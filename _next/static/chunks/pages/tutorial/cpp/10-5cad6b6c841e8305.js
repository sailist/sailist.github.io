(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[77],{8764:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/tutorial/cpp/10",function(){return t(551)}])},551:function(e,n,t){"use strict";t.r(n);var i=t(1527),d=t(6828),h=t(4579);function r(e){let n=Object.assign({h1:"h1",p:"p",h2:"h2",h3:"h3",code:"code"},(0,h.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{children:"多态"}),"\n",(0,i.jsx)(n.p,{children:"多态指的是调用同名函数时根据参数类型的不同执行不同的函数的行为。多态分为静态多态和动态多态，静态多态指在编译阶段函数调用的行为就已经确定，动态多态指函数的调用在运行时确定。"}),"\n",(0,i.jsx)(n.h2,{id:"静态多态",children:"静态多态"}),"\n",(0,i.jsx)(n.p,{children:"同名函数、模板"}),"\n",(0,i.jsx)(n.p,{children:"多态发生在同名函数、模板和存在继承的类成员函数中，其中同名函数是静态多态，在编译阶段函数调用的行为就已经确定；继承的类成员函数是动态多态，函数的行为通过虚函数表在运行时确定。"}),"\n",(0,i.jsx)(n.h3,{id:"为什么不能根据返回类型区分重载",children:"为什么不能根据返回类型区分重载？"}),"\n",(0,i.jsx)(n.p,{children:"从实现上来讲，重载时是根据函数签名来唯一确定一个函数的，而 C++ 中返回值的类型并不包含在函数签名中。"}),"\n",(0,i.jsxs)(n.p,{children:["从理论上来讲，重载的过程，就是根据调用函数的语句来判断调用的具体函数的过程。而在函数调用的过程中，参数的输入是一个必选项，返回值的接收是一个可选项，可以通过",(0,i.jsx)(n.code,{children:"int i = f();"}),"，也可以 ",(0,i.jsx)(n.code,{children:"f();"}),"。用不确定的返回值约束来判定重载函数是一个不优雅的行为。"]}),"\n",(0,i.jsx)(n.p,{children:"从技术上来讲，根据返回类型来区分重载完全可行，定义一套标准/协议/规范外加编译器实现即可。"}),"\n",(0,i.jsx)(n.h2,{id:"动态多态",children:"动态多态"})]})}t(3366),n.default=(0,d.j)({MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,h.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r(e)},pageOpts:{filePath:"pages/tutorial/cpp/10.md",route:"/tutorial/cpp/10",frontMatter:{authors:"sailist",date:"2022-11-09",description:"",draft:!1,title:"多态"},headings:[{depth:1,value:"多态",id:"多态"},{depth:2,value:"静态多态",id:"静态多态"},{depth:3,value:"为什么不能根据返回类型区分重载？",id:"为什么不能根据返回类型区分重载"},{depth:2,value:"动态多态",id:"动态多态"}],title:"多态"},pageNextRoute:"/tutorial/cpp/10"})}},function(e){e.O(0,[6828,9774,2888,179],function(){return e(e.s=8764)}),_N_E=e.O()}]);