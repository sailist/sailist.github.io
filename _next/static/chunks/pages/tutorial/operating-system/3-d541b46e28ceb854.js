(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3908],{8645:function(n,e,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/tutorial/operating-system/3",function(){return i(2126)}])},2126:function(n,e,i){"use strict";i.r(e);var s=i(1527),l=i(6828),t=i(4579);function c(n){let e=Object.assign({h1:"h1",ul:"ul",li:"li",p:"p",img:"img",blockquote:"blockquote",code:"code",h2:"h2",input:"input",a:"a"},(0,t.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{children:"CPU 的执行过程"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["取指令","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"间址"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.li,{children:"分析指令"}),"\n",(0,s.jsx)(e.li,{children:"执行指令"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/images2022-09-25-18-12-45.png",alt:""})}),"\n",(0,s.jsx)(e.h1,{children:"指令周期"}),"\n",(0,s.jsx)(e.p,{children:"CPU 完成一条指令的时间称为指令周期，指令周期可以进一步细分为四个阶段："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["在大多数情况下，CPu 就是按 ",(0,s.jsx)(e.code,{children:"取址->执行->取址->执行"})," 的顺序自动完成工作的。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"不同的指令的执行周期长度不同，如 JUMP 指令没有执行周期，如乘法指令的执行周期比加法指令长："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/images2022-09-25-18-18-14.png",alt:""})}),"\n",(0,s.jsx)(e.p,{children:"一个完整的指令周期可以用如下的流程图表示，其中间址周期和中断周期不一定发生，因此可以用菱形框判断："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/images2022-09-25-18-18-05.png",alt:""})}),"\n",(0,s.jsx)(e.h2,{id:"指令周期的数据流",children:"指令周期的数据流"}),"\n",(0,s.jsx)(e.p,{children:"一个指令周期包含多个计算机的原子操作过程。如："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"取值周期：从程序计数器取地址（PC->MAR）、读地址数据（1->R）、MAR->MDR、MDR->IR、译码 OP(IR)->CU、PC+1"}),"\n",(0,s.jsx)(e.li,{children:"间址周期（Optional）：取指令的地址码部份送至 MAR（Ad(IR)->MAR）、读地址数据（1->R）、MAR->MDR、MDR->Ad(IR)"}),"\n",(0,s.jsx)(e.li,{children:"执行周期：非访存指令、访存指令、转移类指令等"}),"\n"]}),"\n",(0,s.jsx)(e.h1,{children:"指令流水"}),"\n",(0,s.jsx)(e.p,{children:"由于不同的周期会导致设备的空闲，因此通过流水线来加速指令的执行。"}),"\n",(0,s.jsx)(e.p,{children:"一个理想情况下的二级流水可以减少一半的执行时间："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/images2022-09-25-18-23-16.png",alt:""})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"实际执行过程中，因为执行周期大于取址周期，条件转移命令的不可判别等原因，不可能实现减少一半执行时间这种情况。"}),"\n"]}),"\n",(0,s.jsx)(e.h1,{children:"时间管理"}),"\n",(0,s.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(e.a,{href:"https://blog.csdn.net/weixin_43455581/article/details/106249040",children:"https://blog.csdn.net/weixin_43455581/article/details/106249040"})]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"内核需要做的时间管理："}),"\n",(0,s.jsx)(e.p,{children:"1）提供系统调度所使用的 tick 中断"}),"\n",(0,s.jsx)(e.p,{children:"2）维护系统时间"}),"\n",(0,s.jsx)(e.p,{children:"3）维护软件定时器，高速 tcp 和多媒体应用要使 timer 高效精准"}),"\n",(0,s.jsx)(e.p,{children:"为了更好的支持音视频等需求，提出了 hrtimer 这个高精度时钟子系统，为了节约能源，采用了 tickless 子系统。"}),"\n",(0,s.jsx)(e.p,{children:"内核中有两种时间："}),"\n",(0,s.jsx)(e.p,{children:"定时出发滴答的时钟中断，时钟中断用来维护系统时间，保持设备上的时间的正确性。"}),"\n",(0,s.jsx)(e.p,{children:"时钟中断用来控制进程的调度，在每个时钟中断的处理函数中，都会处理一遍进程调度队列，将满足调度的进程放入就绪队列中。"}),"\n",(0,s.jsx)(e.p,{children:"时钟中断可以用来实现用户的定时器设置，但是这种方式实现的定时器精度低且代价昂贵。"}),"\n",(0,s.jsx)(e.p,{children:"另一种可编程的控制器，能够设定时钟时间并返回中断"}),"\n",(0,s.jsx)(e.p,{children:"内核使用一系列的子系统兼容旧的机制，支持新的需求，比如 tickless 方案，hrtimer，时间轮算法等。"}),"\n",(0,s.jsx)(e.h1,{children:"Reference"}),"\n",(0,s.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://blog.csdn.net/weixin_43455581/article/details/106249040",children:"https://blog.csdn.net/weixin_43455581/article/details/106249040"})}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(e.a,{href:"https://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/",children:"https://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"})]}),"\n"]})]})}i(3366),e.default=(0,l.j)({MDXContent:function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)},pageOpts:{filePath:"pages/tutorial/operating-system/3.md",route:"/tutorial/operating-system/3",frontMatter:{authors:"sailist",date:"2022-11-08",description:"",draft:!1,title:"2.CPU"},headings:[{depth:1,value:"CPU 的执行过程",id:"cpu-的执行过程"},{depth:1,value:"指令周期",id:"指令周期"},{depth:2,value:"指令周期的数据流",id:"指令周期的数据流"},{depth:1,value:"指令流水",id:"指令流水"},{depth:1,value:"时间管理",id:"时间管理"},{depth:1,value:"Reference",id:"reference"}],title:"2.CPU"},pageNextRoute:"/tutorial/operating-system/3"})}},function(n){n.O(0,[6828,9774,2888,179],function(){return n(n.s=8645)}),_N_E=n.O()}]);