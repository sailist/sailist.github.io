(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3373],{2308:function(n,i,e){(window.__NEXT_P=window.__NEXT_P||[]).push(["/tutorial/operating-system/5",function(){return e(3559)}])},3559:function(n,i,e){"use strict";e.r(i);var l=e(1527),s=e(6828),d=e(4579);function h(n){let i=Object.assign({h1:"h1",p:"p",h2:"h2",ul:"ul",li:"li",strong:"strong",blockquote:"blockquote",a:"a",h3:"h3",img:"img"},(0,d.ah)(),n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.h1,{children:"锁"}),"\n",(0,l.jsx)(i.p,{children:"锁可以看成是一种对资源的占用声明，表明对其他进程在该资源上读操作或者写操作的 Lock（锁定）。当一个进程对一份资源有读的需求时，就需要声明一个读锁（共享锁），表明该资源对其他所有进程来说只能读；当一个进程对一份资源有写的需求时，就需要声明一个写锁（排它锁），表明该资源不可被其他任何进程占有。"}),"\n",(0,l.jsx)(i.p,{children:"根据具体场景对读/写操作的侧重，就衍生出了各种对锁的叫法。"}),"\n",(0,l.jsx)(i.p,{children:"锁可以在硬件（通过专用于锁的寄存器）或软件层面实现。"}),"\n",(0,l.jsx)(i.p,{children:"? 申请锁->操作->释放锁的过程，称为临界区。"}),"\n",(0,l.jsx)(i.h2,{id:"一些理所当然的锁概念",children:"一些理所当然的锁概念"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["可重入锁：当一个线程的一个方法获得对一个资源的锁时，另一个方法操作该资源",(0,l.jsx)(i.strong,{children:"可以"}),"不被阻塞（即锁是线程级别的，而不是方法级别的）。"]}),"\n",(0,l.jsx)(i.li,{children:"分段锁：细化锁的粒度提高性能。"}),"\n",(0,l.jsx)(i.li,{children:"公平锁/非公平锁：表示锁的获取顺序是公平的（所有的线程入先出）的还是非公平的（不同线程有优先级）。"}),"\n",(0,l.jsx)(i.li,{children:"读优先锁/写优先锁/公平读写锁：是申请读锁优先还是写锁优先还是先入先出。读优先或写优先都会导致【饥饿】现象，即另外一种操作无法申请到锁。"}),"\n"]}),"\n",(0,l.jsx)(i.h1,{children:"偏向锁/轻量级锁/重量级锁"}),"\n",(0,l.jsx)(i.p,{children:"一种启发式的分配锁的方式。"}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.a,{href:"https://www.jianshu.com/p/338db6d64c1e",children:"https://www.jianshu.com/p/338db6d64c1e"})}),"\n"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。"}),"\n",(0,l.jsx)(i.li,{children:"轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。"}),"\n",(0,l.jsx)(i.li,{children:"重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。"}),"\n"]}),"\n",(0,l.jsx)(i.h1,{children:"自旋锁 & 互斥锁"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"自旋锁是让线程在申请锁的过程中不断检查该锁是否可以获取。线程在这一过程中处于无限循环（忙等待）状态。自旋锁避免了进程上下文的切换开销，适用于多核、短时间阻塞的场景。"}),"\n",(0,l.jsx)(i.li,{children:"互斥锁则会在申请锁失败时放弃获取（并休眠），等待在锁空闲时被唤醒。"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"排号自旋锁",children:"排号自旋锁"}),"\n",(0,l.jsx)(i.p,{children:"排号自旋锁类似于饭店排号，每个申请自旋锁的线程按序号分配锁的编号 i，当一个线程释放锁时，锁编号自动加 1，让下一个线程在检查时直接获得锁。（申请锁的开销由 $O(N)$ 降为 $O(1)$ ）"}),"\n",(0,l.jsx)(i.h1,{children:"乐观&悲观并发控制"}),"\n",(0,l.jsx)(i.p,{children:"这里的乐观和悲观表示的是对资源是否会被更新、更新是否频繁的态度。"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsx)(i.p,{children:"乐观并发控制（Optimistic Concurrency Control），也叫乐观锁。该锁假设并发访问中数据不会更新（或不会被频繁更新）。因此采用先修改再确认的激进策略修改数据。"}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsx)(i.p,{children:"悲观并发控制(Pessimistic Concurrency Control)，也被翻译为悲观锁。该锁假设并发访问中数据会被频繁更新，因此采用先取锁再访问的保守策略"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"cas-算法",children:"CAS 算法"}),"\n",(0,l.jsx)(i.p,{children:"CAS(Compare and Swap) 是一种无锁算法，一般用于乐观并发控制场景中。"}),"\n",(0,l.jsx)(i.p,{children:"CAS 操作涉及 3 个操作数，内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B。"}),"\n",(0,l.jsx)(i.p,{children:"CAS 假设共享数据不会被其他进程修改。因此当只有一个进程有写需求时，CAS 算法能够比较高效的更新内存值。当有两个及以上的进程并发更新时，没有检查通过的进程会不断循环回滚事务。"}),"\n",(0,l.jsx)(i.h3,{id:"aba-问题",children:"ABA 问题"}),"\n",(0,l.jsx)(i.p,{children:"一个线程将内存值从 A 改为 B，另一个线程又从 B 改回到 A。该问题可以通过在变量前面添加版本号的方式来解决。"}),"\n",(0,l.jsx)(i.h1,{children:"临界区"}),"\n",(0,l.jsx)(i.p,{children:"一次仅允许一个进程使用的资源称为临界资源。临界区问题（critical-section problem）是设计一个用于多进程协作的协议，保证临界资源能够被有效利用。"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"有效利用"}),"的具体要求："]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"互斥：同一时间只有一个进程在临界区（保证原子性，即数据更新不会出错）"}),"\n",(0,l.jsx)(i.li,{children:"前进：所有进程不能阻塞（保证系统整体不会阻塞）"}),"\n",(0,l.jsx)(i.li,{children:"有限等待：每个进程不能存在饥饿（保证公平）"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.img,{src:"/images2022-09-28-12-46-28.png",alt:""})}),"\n",(0,l.jsx)(i.h1,{children:"原子化"}),"\n",(0,l.jsx)(i.p,{children:"原子操作指的是最小的不可并行化的对共享资源的操作。当说一个操作（比如一段代码）是原子化的，意味着同一时间只能有一个线程执行该操作（代码）。"}),"\n",(0,l.jsx)(i.h2,{id:"原子操作-test-and-set",children:"原子操作: test-and-set"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"[ ]"}),"\n"]}),"\n",(0,l.jsx)(i.h1,{children:"死锁"}),"\n",(0,l.jsx)(i.p,{children:"所有线程都在等待其他线程已经申请的资源的释放。"}),"\n",(0,l.jsx)(i.p,{children:"死锁出现的必要条件："}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"互斥"}),"\n",(0,l.jsxs)(i.li,{children:["占有并等待","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"循环等待"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.li,{children:"非抢占"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"应对死锁的方法："}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["预防","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"死锁预防：保证死锁条件至少一个不出现"}),"\n",(0,l.jsx)(i.li,{children:"死锁避免：要求事先获得进程对所有资源的要求，通过资源分配图算法或银行家算法避免会导致死锁的资源分配。"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["检测并恢复","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"死锁检测：有各种检测算法"}),"\n",(0,l.jsx)(i.li,{children:"死锁恢复：终止进程 & 抢占资源"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.li,{children:"忽视（目前主流方法）"}),"\n"]})]})}e(3366),i.default=(0,s.j)({MDXContent:function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:i}=Object.assign({},(0,d.ah)(),n.components);return i?(0,l.jsx)(i,{...n,children:(0,l.jsx)(h,{...n})}):h(n)},pageOpts:{filePath:"pages/tutorial/operating-system/5.md",route:"/tutorial/operating-system/5",frontMatter:{authors:"sailist",date:"2022-10-26",description:"",draft:!1,title:"4.1.锁与死锁"},headings:[{depth:1,value:"锁",id:"锁"},{depth:2,value:"一些理所当然的锁概念",id:"一些理所当然的锁概念"},{depth:1,value:"偏向锁/轻量级锁/重量级锁",id:"偏向锁轻量级锁重量级锁"},{depth:1,value:"自旋锁 & 互斥锁",id:"自旋锁--互斥锁"},{depth:2,value:"排号自旋锁",id:"排号自旋锁"},{depth:1,value:"乐观&悲观并发控制",id:"乐观悲观并发控制"},{depth:2,value:"CAS 算法",id:"cas-算法"},{depth:3,value:"ABA 问题",id:"aba-问题"},{depth:1,value:"临界区",id:"临界区"},{depth:1,value:"原子化",id:"原子化"},{depth:2,value:"原子操作: test-and-set",id:"原子操作-test-and-set"},{depth:1,value:"死锁",id:"死锁"}],title:"4.1.锁与死锁"},pageNextRoute:"/tutorial/operating-system/5"})}},function(n){n.O(0,[6828,9774,2888,179],function(){return n(n.s=2308)}),_N_E=n.O()}]);