(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2740],{4978:function(e,s,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/tutorial/operating-system/linux-kernel/7",function(){return n(9618)}])},9618:function(e,s,n){"use strict";n.r(s);var l=n(1527),t=n(6828),i=n(4579);function r(e){let s=Object.assign({h1:"h1",p:"p",code:"code",pre:"pre",span:"span",img:"img",h3:"h3",ul:"ul",li:"li",strong:"strong",h2:"h2",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",a:"a",blockquote:"blockquote",input:"input"},(0,i.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(s.h1,{children:"分页"}),"\n",(0,l.jsxs)(s.p,{children:["每个物理页在 Linux 中都会分配一个 ",(0,l.jsx)(s.code,{children:"<mmtypes.h> struct page"})," 结构进行管理。"]}),"\n",(0,l.jsx)(s.pre,{"data-language":"c++","data-theme":"default",children:(0,l.jsxs)(s.code,{"data-language":"c++","data-theme":"default",children:[(0,l.jsx)(s.span,{className:"line",children:(0,l.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"struct page {"})}),"\n",(0,l.jsx)(s.span,{className:"line",children:(0,l.jsx)(s.span,{style:{color:"var(--shiki-color-text)"}})}),"\n",(0,l.jsx)(s.span,{className:"line",children:(0,l.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"}"})})]})}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.img,{src:"/images2022-11-17-14-23-53.png",alt:""})}),"\n",(0,l.jsx)(s.p,{children:"页表实际上是硬件和软件合作的产物，虚拟内存和物理内存都是由操作系统管理的，虚拟地址到物理地址的映射也是软件进行设置，这是软件层面。"}),"\n",(0,l.jsx)(s.p,{children:"而硬件层面，MMU 规定了软件需要将存储页表的物理基地址提交给特定的寄存器中，且保证每一级页表的内容需要占用连续的物理地址，这样 MMU 才能通过地址偏移找到对应的物理地址。"}),"\n",(0,l.jsx)(s.h3,{id:"slab-分配器",children:"Slab 分配器"}),"\n",(0,l.jsx)(s.pre,{"data-language":"text","data-theme":"default",children:(0,l.jsxs)(s.code,{"data-language":"text","data-theme":"default",children:[(0,l.jsx)(s.span,{className:"line",children:(0,l.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"SMP 对称多处理器支持"})}),"\n",(0,l.jsx)(s.span,{className:"line",children:(0,l.jsx)(s.span,{style:{color:"var(--shiki-color-text)"}})}),"\n",(0,l.jsx)(s.span,{className:"line",children:(0,l.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"在对称多处理系统上，在操作系统的支持下，无论行程是处于用户空间，或是核心空间，都可以分配到任何一个处理器上运行。因此，行程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。"})})]})}),"\n",(0,l.jsx)(s.h1,{children:"高端内存"}),"\n",(0,l.jsx)(s.p,{children:"高端内存是非常容易混淆的点，这主要包括以下几个问题："}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"什么是高端内存"}),"\n",(0,l.jsx)(s.li,{children:"为什么需要高端内存"}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"对虚拟内存，高端内存指内核空间的 128 MB。\n对物理内存，高端内存指的是"}),"\n",(0,l.jsx)(s.h1,{children:"MMU"}),"\n",(0,l.jsx)(s.p,{children:"页表是软件实现的，但是页表的查找是 MMU 完成的，所以硬件定义了页表的实现规则，软件可以做的只有选择页表的级数，是否使用 huge page 以及填充对应的权限标志位。"}),"\n",(0,l.jsx)(s.p,{children:"如果处理器没有 MMU，或者有 MMU 但没有启用，CPU 执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为 PA（Physical Address，以下简称 PA），如下图所示。"}),"\n",(0,l.jsxs)(s.p,{children:["如果处理器启用了 MMU，CPU 执行单元发出的",(0,l.jsx)(s.strong,{children:"所有内存地址"}),"将被 MMU 截获，",(0,l.jsx)(s.strong,{children:"从 CPU 到 MMU 的地址称为虚拟地址"}),"（Virtual Address，以下简称 VA），而 MMU 将这个地址翻译成另一个地址发到 CPU 芯片的外部地址引脚上，也就是将 VA 映射成 PA，如下图所示。"]}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.img,{src:"/images2022-11-17-17-09-46.png",alt:""})}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"TTBR0 寄存器"}),"\n",(0,l.jsx)(s.li,{children:"TTBCR 寄存器"}),"\n",(0,l.jsx)(s.li,{children:"MMU 使能寄存器：控制 MMU 是否开启。在开启 MMU 之前，页表就必须准备好，但是并不要求该页表是完整的，实际上在初始化过程中，可以只建立需要访问的虚拟地址对应的临时映射页表即可，页表的配置实际上是存在一定的灵活性的。"}),"\n",(0,l.jsxs)(s.li,{children:["PGD、PTE 页表：一级页表和二级页表","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"PGD（页全局目录），pgd_t，指向 PMD"}),"\n",(0,l.jsx)(s.li,{children:"PMD（中间页目录）， pmd_t，指向 PTE"}),"\n",(0,l.jsx)(s.li,{children:"PTE（页表），pte_t，指向物理页面"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.img,{src:"/images2022-11-17-18-22-58.png",alt:""})}),"\n",(0,l.jsx)(s.h2,{id:"页表缓存",children:"页表缓存"}),"\n",(0,l.jsx)(s.p,{children:"虚拟内存-> 物理内存转换时查询物理地址的顺序： TLB -> paging structure caches -> 普通 cache 中的页表 -> 内存中的页表"}),"\n",(0,l.jsx)(s.h1,{children:"大页"}),"\n",(0,l.jsx)(s.p,{children:"large page 的使用可以减少页表的级数，也就减少了查找页表的内存访问次数，而且对于同样 entries 数目的 TLB，可以扩大 TLB 对内存地址的覆盖范围，减小 TLB miss 的概率。此外，因为页表本身也要占用内存空间，减少页表的大小也可以节约那么一丢丢的内存。"}),"\n",(0,l.jsx)(s.p,{children:"当然，使用 large page 也会带来一些问题，比如："}),"\n",(0,l.jsx)(s.p,{children:"由于各种内存操作基本都要求按照 page 对齐，比如一个可执行文件映射到进程地址空间，根据文件大小的不同，平均算下来会浪费掉半个 page size 的物理内存，使用 large page 的话这个消耗就显得比较大了。\n系统运行一段时间后，会很难再也大块的连续物理内存，这时分配 large page 将会变的很困难，所以通常需要在系统初始化的时候就划分出一段物理内存给 large page 用（类似于 DMA 的内存分配），这样就减少了一些灵活性。\n动态 large page（THP）在换出到外部的 flash/disk 和从 flash/disk 换入物理内存的过程会比 normal size 的 page 带来更大的开销（可参考这篇文章）。"}),"\n",(0,l.jsx)(s.h1,{children:"操作内存的过程"}),"\n",(0,l.jsx)(s.h1,{children:"内核对用户空间的访存处理"}),"\n",(0,l.jsx)(s.p,{children:"在内核看来，用户态提供的虚拟地址是不可信的，所以在一旦在内核态访问用户态内存发生缺页中断，处理起来是非常棘手的。"}),"\n",(0,l.jsx)(s.p,{children:"Linux 内核的做法是提供了一张 异常处理表 ，使用专有的函数来访问用户态内存。类似 try-catch 块一般。具体详情可参见 copy_to_user/copy_from_user 的实现以及内核文档 Documentation/x86/exception-tables.txt 的描述。"}),"\n",(0,l.jsx)(s.p,{children:"在 copy_from_user 时，会去进行指针检查，然后如果没有映射，会触发 page_fault,如果指针不合法，也会检查。这句话是重点！也正是 copy_from_user 的作用所在。"}),"\n",(0,l.jsx)(s.p,{children:"就 LINUX 内存管理机制来说，在 x86 平台下用 CR3 寄存器来保存页目录表的物理地址，无论内核态或用户态使用同一张页目录表，用户态或内核态都是通过同一个页目录找到线性地址对应的物理地址。因此内核态可以通过页目录表找到用户态指针指向的地址，这样就可以不使用 copy_from_user 来直接操作用户态传入内核的指针(只要这个指针合法)，用户态不能直接使用内核指针的主要原因是因为权限不够(ring3 不能访问 ring0 地址空间)。"}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.img,{src:"/images2022-11-17-18-00-28.png",alt:""})}),"\n",(0,l.jsx)(s.p,{children:"内核可以通过以下函数间接的访问用户空间："}),"\n",(0,l.jsxs)(s.table,{children:[(0,l.jsx)(s.thead,{children:(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.th,{}),(0,l.jsx)(s.th,{})]})}),(0,l.jsxs)(s.tbody,{children:[(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{children:"access_ok"}),(0,l.jsx)(s.td,{children:"Checks the validity of the user space memory pointer"})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{children:"get_user"}),(0,l.jsx)(s.td,{children:"Gets a simple variable from user space"})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{children:"put_user"}),(0,l.jsx)(s.td,{children:"Puts a simple variable to user space"})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{children:"clear_user"}),(0,l.jsx)(s.td,{children:"Clears, or zeros, a block in user space"})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{children:"copy_to_user"}),(0,l.jsx)(s.td,{children:"Copies a block of data from the kernel to user space"})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{children:"copy_from_user"}),(0,l.jsx)(s.td,{children:"Copies a block of data from user space to the kernel"})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{children:"strnlen_user"}),(0,l.jsx)(s.td,{children:"Gets the size of a string buffer in user space"})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{children:"strncpy_from_user"}),(0,l.jsx)(s.td,{children:"Copies a string from user space into the kernel"})]})]})]}),"\n",(0,l.jsx)(s.p,{children:"内核函数却不能直接解引用用户空间的指针，基于以下原因："}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsx)(s.p,{children:"用户空间的指针指向的地址可能在内核运行期间无效"}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsx)(s.p,{children:"即使指针有效但是指针指向的数据却不驻留在内存中，就会造成缺页异常"}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsx)(s.p,{children:"指针可能由于程序的恶意或错误产生，直接访问就会造成系统的不稳定"}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.a,{href:"https://blog.csdn.net/m0_47696151/article/details/118770472",children:"https://blog.csdn.net/m0_47696151/article/details/118770472"})}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.h1,{children:"Linux 内核如何判断地址是否位于用户空间？"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.a,{href:"https://juejin.cn/post/6950275689345974308",children:"https://juejin.cn/post/6950275689345974308"})}),"\n"]}),"\n",(0,l.jsx)(s.pre,{"data-language":"text","data-theme":"default",children:(0,l.jsxs)(s.code,{"data-language":"text","data-theme":"default",children:[(0,l.jsx)(s.span,{className:"line",children:(0,l.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"如果(addr + size) >= (current_thread_info()->addr_limit) - 1，返回非零值"})}),"\n",(0,l.jsx)(s.span,{className:"line",children:(0,l.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"如果(addr + size) < (current_thread_info()->addr_limit)，返回零"})})]})}),"\n",(0,l.jsx)(s.h2,{id:"vm_area_struct",children:"vm_area_struct"}),"\n",(0,l.jsx)(s.p,{children:"进程的 task_struct 中存了 mm_struct 的指针 mm，task_struct 中存了 vm_area_struct 的链表结构"}),"\n",(0,l.jsx)(s.p,{children:"每个 vm_area_struct 都代表虚拟内存空间中一段连续的、具有相同访问权限的区域。包含下面的成员："}),"\n",(0,l.jsx)(s.p,{children:"vm_start：指向这个区域的起始处\nvm_end：指向这个区域的结束处\nvm_prot：描述这个区域所有页的读写许可权限\nvm_flags：描述这个区域内的页面是与其他进程共享的还是私有的\nvm_next：指向链表下一个区域结构\n当访问某个页面发生缺页中断，需要查询这个页面属于哪一个 vm_area_struct。而为了加快查找的速度，内核将 vm_area_struct 又组织成了一个红黑树。"}),"\n",(0,l.jsx)(s.p,{children:"根据查找的结果，有三种处理方式："}),"\n",(0,l.jsxs)(s.p,{children:["如果不在任何一个区域中，说明这个页面是非法的，触发段错误\n如果内存访问不合法，比如想要写这个页面，而这个页面所在的区域是只读的，这时候触发保护异常，中止程序。\n前两种情况都不存在，就选择一个物理页面来缓存，必要的时候要选择牺牲页面，还要将脏页写回。\n————————————————\n版权声明：本文为 CSDN 博主「不动心、」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：",(0,l.jsx)(s.a,{href:"https://blog.csdn.net/sinat_41619762/article/details/118972204",children:"https://blog.csdn.net/sinat_41619762/article/details/118972204"})]}),"\n",(0,l.jsx)(s.h1,{children:"CR3 寄存器"}),"\n",(0,l.jsx)(s.p,{children:"x86 平台上，在进程切换的时候，软件不需要显示的调用 tlb flush 函数，在 switch_mm 函数中会用 next task 中的 mm->pgd 加载 CR3 寄存器，这时候 load cr3 的动作会导致本 cpu 中的 local tlb entry 被全部 flush 掉。"}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.a,{href:"https://blog.csdn.net/SweeNeil/article/details/106171361",children:"https://blog.csdn.net/SweeNeil/article/details/106171361"})}),"\n",(0,l.jsx)(s.h1,{children:"缺页中断"}),"\n",(0,l.jsxs)(s.blockquote,{children:["\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.a,{href:"https://zhuanlan.zhihu.com/p/488042885",children:"https://zhuanlan.zhihu.com/p/488042885"})}),"\n"]}),"\n",(0,l.jsx)(s.h1,{children:"进程的内存分配"}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.img,{src:"/images2022-11-17-21-15-16.png",alt:""})}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.img,{src:"/images2022-11-17-21-37-32.png",alt:""})}),"\n",(0,l.jsx)(s.h2,{id:"内存描述符",children:"内存描述符"}),"\n",(0,l.jsxs)(s.p,{children:["内存使用内存描述符 ",(0,l.jsx)(s.code,{children:"mm_struct"})," 表示进程的地址空间"]}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.img,{src:"/images2022-11-18-09-34-26.png",alt:""})}),"\n",(0,l.jsx)(s.h1,{children:"vm_area_struct"}),"\n",(0,l.jsx)(s.p,{children:"虚拟页的三种状态的实际含义如下："}),"\n",(0,l.jsx)(s.p,{children:"未分配虚拟页，指的是没有使用 mmap 建立 vm_area_struct，所以也就没有对应到具体的页表项\n已分配虚拟页，未映射到物理页，指的是已经使用了 mmap 建立的 vm_area_struct，可以映射到对应的页表项，但是页表项没有指向具体的物理页\n已分配虚拟页，已映射到物理页，指的是已经使用了 mmap 建立的 vm_area_struct，可以映射到对应的页表项，并且页表项指向具体的物理页"}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.a,{href:"https://zhuanlan.zhihu.com/p/431713219",children:"https://zhuanlan.zhihu.com/p/431713219"})}),"\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.img,{src:"/images2022-11-18-09-53-42.png",alt:""}),"\nmmap 函数就是要创建一个新的 vm_area_struct 结构，并将其与文件的物理磁盘地址相连"]}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.a,{href:"https://blog.csdn.net/Windgs_YF/article/details/114587330",children:"https://blog.csdn.net/Windgs_YF/article/details/114587330"})}),"\n",(0,l.jsx)(s.h1,{children:"do_page_fault"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"good_area"}),"\n",(0,l.jsx)(s.li,{children:"bad_area：用户空间访问未在 vma 中分配的空间"}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.img,{src:"/images2022-11-18-10-26-28.png",alt:""})}),"\n",(0,l.jsx)(s.h1,{children:"申请内存"}),"\n",(0,l.jsx)(s.p,{children:"包括两种情况"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"需要一个空白的内存，作为函数调用栈空间或堆空间"}),"\n",(0,l.jsx)(s.li,{children:"因为按需调页或交换，需要从磁盘交换写入到内存中"}),"\n"]}),"\n",(0,l.jsx)(s.h1,{children:"mmap"}),"\n",(0,l.jsx)(s.p,{children:"malloc 的实现,它有一个 chunk 仓库管理 128 字节以下的小块(chunk 仓库类似链表数组,)。之所以有 chunk 仓库是因为为了避免多次系统调用,快速获取内存块,因为从用户态到内核态的转换很耗时的(改变 cs,ds,ss,各种参数压栈等等),而有了 chunk 仓库可以直接在用户态获取内存块,chunk 仓库类似链表数组,其块大小由 2 的 n 次方构成,最大的块是 128 字节. malloc 如果分配超过了 128 字节将调用 brk 系统调用(改变堆界限,同时创建 vma) 如果 malloc 分配超大内存（具体是多少忘了）,那就直接 mmap 匿名映射了创建 vma 结构。"}),"\n",(0,l.jsxs)(s.p,{children:["作者：Tools boy\n链接：",(0,l.jsx)(s.a,{href:"https://www.zhihu.com/question/57653599/answer/154146640",children:"https://www.zhihu.com/question/57653599/answer/154146640"}),"\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]}),"\n",(0,l.jsx)(s.h1,{children:"内核访存"}),"\n",(0,l.jsx)(s.p,{children:"进程访存通过 CR3 基地址寄存器"}),"\n",(0,l.jsxs)(s.p,{children:["内核访存低端地址 896Mb 内直接减 ",(0,l.jsx)(s.code,{children:"0xC0000000"})," 得到，高端地址通过动态临时的建立到其他全部物理空间的映射"]}),"\n",(0,l.jsx)(s.h1,{children:"Reference"}),"\n",(0,l.jsxs)(s.ul,{className:"contains-task-list",children:["\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.a,{href:"https://zhuanlan.zhihu.com/p/358891862",children:"https://zhuanlan.zhihu.com/p/358891862"})}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.a,{href:"https://blog.csdn.net/maokelong95/article/details/51989081",children:"https://blog.csdn.net/maokelong95/article/details/51989081"})}),"\n"]}),"\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ",(0,l.jsx)(s.a,{href:"https://blog.csdn.net/jasonchen_gbd/article/details/79461385",children:"https://blog.csdn.net/jasonchen_gbd/article/details/79461385"})]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ",(0,l.jsx)(s.a,{href:"https://zhuanlan.zhihu.com/p/556563925",children:"https://zhuanlan.zhihu.com/p/556563925"})]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ",(0,l.jsx)(s.a,{href:"https://blog.csdn.net/Apollon_krj/article/details/54565768",children:"https://blog.csdn.net/Apollon_krj/article/details/54565768"})]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsx)(s.p,{children:"高端内存"}),"\n",(0,l.jsxs)(s.ul,{className:"contains-task-list",children:["\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ",(0,l.jsx)(s.a,{href:"https://www.zhihu.com/question/280526042",children:"https://www.zhihu.com/question/280526042"})]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsx)(s.p,{children:"MMU 硬件对页表的支持"}),"\n",(0,l.jsxs)(s.ul,{className:"contains-task-list",children:["\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ",(0,l.jsx)(s.a,{href:"https://zhuanlan.zhihu.com/p/363856783",children:"https://zhuanlan.zhihu.com/p/363856783"})]}),"\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ",(0,l.jsx)(s.a,{href:"https://zhuanlan.zhihu.com/p/67813716",children:"https://zhuanlan.zhihu.com/p/67813716"})]}),"\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ",(0,l.jsx)(s.a,{href:"https://zhuanlan.zhihu.com/p/65298260",children:"https://zhuanlan.zhihu.com/p/65298260"})]}),"\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ",(0,l.jsx)(s.a,{href:"https://cloud.tencent.com/developer/article/1815567",children:"https://cloud.tencent.com/developer/article/1815567"})]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ","大页"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ","paging struct caches ",(0,l.jsx)(s.a,{href:"https://zhuanlan.zhihu.com/p/65774094",children:"https://zhuanlan.zhihu.com/p/65774094"})]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:["copy_to_user： ",(0,l.jsx)(s.a,{href:"https://blog.csdn.net/dog250/article/details/106105523",children:"https://blog.csdn.net/dog250/article/details/106105523"})]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsx)(s.p,{children:"综述"}),"\n",(0,l.jsxs)(s.ul,{className:"contains-task-list",children:["\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ",(0,l.jsx)(s.a,{href:"https://www.cnblogs.com/titer1/archive/2012/04/10/2440238.html",children:"https://www.cnblogs.com/titer1/archive/2012/04/10/2440238.html"})]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsx)(s.p,{children:"Buddy 系统"}),"\n",(0,l.jsxs)(s.ul,{className:"contains-task-list",children:["\n",(0,l.jsxs)(s.li,{className:"task-list-item",children:[(0,l.jsx)(s.input,{type:"checkbox",disabled:!0})," ",(0,l.jsx)(s.a,{href:"https://zhuanlan.zhihu.com/p/363928310",children:"https://zhuanlan.zhihu.com/p/363928310"})]}),"\n"]}),"\n"]}),"\n"]})]})}n(3366),s.default=(0,t.j)({MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,i.ah)(),e.components);return s?(0,l.jsx)(s,{...e,children:(0,l.jsx)(r,{...e})}):r(e)},pageOpts:{filePath:"pages/tutorial/operating-system/linux-kernel/7.md",route:"/tutorial/operating-system/linux-kernel/7",frontMatter:{authors:"sailist",date:"2022-11-23",description:"",draft:!1,title:"内存管理"},headings:[{depth:1,value:"分页",id:"分页"},{depth:3,value:"Slab 分配器",id:"slab-分配器"},{depth:1,value:"高端内存",id:"高端内存"},{depth:1,value:"MMU",id:"mmu"},{depth:2,value:"页表缓存",id:"页表缓存"},{depth:1,value:"大页",id:"大页"},{depth:1,value:"操作内存的过程",id:"操作内存的过程"},{depth:1,value:"内核对用户空间的访存处理",id:"内核对用户空间的访存处理"},{depth:1,value:"Linux 内核如何判断地址是否位于用户空间？",id:"linux-内核如何判断地址是否位于用户空间"},{depth:2,value:"vm_area_struct",id:"vm_area_struct"},{depth:1,value:"CR3 寄存器",id:"cr3-寄存器"},{depth:1,value:"缺页中断",id:"缺页中断"},{depth:1,value:"进程的内存分配",id:"进程的内存分配"},{depth:2,value:"内存描述符",id:"内存描述符"},{depth:1,value:"vm_area_struct",id:"vm_area_struct-1"},{depth:1,value:"do_page_fault",id:"do_page_fault"},{depth:1,value:"申请内存",id:"申请内存"},{depth:1,value:"mmap",id:"mmap"},{depth:1,value:"内核访存",id:"内核访存"},{depth:1,value:"Reference",id:"reference"}],title:"内存管理"},pageNextRoute:"/tutorial/operating-system/linux-kernel/7"})}},function(e){e.O(0,[6828,9774,2888,179],function(){return e(e.s=4978)}),_N_E=e.O()}]);