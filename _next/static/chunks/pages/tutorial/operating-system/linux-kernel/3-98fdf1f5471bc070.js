(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5287],{6084:function(e,l,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/tutorial/operating-system/linux-kernel/3",function(){return s(1545)}])},1545:function(e,l,s){"use strict";s.r(l);var n=s(1527),d=s(6828),i=s(4579);function c(e){let l=Object.assign({h1:"h1",p:"p",code:"code",h2:"h2",h3:"h3",pre:"pre",span:"span",img:"img",a:"a",ul:"ul",li:"li",input:"input"},(0,i.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(l.h1,{children:"内存分配"}),"\n",(0,n.jsxs)(l.p,{children:["在 NUMA 架构下，物理页面按照 ",(0,n.jsx)(l.code,{children:"node -> zones -> pages"})," 的树形结构进行管理。"]}),"\n",(0,n.jsx)(l.h2,{id:"内核内存分配",children:"内核内存分配"}),"\n",(0,n.jsx)(l.h3,{id:"buddy",children:"buddy"}),"\n",(0,n.jsxs)(l.p,{children:["Linux 内核中有多种分配内存的方式，其中最基本的是 buddy 内存分配器，该分配器以页为单位，通过 ",(0,n.jsx)(l.code,{children:"alloc_pages"})," 对外提供可用的物理页。"]}),"\n",(0,n.jsx)(l.pre,{"data-language":"c","data-theme":"default",children:(0,n.jsx)(l.code,{"data-language":"c","data-theme":"default",children:(0,n.jsxs)(l.span,{className:"line",children:[(0,n.jsx)(l.span,{style:{color:"var(--shiki-token-keyword)"},children:"struct"}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-color-text)"},children:" page "}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-token-keyword)"},children:"*"}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-token-function)"},children:"alloc_pages"}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-color-text)"},children:"("}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-token-keyword)"},children:"unsigned"}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-token-keyword)"},children:"int"}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-color-text)"},children:" gfp_mask"}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-token-punctuation)"},children:","}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-token-keyword)"},children:"unsigned"}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-token-keyword)"},children:"int"}),(0,n.jsx)(l.span,{style:{color:"var(--shiki-color-text)"},children:" order)"})]})})}),"\n",(0,n.jsx)(l.p,{children:"将空闲页面按照 order 的大小分配挂到不同的 order 链表中。"}),"\n",(0,n.jsx)(l.p,{children:"buddy 分配器内部维护一个链表数组，空闲页面（free pages）按照 order 大小分配到不同的链表中。其中 order 表示 2 的阶数，一个大小为 order 的链表内部以 $2^order$ 为单位存储空闲页面块。"}),"\n",(0,n.jsxs)(l.p,{children:["当内核通过 ",(0,n.jsx)(l.code,{children:"alloc_pages"})," 申请 ",(0,n.jsx)(l.code,{children:"order=n"})," 的页面时，buddy 分配器会判断 ",(0,n.jsx)(l.code,{children:"order=n"})," 的链表内是否有空闲页面，如果有则直接分配，如果没有，则从 ",(0,n.jsx)(l.code,{children:"order=n+1"})," 的链表中取出一个空闲页面拆分成两个 ",(0,n.jsx)(l.code,{children:"order=n"})," 的空闲页面挂载到 ",(0,n.jsx)(l.code,{children:"order=n"})," 的链表下，并返回其中一个。"]}),"\n",(0,n.jsx)(l.p,{children:"当释放某个页面时，将释放的页面挂载到相同 order 的链表下，如果发现连续地址，则按照类似的方式反向向上合并。"}),"\n",(0,n.jsx)(l.p,{children:(0,n.jsx)(l.img,{src:"/images2022-11-23-12-23-36.png",alt:""})}),"\n",(0,n.jsxs)(l.p,{children:["每个 ",(0,n.jsx)(l.code,{children:"zone"})," 内部会维护一个水位线数组，包括",(0,n.jsx)(l.code,{children:"WMARK_HIHG"}),"/",(0,n.jsx)(l.code,{children:"WMARK_LOW"}),"/",(0,n.jsx)(l.code,{children:"WMARK_MIN"}),"，分别表示内存足够，内存较少和内存见底，内存余量小于 ",(0,n.jsx)(l.code,{children:"WMARK_LOW"})," 时，某些内存申请可能会失败；内存余量小于 ",(0,n.jsx)(l.code,{children:"WMARK_MIN"})," 时，会触发内存回收、交换等机制避免 OOM。"]}),"\n",(0,n.jsx)(l.h3,{id:"slab",children:"Slab"}),"\n",(0,n.jsx)(l.p,{children:"buddy 内存分配是最底层的分配机制，从 buddy 分配器申请的物理内存的最小单位是一页，对于更小的内核结构体的内存需求，Linux 内核通过 Slab 分配器进行管理。"}),"\n",(0,n.jsxs)(l.p,{children:["Slab 分配器以字节为单位分配内存，在分配过程中，上游是从 Buddy 分配器申请得到的以页为单位的内存，下游则向操作系统和应用提供 ",(0,n.jsx)(l.code,{children:"kmalloc"})," 和 ",(0,n.jsx)(l.code,{children:"kfree"})," 接口。为了减少内存碎片，针对不同的专用或通用需求，一个操作系统可以存在多个 Slab，如对 ",(0,n.jsx)(l.code,{children:"vm_area_struct"}),"、",(0,n.jsx)(l.code,{children:"mm_struct"})," 等结构的分配是通过专用 Slab 分配器完成的。"]}),"\n",(0,n.jsxs)(l.p,{children:["一个 buddy 分配器会分配多个 Slab 分配器，用来处理不同的内存申请大小，每个 Slab 分配器维护一个 ",(0,n.jsx)(l.code,{children:"kmem_cache"})," 结构，来描述从 buddy 申请到的物理内存。"]}),"\n",(0,n.jsx)(l.p,{children:(0,n.jsx)(l.img,{src:"/images2022-11-17-16-25-10.png",alt:""})}),"\n",(0,n.jsx)(l.h3,{id:"vmalloc",children:"vmalloc"}),"\n",(0,n.jsxs)(l.p,{children:["Slab 提供的 ",(0,n.jsx)(l.code,{children:"kmalloc"})," 保证函数只从低端内存（lowmem）申请内存，根据低端内存的映射规则，其申请到的内存在物理上也是连续的。但在 Linux 启动一段时间后，可能无法满足较大的连续物理内存的申请。对于这部分特殊需要，Linux 内核提供了 ",(0,n.jsx)(l.code,{children:"vmalloc"}),"/",(0,n.jsx)(l.code,{children:"vfree"})," 接口。"]}),"\n",(0,n.jsxs)(l.p,{children:[(0,n.jsx)(l.code,{children:"vmalloc"})," 仍然基于 buddy，和 slab 不同的是，",(0,n.jsx)(l.code,{children:"vmalloc"})," 可以同时从高端和低端内存申请物理内存。因此 ",(0,n.jsx)(l.code,{children:"vmalloc"})," 申请到的连续的虚拟内存背后对应的物理内存地址可能不连续。"]}),"\n",(0,n.jsxs)(l.p,{children:["根据",(0,n.jsx)(l.a,{href:"http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch11lev1sec5.html#:~:text=The%20vmalloc()%20function%20only,of%20the%20logical%20address%20space.",children:"这里"}),"的介绍，Slab 方式提供的 ",(0,n.jsx)(l.code,{children:"kmalloc"})," 和 ",(0,n.jsx)(l.code,{children:"kfree"})," 接口能够处理大多数情况内核对内存的需求，且 ",(0,n.jsx)(l.code,{children:"vmalloc"})," 对页表的依赖导致其申请到的内存的性能远低于 ",(0,n.jsx)(l.code,{children:"kmalloc"}),"，因此，除非需要获取一段超大区域的内存，否则没有必要使用 ",(0,n.jsx)(l.code,{children:"vmalloc"})]}),"\n",(0,n.jsx)(l.h2,{id:"进程内存分配",children:"进程内存分配"}),"\n",(0,n.jsxs)(l.p,{children:["用户态的 ",(0,n.jsx)(l.code,{children:"malloc"})," 是通过 ",(0,n.jsx)(l.code,{children:"brk"}),"/",(0,n.jsx)(l.code,{children:"mmap"})," 系统调用每次向内核申请一页，然后在标准库里再做进一步管理供用户程序使用。"]}),"\n",(0,n.jsx)(l.h2,{id:"内存回收",children:"内存回收"}),"\n",(0,n.jsxs)(l.p,{children:["buddy 分配器内部会维护一个 ",(0,n.jsx)(l.code,{children:"watermark"})]}),"\n",(0,n.jsx)(l.p,{children:"可以被回收的内存，大致可以分为以下两类："}),"\n",(0,n.jsxs)(l.ul,{children:["\n",(0,n.jsx)(l.li,{children:"文件映射的页，包括 page cache、slab 中的 dcache、icache、用户进程的可执行程序的代码段，文件映射页面。"}),"\n",(0,n.jsx)(l.li,{children:"匿名页，括进程使用各种 api（malloc,mmap,brk/sbrk）申请到的物理内存(这些 api 通常只是申请虚拟地址，真实的页分配发生在 page fault 中)，包括堆、栈，进程间通信中的共享内存，pipe，bss 段，数据段，tmpfs 的页。这部分没有办法直接回写，为他们创建 swap 区域，这些页也转化成了文件映射的页，可以回写到磁盘。"}),"\n"]}),"\n",(0,n.jsx)(l.p,{children:"对于内核并不是所有的物理内存都可以参与回收，比如内核的代码段，如果被内核回收了，系统就无法正常运行了，所以一般内核代码段、数据段、内核申请的内存、内核线程占用的内存等都是不可以回收的，除此之外的内存都可以是我们要回收的目标。"}),"\n",(0,n.jsxs)(l.ul,{className:"contains-task-list",children:["\n",(0,n.jsxs)(l.li,{className:"task-list-item",children:[(0,n.jsx)(l.input,{type:"checkbox",disabled:!0})," ","哪些情况下需要回收？"]}),"\n",(0,n.jsxs)(l.li,{className:"task-list-item",children:[(0,n.jsx)(l.input,{type:"checkbox",disabled:!0})," ","回收的是哪些内存？"]}),"\n"]}),"\n",(0,n.jsx)(l.h2,{id:"内存迁移",children:"内存迁移"}),"\n",(0,n.jsx)(l.h2,{id:"交换空间",children:"交换空间"}),"\n",(0,n.jsx)(l.p,{children:"交换空间（swap space）是位于磁盘上的一块存储区域，可以用于断电休眠、释放物理内存防止 OOM。"}),"\n",(0,n.jsx)(l.p,{children:"在内存空间不足时，根据某种调度策略，将已经分配给某个进程的页块存储到物理硬盘上，腾出该页的内存分配给当前需要的进程。"}),"\n",(0,n.jsx)(l.p,{children:"交换的过程："}),"\n",(0,n.jsxs)(l.ul,{className:"contains-task-list",children:["\n",(0,n.jsx)(l.li,{children:"根据策略（如 LRU）选择一个物理块"}),"\n",(0,n.jsx)(l.li,{children:"找到使用该物理块的虚拟地址（反向映射），删除相应的页表项"}),"\n",(0,n.jsx)(l.li,{children:"将该物理块写入到硬盘中"}),"\n",(0,n.jsxs)(l.li,{className:"task-list-item",children:[(0,n.jsx)(l.input,{type:"checkbox",disabled:!0})," ","【检查】"]}),"\n"]})]})}s(3366),l.default=(0,d.j)({MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:l}=Object.assign({},(0,i.ah)(),e.components);return l?(0,n.jsx)(l,{...e,children:(0,n.jsx)(c,{...e})}):c(e)},pageOpts:{filePath:"pages/tutorial/operating-system/linux-kernel/3.md",route:"/tutorial/operating-system/linux-kernel/3",frontMatter:{authors:"sailist",date:"2022-11-23",description:"",draft:!1,title:"1.3.内存分配"},headings:[{depth:1,value:"内存分配",id:"内存分配"},{depth:2,value:"内核内存分配",id:"内核内存分配"},{depth:3,value:"buddy",id:"buddy"},{depth:3,value:"Slab",id:"slab"},{depth:3,value:"vmalloc",id:"vmalloc"},{depth:2,value:"进程内存分配",id:"进程内存分配"},{depth:2,value:"内存回收",id:"内存回收"},{depth:2,value:"内存迁移",id:"内存迁移"},{depth:2,value:"交换空间",id:"交换空间"}],title:"1.3.内存分配"},pageNextRoute:"/tutorial/operating-system/linux-kernel/3"})}},function(e){e.O(0,[6828,9774,2888,179],function(){return e(e.s=6084)}),_N_E=e.O()}]);