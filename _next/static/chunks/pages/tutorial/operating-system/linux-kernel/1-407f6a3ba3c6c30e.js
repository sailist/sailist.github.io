(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8313],{7088:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/tutorial/operating-system/linux-kernel/1",function(){return s(6901)}])},6901:function(e,n,s){"use strict";s.r(n);var i=s(1527),c=s(6828),l=s(4579);function r(e){let n=Object.assign({h1:"h1",p:"p",code:"code",blockquote:"blockquote",ul:"ul",li:"li",img:"img",h2:"h2",strong:"strong",a:"a"},(0,l.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{children:"内存模型"}),"\n",(0,i.jsxs)(n.p,{children:["不做额外支持（如 Physical Address Extension，即 PAE）的情况下，32 位系统的地址总线的寻址范围是 $2^32bit = 4GB$。在虚拟地址的支持下，此时每一个进程都会拥有 4G 的虚拟地址空间 ",(0,i.jsx)(n.code,{children:"0x00000000-0xffffffff"}),"。Linux 内核将其中 0-3G（",(0,i.jsx)(n.code,{children:"0x00000000-0xc0000000"}),"） 划分为用户空间，3-4G（",(0,i.jsx)(n.code,{children:"0xc0000000-0xffffffff"}),"）划分为内核空间（通过 ",(0,i.jsx)(n.code,{children:"#define PAGE_OFFSET"})," 宏）。这种划分是人为设计的，还有诸多细节（如用户空间堆栈的初始位置、增长方向，内核空间 kernel image、vmalloc 内存区间等），称为虚拟内存模型（Virtual Memory Model）。"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"一旦开启了保护模式，CPU 发出的访存操作必须经过 MMU。所以内核和进程的访存操作都必须使用虚拟地址。此时不重叠的用户空间和内核空间使进程陷入内核态时不需要切换内核页表和进程页表重新建立映射关系。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["其中，用户空间设定包括（具体的实例地址通过进程描述符 ",(0,i.jsx)(n.code,{children:"task_struct"})," 表示）："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"用户栈"}),"\n",(0,i.jsx)(n.li,{children:"堆"}),"\n",(0,i.jsx)(n.li,{children:"代码段、数据段"}),"\n",(0,i.jsx)(n.li,{children:"..."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"/images2022-11-22-11-46-55.png",alt:""})}),"\n",(0,i.jsx)(n.p,{children:"内核空间设定包括："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"kernel image：内核代码段"}),"\n",(0,i.jsxs)(n.li,{children:["vmalloc，",(0,i.jsx)(n.code,{children:"#define VMALLOC_START"}),"：虚拟内存中连续、但物理内存中不连续的内存区，可以在 vmalloc 区域通过 ",(0,i.jsx)(n.code,{children:"vmalloc"})," 分配。"]}),"\n",(0,i.jsxs)(n.li,{children:["swapper_pg_dir，",(0,i.jsx)(n.code,{children:"#define KERNEL_RAM_VADDR"}),"，用于内核初始化时的页表项【？需要确认】"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"#define FIXADDR_START"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"#define CONFIG_VECTORS_BASE"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#define PKMAP_BASE"}),"/"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"#define MODULES_VADDR"})}),"\n",(0,i.jsx)(n.li,{children:"一些空洞"}),"\n",(0,i.jsx)(n.li,{children:"..."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"/images2022-11-22-16-59-32.png",alt:""})}),"\n",(0,i.jsx)(n.h2,{id:"安全性分析",children:"安全性分析"}),"\n",(0,i.jsxs)(n.p,{children:["在设定上，用户态禁止访问内核空间，内核态不建议",(0,i.jsx)(n.strong,{children:"直接"}),"访问用户空间。用户态禁止访问内核空间是为了避免用户执行不安全操作；内核态不建议直接访问用户空间是因为用户空间提供的指针可能是不安全或者无效的，需要通过",(0,i.jsx)(n.code,{children:"copy_from_user"}),"/",(0,i.jsx)(n.code,{children:"get_user"})," 等函数将用户空间的数据拷贝到内核空间，再操作完后再通过 ",(0,i.jsx)(n.code,{children:"copy_to_user"}),"/",(0,i.jsx)(n.code,{children:"put_user"})," 将修改后的数据拷贝回用户空间。"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["关于内核操作用户空间的 API，可以参考 ",(0,i.jsx)(n.a,{href:"https://blog.51cto.com/xiaojielinux/1874080",children:"这篇文章"}),"。"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"高端内存",children:"高端内存"}),"\n",(0,i.jsx)(n.p,{children:"32 位系统下，当物理内存小于 1G 时，内核态使用 1G 的虚拟内存空间，可以通过直接映射方式访问到全部的物理内存空间。但当物理内存大于 1G 时，1G 的虚拟内存空间会不够用。"}),"\n",(0,i.jsxs)(n.p,{children:["Linux 内核因此设计了高端内存这一概念，将内核的虚拟内存地址 3-4G 的空间中的前 896MB 定义为",(0,i.jsx)(n.strong,{children:"低端内存（low memory）"}),"，其余的 128 MB 定义为",(0,i.jsx)(n.strong,{children:"高端内存（high memory）"}),"。低端地址采用直接映射的方式，减去 3G 的 OFFSET 直接访问 0-896MB 的物理地址；高端地址采用非直接映射的方式，通过",(0,i.jsx)(n.strong,{children:"永久映射"}),"和",(0,i.jsx)(n.strong,{children:"临时映射"}),"等方式，访问剩余的全部物理地址空间。"]}),"\n",(0,i.jsx)(n.p,{children:"此外，在物理内存空间中，0-896MB 定义为低端内存，该部分内存地址可以由内核态直接映射访问，896MB 后的剩余空间定义为物理地址空间下的高端内存，必须由内核态通过非直接映射的方式建立连接后访问。"}),"\n",(0,i.jsxs)(n.p,{children:["物理地址通过 ",(0,i.jsx)(n.code,{children:"struct zone_struct"})," 划分为不同的管理区域，每一个 ",(0,i.jsx)(n.code,{children:"zone_struct"})," 可以看成是一个 ",(0,i.jsx)(n.code,{children:"struct page"})," 的集合，在 32 位系统下，这包括："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ZONE_DMA"}),"(0-16MB)，ISA 总线的直接内存存取（DMA）处理器有一个严格的限制：它们只能对内存的前 16MB 地址进行寻址。此外，DMA 使用需要",(0,i.jsx)(n.strong,{children:"连续的物理地址"}),"直接访问内存，不经过 MMU，因此 ",(0,i.jsx)(n.code,{children:"ZONE_DMA"})," 为专门划分出的连续的物理区域用于 DMA。类似的区域在 64 位系统下还包括 ",(0,i.jsx)(n.code,{children:"ZONE_DMA32"}),"。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ZONE_NORMAL"}),"(16-896MB)，该区域的物理页面是内核能够直接使用的，通过虚拟地址直接减 3G 使用。即 ",(0,i.jsx)(n.code,{children:"物理地址 = 逻辑地址 – 0xC0000000"})," 。",(0,i.jsx)(n.code,{children:"0xC0000000"})," 即 ",(0,i.jsx)(n.code,{children:"3G"})," 的偏移大小。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ZONE_HIGHMEM"}),"(890-END)，内核不能直接使用，需要由内核申请虚拟内存建立页表项。（用于高端内存）"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"/images2022-11-24-15-20-15.png",alt:""})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"/images2022-11-22-22-15-42.png",alt:""})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"/images2022-11-24-15-20-01.png",alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["定义高端内存的目的是让内核的虚拟内存空间有能力访问到全部的物理内存空间，因此，当实际物理内存地址小于内核虚拟内存地址时，高端内存就不再需要了。这体现在",(0,i.jsx)(n.strong,{children:"物理内存小于 1G 的 32 位系统"}),"上和 ",(0,i.jsx)(n.strong,{children:"64 位系统"}),"上。"]}),"\n",(0,i.jsx)(n.p,{children:"而高端内存内部会进一步的划分为多个部份，用于不同的非直接映射方式，这包括："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"内核动态映射空间（noncontiguous memory allocation）"}),"：通过 ",(0,i.jsx)(n.code,{children:"vmalloc"})," 分配可能不连续的物理地址到虚拟地址上连续的内存地址。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"持久内存映射（persistent kernel mappings）"}),"：在 ",(0,i.jsx)(n.code,{children:"KMAP_BASE-FIXADDR_START"})," 之间，使用 ",(0,i.jsx)(n.code,{children:"alloc_page(GFP_HIGHMEM)"})," 分配高端内存页或者使用 ",(0,i.jsx)(n.code,{children:"kmap"}),"/",(0,i.jsx)(n.code,{children:"kunmap"})," 函数将分配到的高端内存会映射到该区域。通常情况下，这个空间是 4M 大小，相应页表叫 ",(0,i.jsx)(n.code,{children:"pkmap_page_table"}),"，该页表的页基址是 ",(0,i.jsx)(n.code,{children:"swapper_pg_dir"}),"。【？",(0,i.jsx)(n.code,{children:"swapper_pg_dir"})," 是这样吗？】"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"临时映射（temporary kernel mapping）"}),"：",(0,i.jsx)(n.code,{children:"kmap"}),"/",(0,i.jsx)(n.code,{children:"kunmap"})," 可能会因为内存不够而睡眠，因此不能用于中断处理程序。对中断服务程序中的内核内存分配，可以使用 ",(0,i.jsx)(n.code,{children:"kmap_atomic"}),"/",(0,i.jsx)(n.code,{children:"kunmap_atomic"})," 在临时映射区来完成。该区域位于 ",(0,i.jsx)(n.code,{children:"FIXADDR_START-FIXADDR_TOP"})," 之间，每个 CPU 占用其中一块空间，这部分空间又会根据不同用途进一步细化，这定义在 ",(0,i.jsx)(n.code,{children:"kmap_types.h -> km_type"})," 中。注意，",(0,i.jsx)(n.code,{children:"kmap_atomic"})," 操作是原子性的，因为在中断服务程序中的任意时间，每个 CPU 在临时映射区都有各自可用的一块内存地址空间，所以该操作不会阻塞。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"固定映射（fixmaps）"}),"：在编译时会直接根据各种用途分配物理地址，区域位于 ",(0,i.jsx)(n.code,{children:"FIXADDR_START-FIXADDR_END"})," 。"]}),"\n"]})]})}s(3366),n.default=(0,c.j)({MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r(e)},pageOpts:{filePath:"pages/tutorial/operating-system/linux-kernel/1.md",route:"/tutorial/operating-system/linux-kernel/1",frontMatter:{authors:"sailist",date:"2022-11-24",description:"",draft:!1,title:"1.1.内存模型"},headings:[{depth:1,value:"内存模型",id:"内存模型"},{depth:2,value:"安全性分析",id:"安全性分析"},{depth:2,value:"高端内存",id:"高端内存"}],title:"1.1.内存模型"},pageNextRoute:"/tutorial/operating-system/linux-kernel/1"})}},function(e){e.O(0,[6828,9774,2888,179],function(){return e(e.s=7088)}),_N_E=e.O()}]);