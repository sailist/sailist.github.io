(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[787],{90:function(n,e,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/tutorial/operating-system/18",function(){return s(2728)}])},2728:function(n,e,s){"use strict";s.r(e);var i=s(1527),t=s(6828),l=s(4579);function c(n){let e=Object.assign({h1:"h1",p:"p",ul:"ul",li:"li",input:"input",a:"a",code:"code"},(0,l.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{children:"上下文切换"}),"\n",(0,i.jsx)(e.p,{children:"上下文切换类型上下文还分为了三种类型，分别是："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"进程上下文切换"}),"\n",(0,i.jsx)(e.li,{children:"线程上下文切换"}),"\n",(0,i.jsx)(e.li,{children:"中断上下文切换"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"进程上下文切换进程上下文切换指的是不同进程之间发生切换。一般来说，进程被调度有如下几个时机："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"某个进程时间片耗尽，会被系统挂起，切换到其他等待 CPU 的进程。"}),"\n",(0,i.jsx)(e.li,{children:"进程所需系统资源不足，需要等到资源满足时才可运行，此时会被挂起，其他进程会被调度。"}),"\n",(0,i.jsx)(e.li,{children:"进程通过 sleep 方法主动挂起，其他进程就有机会被调度。"}),"\n",(0,i.jsx)(e.li,{children:"有更高优先级的进程，当前进程会被挂起，高优先级进程会被调度。"}),"\n",(0,i.jsx)(e.li,{children:"硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"当发生如上几种情况的时候，就会发生进程调度，进而发生进程上下文切换。"}),"\n",(0,i.jsx)(e.p,{children:"进程是资源分配的基本单位，线程是调度的基本单位，进程只是给线程提供了虚拟内存等资源。线程上下文切换，就可以分为两种情况："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"进程调度前后的两个线程，属于同一进程：此时因为资源共享，所以在切换的时候虚拟内存等这些资源就不需要变化，只需要切换线程的私有数据、寄存器等不共享的数据。"}),"\n",(0,i.jsx)(e.li,{children:"进程调度前后的两个线程，不属于同一进程：这时候因为资源部共享，所以切换过程和进程上下文切换是一样的。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"因此同进程内的线程切换，要比多进程间的切换消耗更少的资源，这其实就是多线程比起多进程的一个优势。"}),"\n",(0,i.jsx)(e.p,{children:"为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其它进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以即便中断过程打断了一个正在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。对同一个 CPU 来说，中断处理比进程拥有更高的优先级，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，当发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。"}),"\n",(0,i.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(e.a,{href:"https://www.zhihu.com/question/23199395",children:"https://www.zhihu.com/question/23199395"})]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["Linux 内核调度的单位是 task_struct 用来标识一个调度单位（线程）。同一个进程的多个线程内的 tgid 相同，虚拟内存地址相同。创建进程和线程时，都是系统调用相同的内核函数 ",(0,i.jsx)(e.code,{children:"do_fork"}),"，该函数的主要工作是创建 ",(0,i.jsx)(e.code,{children:"task_strcut"})," 结构体，只是传入的参数不同，从而影响了最终资源的分配策略。"]}),"\n",(0,i.jsx)(e.h1,{children:"Reference"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://blog.csdn.net/qq_28351465/article/details/88950311",children:"https://blog.csdn.net/qq_28351465/article/details/88950311"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://www.cnblogs.com/cangqinglang/p/12455444.html",children:"https://www.cnblogs.com/cangqinglang/p/12455444.html"})}),"\n"]})]})}s(3366),e.default=(0,t.j)({MDXContent:function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)},pageOpts:{filePath:"pages/tutorial/operating-system/18.md",route:"/tutorial/operating-system/18",frontMatter:{authors:"sailist",date:"2022-11-09",description:"",draft:!1,title:"上下文切换"},headings:[{depth:1,value:"上下文切换",id:"上下文切换"},{depth:1,value:"Reference",id:"reference"}],title:"上下文切换"},pageNextRoute:"/tutorial/operating-system/18"})}},function(n){n.O(0,[6828,9774,2888,179],function(){return n(n.s=90)}),_N_E=n.O()}]);