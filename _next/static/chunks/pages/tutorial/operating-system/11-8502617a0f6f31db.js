(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[140],{5674:function(n,e,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/tutorial/operating-system/11",function(){return i(7836)}])},7836:function(n,e,i){"use strict";i.r(e);var s=i(1527),l=i(6828),r=i(4579);function d(n){let e=Object.assign({h1:"h1",p:"p",code:"code",blockquote:"blockquote",h2:"h2",h3:"h3",ul:"ul",li:"li",input:"input",a:"a",img:"img",strong:"strong"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{children:"寻址"}),"\n",(0,s.jsx)(e.p,{children:"地址的数量表明了有多少个存储单元，可以由地址总线的条数表示。地址的表示受限于寄存器的位数，如果寄存器的位数大于等于地址总线的位数，那么就可以直接表示存储单元的地址，否则就需要寻找其他的方法。"}),"\n",(0,s.jsxs)(e.p,{children:["早期 CPU 有 20 位地址线，但寄存器只有 16 位，因此采用了 ",(0,s.jsx)(e.code,{children:"[段基址:段偏移量]"})," 的方式来表示。第一个寄存器高四位和第二个寄存器一起组成 20 位的内存地址。"]}),"\n",(0,s.jsx)(e.p,{children:"由于两个寄存器表示的内存地址是真实的物理地址，因此这种寻址方式也叫做实模式。"}),"\n",(0,s.jsxs)(e.p,{children:["随着计算机的发展， CPU 的地址线的个数和寄存器的位数相同了，但因为兼容性等原因，仍然采用 ",(0,s.jsx)(e.code,{children:"[段基址:段偏移量]"})," 的表示方式。与此同时，为了更安全、更灵活访问内存空间，引入了保护模式。"]}),"\n",(0,s.jsx)(e.p,{children:"在保护模式下，每一个进程都会有段基址、界限地址等描述进程分配的内存大小与内存位置的信息，这一信息存储在全局描述表（GDT，Global Description Table）中（表示为一块内核内存空间），可以有不同的硬件实现。全局描述表只可以由操作系统（在内核态）修改。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"存储全局描述表的硬件叫做基地址寄存器、重定位寄存器，或统称为内存管理单元（Memory-management unit，MMU）"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"用户视角下得到的内存地址实际上是段偏移量，是逻辑地址。在不涉及 IO 操作时，用户对逻辑地址的任何操作都不涉及到物理地址。在涉及 IO 操作时，逻辑地址会通过 MMU 转换为物理地址，并执行实际的操作，但用户程序在保护模式下绝对无法得到真实的物理地址。"}),"\n",(0,s.jsx)(e.h1,{children:"内存的分配方式"}),"\n",(0,s.jsx)(e.h2,{id:"连续内存分配",children:"连续内存分配"}),"\n",(0,s.jsx)(e.p,{children:"采用连续内存分配方式时，如果用户申请一块 2M 的内存空间，那么物理内存上就会开辟一块 2M 的内存空间，这 2M 的内存空间地址将是连续的（如从 0-2048）。"}),"\n",(0,s.jsx)(e.p,{children:"当新的进程需要一块连续内存空间，物理内存中存在空闲的足够的空间，但是因为不连续导致无法分配时候，就会产生外部碎片问题（external fragmentation）。解决这一问题的方法是允许物理地址空间非连续，如分页/分段/段页式分配。"}),"\n",(0,s.jsxs)(e.p,{children:["采用连续内存分配时，物理地址仍然可以沿用 ",(0,s.jsx)(e.code,{children:"段基址, 段偏移"})," 的方式来表示，而逻辑地址则可以直接用 ",(0,s.jsx)(e.code,{children:"段偏移"})," 表示"]}),"\n",(0,s.jsx)(e.h3,{id:"外部碎片整理算法伙伴系统算法",children:"外部碎片整理算法（伙伴系统算法）"}),"\n",(0,s.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(e.a,{href:"http://kerneltravel.net/blog/2020/lp_901/",children:"http://kerneltravel.net/blog/2020/lp_901/"})]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"分页",children:"分页"}),"\n",(0,s.jsx)(e.p,{children:"分页将整个内存空间划分分成细粒度的块，以块为单位分配给进程。分页的过程需要保证物理内存和逻辑内存的块大小一致（物理内存的块叫帧，逻辑内存的叫页），用于建立逻辑块和物理块的映射关系。"}),"\n",(0,s.jsxs)(e.p,{children:["分页系统中逻辑地址和物理地址之间的映射通过页表来实现，页表存储了每个页号到帧号的映射关系，此时单个逻辑内存地址用 ",(0,s.jsx)(e.code,{children:"页号, 页偏移"})," 来唯一表示，在转换时通过页表转换为物理内存地址 ",(0,s.jsx)(e.code,{children:"帧号, 帧偏移"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/images2022-10-07-22-37-17.png",alt:""})}),"\n",(0,s.jsx)(e.p,{children:"分页避免了外部碎片问题，保证所有的块都能被分配，但会产生内部碎片问题，但这可以通过调整块大小来缓解。"}),"\n",(0,s.jsx)(e.p,{children:"分页功能可以由不同的硬件支持，如转换表缓冲区（translation look-aside buffer, TLB），可以看成是一种存储页号到帧号映射关系的缓存。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/images2022-10-07-22-44-39.png",alt:""})}),"\n",(0,s.jsx)(e.p,{children:"页表不仅仅是一个线性表，为了支撑更多的页分配，会有更复杂的页表数据结构实现，如多层页表。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/images2022-10-07-22-47-17.png",alt:""})}),"\n",(0,s.jsx)(e.h2,{id:"分段",children:"分段"}),"\n",(0,s.jsx)(e.p,{children:"分段是一种用户视角的内存管理方案，反映了程序申请内存的逻辑结构。分段系统将进程的逻辑内存空间区分为代码段、数据段、堆栈等，可以帮助用户更好的操作、共享和保护每一段的内存空间。"}),"\n",(0,s.jsxs)(e.p,{children:["分段系统中逻辑地址和物理地址的映射通过段表实现，段表保存了每个段的基地址和界限地址，并用 ",(0,s.jsx)(e.code,{children:"段号, 段偏移"})," 的方式来表示和获取物理内存地址。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/images2022-10-07-22-49-27.png",alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/images2022-10-07-22-49-36.png",alt:""})}),"\n",(0,s.jsx)(e.h2,{id:"段页式",children:"段页式"}),"\n",(0,s.jsxs)(e.p,{children:["段页式将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用。段页式系统中，内存地址由 ",(0,s.jsx)(e.code,{children:"段号, 页号, 页偏移量"})," 组成。"]}),"\n",(0,s.jsx)(e.p,{children:"在进行地址转换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。"}),"\n",(0,s.jsx)(e.h1,{children:"交换"}),"\n",(0,s.jsx)(e.p,{children:"逻辑地址的设定，不仅提供了安全性，也允许逻辑空间大于实际的物理空间。当物理空间不够用又需要分配时，可以将一块不经常使用的内存备份到硬盘的空间上，从而空出这一块空间用于分配，这一操作叫做交换（swap）。"}),"\n",(0,s.jsxs)(e.p,{children:["理论上所有的硬盘空间都可以用于交换，但实际中需要定义用于交换的内存空间大小。此时，",(0,s.jsx)(e.code,{children:"逻辑内存空间=物理内存空间+交换空间"})]}),"\n",(0,s.jsx)(e.h2,{id:"页置换",children:"页置换"}),"\n",(0,s.jsx)(e.p,{children:"分页系统也允许交换操作，称为页置换（page replacement），此时交换操作以页为粒度进行。页置换的步骤为："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["用户需要使用一个不在内存上的页，产生一个",(0,s.jsx)(e.strong,{children:"页错误"}),"陷阱（page-fault trap）","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"检查该进程的内部页表来确认该引用是否合法，如果非法则终止进程，否则继续执行页置换过程"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.li,{children:"在磁盘上查找待置换到内存中的页"}),"\n",(0,s.jsxs)(e.li,{children:["在内存上查找一个空闲帧（没有被分配的帧），如果没有则通过页置换算法选择一个牺牲帧（victim frame）写到磁盘上（并更新页表、帧表）并将该帧的位置作为",(0,s.jsx)(e.strong,{children:"空闲帧"}),"。"]}),"\n",(0,s.jsx)(e.li,{children:"将页置换到空闲帧位置上（并更新页表、帧表）"}),"\n",(0,s.jsx)(e.li,{children:"中断返回，此时该页存在，用户进程无感使用该页（外部仅表现为少许延迟）"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"页置换过程中，最重要的是页置换算法，该算法的目的是寻找一个最优解（一个被占用帧），该帧被置换在之后一段时间内造成页错误的数量最少，因为未来无法预测，所以所有算法只能通过过去一段时间的页使用信息来预测并选择。在这种情况下，常用的算法有："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"FIFO（先进先出）"}),"\n",(0,s.jsx)(e.li,{children:"LRU（least-recently-used，最近最少使用）算法"}),"\n",(0,s.jsx)(e.li,{children:"..."}),"\n"]}),"\n",(0,s.jsx)(e.h1,{children:"虚拟内存"}),"\n",(0,s.jsxs)(e.p,{children:["虚拟内存是对内存交换特性的利用。虚拟内存的",(0,s.jsx)(e.strong,{children:"虚拟"}),"强调进程在执行过程中可能需要的内存不一定真实存在在物理内存中。比如一个程序中存在一个很少被调用的逻辑，该部份逻辑对应的内存可能在程序启动时不会被分配具体的内存空间，而是等到进程真正调用该部份逻辑时，通过缺页中断来动态的加载该部分内存，该操作被称为",(0,s.jsx)(e.strong,{children:"按需调页"}),"。按需调页在缺少物理内存时，可能会反复的置换需要的页，使进程在换页上用的时间多于执行时间，导致 CPU 利用率下降，这一过程称为颠簸（thrashing）。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["实际上这种特性在编程语言中也有体现，即",(0,s.jsx)(e.strong,{children:"懒加载（lazy load）"})]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"因此，虚拟内存使得程序的初始启动速度加快，也减少了单个进程的物理内存使用量。同时程序不再受物理内存空间的限制。"}),"\n",(0,s.jsx)(e.h2,{id:"写时复制",children:"写时复制"}),"\n",(0,s.jsx)(e.p,{children:"写时复制可以看成是另一种懒操作，当进程 fork 自身时，操作系统可以直接共享原进程的所有内存页，仅在这些页发生了写操作时，创建写操作对应页的副本。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/images2022-10-08-11-12-10.png",alt:""})}),"\n",(0,s.jsx)(e.h1,{children:"大页内存"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"降低 TLB miss 的概率：拿普通的 4KB 页面和 2MB 的大页相比，都是使用一条页表项，能 cover 的内存大小却差了 511 倍，所以更多的使用大页能大大减少系统中页表项的数量，再加上 TLB cache 大小固定且有限，再再加上程序访问的地址的局部性原理，TLB miss 的概率就下来了。"}),"\n",(0,s.jsx)(e.li,{children:"降低 walk page table 的长度：由于大页的页表级数(PGD PUD PMD)比普通页面级数(PGD PUD PMD PTE)小 1，所以在走表时会高效一些。(以普通页面是四级页表为例)"}),"\n"]}),"\n",(0,s.jsx)(e.h1,{children:"页表缓冲"}),"\n",(0,s.jsx)(e.p,{children:"TLB（translation lookaside buffer）快表，直译为转换检测缓冲区，也称页表缓冲，是一个内存管理单元，用于改进虚拟地址到物理地址转换速度的缓存。"}),"\n",(0,s.jsx)(e.p,{children:"TLB 和 Cache 没有本质的区别，TLB 缓存页表数据，Cache 缓存内存数据。"})]})}i(3366),e.default=(0,l.j)({MDXContent:function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)},pageOpts:{filePath:"pages/tutorial/operating-system/11.md",route:"/tutorial/operating-system/11",frontMatter:{authors:"sailist",date:"2022-11-06",description:"",draft:!1,title:"5.内存管理"},headings:[{depth:1,value:"寻址",id:"寻址"},{depth:1,value:"内存的分配方式",id:"内存的分配方式"},{depth:2,value:"连续内存分配",id:"连续内存分配"},{depth:3,value:"外部碎片整理算法（伙伴系统算法）",id:"外部碎片整理算法伙伴系统算法"},{depth:2,value:"分页",id:"分页"},{depth:2,value:"分段",id:"分段"},{depth:2,value:"段页式",id:"段页式"},{depth:1,value:"交换",id:"交换"},{depth:2,value:"页置换",id:"页置换"},{depth:1,value:"虚拟内存",id:"虚拟内存"},{depth:2,value:"写时复制",id:"写时复制"},{depth:1,value:"大页内存",id:"大页内存"},{depth:1,value:"页表缓冲",id:"页表缓冲"}],title:"5.内存管理"},pageNextRoute:"/tutorial/operating-system/11"})}},function(n){n.O(0,[6828,9774,2888,179],function(){return n(n.s=5674)}),_N_E=n.O()}]);