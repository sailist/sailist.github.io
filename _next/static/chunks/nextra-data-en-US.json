{"/_app":{"title":" App","data":{"":""}},"/about":{"title":"About","data":{"":"This is the about page! This page is shown on the navbar."}},"/blog/3":{"title":"关于 Python sys.path 包含了奇怪字符串的问题","data":{"":"我一直找不到 sys.path 是如何进行初始化的。在我的电脑上，sys.path 输出了以下内容：\n['{PWD}',\n'/opt/homebrew/Cellar/python@3.9/3.9.16/Frameworks/Python.framework/Versions/3.9/lib/python39.zip',\n'/opt/homebrew/Cellar/python@3.9/3.9.16/Frameworks/Python.framework/Versions/3.9/lib/python3.9',\n'/opt/homebrew/Cellar/python@3.9/3.9.16/Frameworks/Python.framework/Versions/3.9/lib/python3.9/lib-dynload',\n'',\n'/Users/user/Library/Python/3.9/lib/python/site-packages',\n'/opt/homebrew/lib/python3.9/site-packages',\n'/opt/homebrew/lib/python3.9/site-packages/potion-0.0.1-py3.9.egg',\n'/opt/homebrew/lib/python3.9/site-packages/pynotion-0.0.1-py3.9.egg',\n'/Users/user/Documents/timeflow/backend_api',\n'/opt/homebrew/lib/python3.9/site-packages/IPython/extensions',\n'/Users/user/.ipython']\n这里面有一些不符合常规的路径，包括：\n我的项目里的路径\n空字符串\n.ipython\n\n最终找到的来源包括以下途径：\n环境变量 $PYTHONPATH\n/site-packages/*.pth\n\n\nhttps://docs.python.org/3/library/site.html#module-site"}},"/blog/4":{"title":"寻找 auth_aes128_md5 的参数配置","data":{"":"ss-local 的官方文档很久了，新更新的关于 ssr 的参数没有更新，导致一些参数不会写在 https://github.com/shadowsocksrr/shadowsocksr-libev/blob/4799b312b8244ec067b8ae9ba4b85c877858976c/src/local.c#L620 处定义了 ss-local 定义的各种参数``\n#ifndef LIB_ONLY\nint i, c;\nint pid_flags    = 0;\nint mtu          = 0;\nint mptcp        = 0;\nchar *user       = NULL;\nchar *local_port = NULL;\nchar *local_addr = NULL;\nchar *password = NULL;\nchar *timeout = NULL;\nchar *protocol = NULL; // SSR\nchar *protocol_param = NULL; // SSR\nchar *method = NULL;\nchar *obfs = NULL; // SSR\nchar *obfs_param = NULL; // SSR\nchar *pid_path = NULL;\nchar *conf_path = NULL;\nchar *iface = NULL;\nint remote_num = 0;\nchar *hostnames[MAX_REMOTE_NUM] = {NULL};\nss_addr_t remote_addr[MAX_REMOTE_NUM];\nchar *remote_port = NULL;\nint use_new_profile = 0;\njconf_t *conf = NULL;\n这些参数的读取有两种方法，一种是直接通过命令行参数读取，另一种是通过 conf_path 这一个参数读取 json 配置文件读取。","通过命令行参数读取#通过命令行参数读取":"定义在 https://github.com/shadowsocksrr/shadowsocksr-libev/blob/4799b312b8244ec067b8ae9ba4b85c877858976c/src/local.c#LL1532C9-L1532C18如关键的几个参数：\ncase 'O':\nprotocol = optarg;\nbreak;\ncase 'm':\nmethod = optarg;\nbreak;\ncase 'o':\nobfs = optarg;\nbreak;\ncase 'G':\nprotocol_param = optarg;\nbreak;\ncase 'g':\nobfs_param = optarg;\nbreak;\n// SSR end\ncase 'c':\nconf_path = optarg;\nbreak;\n主要参考了https://coderschool.cn/2498.html，在通过 base64 解码后，ssr 的内容大致如下所示：\nssr://server:port:protocol:method:obfs:password_base64/?params_base64\n\n# 尝试解析 ssr 并代理的脚本\nimport requests\nimport pandas as pd\nimport re\nfrom base64 import b64decode\nimport base64\nimport json\n\ndef pad64(c):\nc = c.ljust(len(c)+(4 - len(c) % 4),'=')\nreturn c\n\nres = requests.get('subscription_url')\ncontent = res.content.decode()\ncontent = pad64(content)\n\ndef split(s):\nres = re.split(r'\\/\\?|\\&',s)\n\nres = {'password':res[0],\n'protoparam':res[2].split('=')[1],\n'remarks':res[3].split('=')[1],\n'group':res[4].split('=')[1],\n'udpport':int(res[5].split('=')[1]),\n'uot':int(res[6].split('=')[1])}\n\nfor k,v in list(res.items()):\nif isinstance(v,str):\ntry:\nv = b64decode(pad64(v),b'-_').decode()\nexcept:\nprint(v)\nres[k] = v\nreturn res\n\n\n\nres = []\nfor line in base64.b64decode(content).decode().split():\ntry:\ndecode_line = (base64.b64decode(pad64(line.split('//')[-1]),b'-_')).decode()\nres.append(decode_line.split(':'))\nexcept Exception as e:\nprint(e)\n\ndf = pd.DataFrame(res,columns=['server','server_port','protocol','method','obfs','p'])\np = df.p.apply(lambda x:split(x));\ndf['local_port'] = 1100\ndf['server_port'] = df['server_port'].apply(int)\ndf = df.drop('p',axis=1)\nparams = df.to_dict('records')\nextras = list(p)\n\n# df['name'] = df.p.apply(lambda x:x['remarks'])\n\nfor p,e in zip(params,extras):\np.update(e)\n\nnewdf = pd.DataFrame(params)\n\nnewdf = newdf.rename(columns={'passwode':'password','protoparam':'protocol_param'})\nnew_params = newdf.to_dict('records')\nprint(json.dumps(new_params[8],indent=2,ensure_ascii=False))\n截至 2023.02.17， 除了较出名的客户端外，已发布的 ss-local 本身并未 ssr 参数，需要手动编译这些命令行工具。最终放弃转为使用 clash。已有的 ssr 订阅链接可以通过 subconverter 转换为 clash 的配置文件。"}},"/blog/5":{"title":"一次 rss 阅读器的筛选","data":{"":"主要筛选条件：开源免费，维持更新，界面美观，基于 Web 且提供了 API 接口，有 Docker 原生支持开源+维持更新：\nhttps://github.com/Xyrio/RSSOwlnix 完全 Java 编写的客户端\nhttps://github.com/DJj123dj/open-ticket\nhttps://github.com/getstream/winds JS 写的，界面很好看，可惜已经不维护了\nhttps://github.com/sismics/reader Java 后端+Js 前端，但已经不更新 10 个月以上了\nhttps://github.com/pietheinstrengholt/rssmonster 基于 Vue 的 Js 前端，有 Docker 支持\nhttps://github.com/nkanaev/yarr Go+Js 前端，比较新\nhttps://github.com/martinrotter/rssguard C 客户端"}},"/blog/6":{"title":"chatgpt-enhancement-extension 插件开发宣传文案","data":{"":"最近再次完善了一波我之前的插件：chatgpt-enhancement-extension插件在 ChatGPT 原生应用上嵌入了一系列功能，包括：\nPrompt 提示：在输入区域输入“/”并查看提示。\nPDF 自动阅读：使用Regex Prompt Group逐页加载 PDF 文件并阅读。\nMarkdown 转换支持：将对话转换为 markdown 格式。\n复制、保存和导出页面：通过注入按钮组复制、保存和导出对话。\n后台管理：在选项页面中轻松管理上述所说的 Prompt ，正则 Prompt 组，对话历史。\n\n对话历史：和 ChatGPT 的 id 绑定，点击 id 即可跳转会对应 ChatGPT 页面\n因为最近更新频繁，且 Chrome 商店审核很慢，因此目前还是推荐通过本地方式加载应用：欢迎关注：chatgpt-enhancement-extension之前的两次帖子：\nhttps://www.v2ex.com/t/928566\nhttps://www.v2ex.com/t/925917\n\n文案二次编辑：","chatgpt-enhancement-extension-旨在以插件的形式补全基于-chatgpt-的工作流全方位提升使用体验#chatgpt-enhancement-extension 旨在以插件的形式补全基于 ChatGPT 的工作流，全方位提升使用体验。":"功能简洁：支持 PDF 文件拖进文本框后自动逐页提问每一页文本会通过基于正则表达式的 Prompt 组（ Regex Promp Group ）进行匹配并追加 Prompt：输入 / 弹出 Prompt 选择框，Enter 直接发送，Tab 置入编辑框用于二次修改：支持单个回复的 Markdown 转换，还支持整个页面的 Markdown 格式的复制、保存和导出插件 Option 页面提供了对 Promp 、Regex Promp Group 、对话历史的管理功能，可以轻松编辑与导入导出：对话历史保存和 ChatGPT 的 id 绑定，点击 id 即可跳转会对应 ChatGPT 页面\n因为最近更新频繁，且 Chrome 商店审核很慢，因此目前还是推荐通过本地方式下载 dist.crx 并加载应用，欢迎 start 并关注插件最新动态：\nhttps://github.com/sailist/chatgpt-enhancement-extension\n\nReddit text:Introducing ChatGPT Enhancement Extension - an all-in-one plugin to improve your ChatGPT experience!With ChatGPT Enhancement Extension, you can enjoy a range of features that enhance your dialogue generation experience. Some of our key features include prompt hints, PDF support, markdown conversion, copy/save/export options, and an admin dashboard for easy management.\nv2ex\nreddit"}},"/blog/7-994-2023-04-16-7":{"title":"字体是怎么渲染的","data":{"":"感觉从事计算机相关行业久了，不惯是写代码的还是做设计的，应该都免不了要跟字体打交道，一些基本的字体格式（ttf）也都还算了解，知道一个不同的 ttf 可以渲染出不同形状的文字。这个时候问题来了，现在在我们的左边是存储了各种字形信息的字体文件，在我们右边是已经渲染出好的文字。在这中间发生了什么？在参考了一系列博客、官方文档，并阅读调试了 Typr.js 源码后，我得以一窥字体的渲染方式，并将他写下来。本文将涵盖一下内容：\n整个渲染流程的介绍\n最小版本的基于 Python fonttools 库渲染字体的实现","字体格式与读取#字体格式与读取":"关于字体文件（ttf）标准的一些了解可以参考 这篇文章。我在  中解读了具体怎么解析一个 ttf 文件。我们只需要了解一个 ttf 可以看成是一个 List[Dict]，即包含多个字典（table）的列表，每个字典里的值可以是数字、文本、数组等。使用 fonttools 可以方便的直接解析一个 ttf 文件。为了方便比对和调试，我以 github/Typr.js/demo/LiberationSans-Bold.ttf 这一英文字体为例。\nfrom fontTools import ttLib\ntt = ttLib.TTFont(\"LiberationSans-Bold.ttf\")\nprint(tt.keys())\n\n>>> ['GlyphOrder', 'head', 'hhea', 'maxp', 'OS/2', 'hmtx', 'cmap', 'fpgm', 'prep', 'cvt ', 'loca', 'glyf', 'kern', 'name', 'post', 'gasp', 'FFTM', 'GDEF', 'GPOS', 'GSUB']\n其中四个字节长度的是字体文件中所有的表名，这是由字体文件的标准决定的，表名以四个字节长度大端存储。\n所以你能看到有一个表名是 'cvt '，GlyphOrder 则是该库自己解析出来的。\n如 TTF 文件探秘 所说：\n整体来看 TTF 文件，我们可以学到一些高密度存储数据的方式\n\nfonttools 自行优化了一些读取方式，这使我们用 fonttools 能够更容易的获取到表的一些数据了。\n此时，可以对照官方文档 参考这些表的意义，这里简单列几个\nkern: kerning（字距调整）\nhmtx: horizontal metrics（字形的水平宽度）\ncmap: character to glyph mapping（unicode 到 字形 index 的映射）\nglyf: glyph data（字形数据）","获取-character-name#获取 character name":"cmap: character to glyph mapping\n通过打印 cmap 中的 table 我们能看到 cmap 存储了一个 index 到 character name 的映射：\nprint(tt['cmap'].tables[0].__dict__)\n\n>>> 'cmap': {32: 'space', 33: 'exclam', 34: 'quotedbl', 35: 'numbersign', 36: 'dollar', 37: 'percent', 38: 'ampersand', 39: 'quotesingle', 40: 'parenleft', 41: 'parenright', 42: 'asterisk', 43: 'plus', 44: 'comma', 45: 'hyphen', 46: 'period', 47: 'slash', 48: 'zero', 49: 'one', 50: 'two', 51: 'three', 52: 'four', 53: 'five', 54: 'six', 55: 'seven', 56: 'eight', 57: 'nine', 58: 'colon', 59: 'semicolon', 60: 'less', 61: 'equal', 62: 'greater', 63: 'question', 64: 'at', 65: 'A', 66: 'B', 67: 'C', 68: 'D', 69: 'E', 70: 'F',\n这些 index 实际是 unicode 编码，在 python 中我们可以通过 ord 或者 encode('utf8') 来转换：\nprint(ord(','))\n>>> 44\n\nprint(list(',A'.encode('utf8')))\n>>> [44, 65]\n我们可以基于此拿到相应的 character name，比如 ',A' -> [44, 65] ->  ['comma', 'A']","寻找字形数据#寻找字形数据":"glyf: glyph data\n\nprint(tt['glyf'].__dict__.keys())\n>>> dict_keys(['tableTag', 'glyphs', 'glyphOrder'])\n\nprint(tt['glyf'].__dict__['glyphOrder'])\n>>> ['.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft',\n由于 fonttools 已经帮我们处理好了映射关系，所以我们只可以直接根据 character name 找到字形数据\nglyphs = tt['glyf'].__dict__['glyphs']\ngls = [glyphs[i] for i in cname]\nprint(gls)\n>>> [<fontTools.ttLib.tables._g_l_y_f.Glyph object at 0x11c099c10>, <fontTools.ttLib.tables._g_l_y_f.Glyph object at 0x11c0a41f0>]\n\n我们还可以根据 glyphOrder 找出 character name 在原本字体文件中 glyphs 中的顺序：\ncmap = tt['cmap'].tables[0].__dict__['cmap']\ncname = [cmap[i] for i in list(',A'.encode('utf8'))] # ['comma', 'A']\n\nglyphOrder = tt['glyf'].__dict__['glyphOrder']\ngid = [glyphOrder.index(i) for i in cname]\nprint(gid)\n>>> [15, 36]\n字形数据 fonttools 帮我们处理成了字典，但没有帮我们处理成直观的格式：\nprint(gls[0].data)\n>>> b'\\x00\\x01\\x00\\x8b\\xfe\\xc3\\x01\\xb0\\x011\\x00\\n\\x00\"@\\x11\\x03\\x04\\n\\x08\\x04\\x08\\x0c\\x0b\\x08\\t\\x9b[\\x08\\x04\\xa8[\\x08\\x00/++\\x11\\x12\\x0199\\x113\\x11310%\\x14\\x06\\x07#>\\x015#\\x11!\\x01\\xb039\\xb9;J\\x81\\x01!Bx\\xb8OG\\xaaL\\x011\\x00\\x00'\n但没关系，这一部分逻辑在 Typr.js:_parseGlyf 中有相应的实现。我用 Python 复刻了其中的算法，将其最终转换为了 SVG path：\ndata = gls[0].data\nprint(data)\ndata = parse_glyf(data)\nprint(data)\n>>> {'noc': 1, 'xMin': 139, 'yMin': -317, 'xMax': 432, 'yMax': 305, 'endPts': [10], 'instructions': [64, 17, 3, 4, 10, 8, 4, 8, 12, 11, 8, 9, 155, 91, 8, 4, 168, 91, 8, 0, 47, 43, 43, 17, 18, 1, 57, 57, 17, 51, 17, 51, 49, 48], 'flags': [37, 20, 6, 7, 35, 62, 62, 53, 35, 17, 33], 'xs': [432, 432, 381, 324, 139, 198, 272, 272, 143, 143, 432], 'ys': [66, -54, -238, -317, -317, -246, -76, 0, 0, 305, 305]}\n\nsvg_path = simple_Glyphfunction(data)\nprint(svg_path)\n>>> ['M', 432, 305, 'L', 432, 66, 'Q', 432, -54, 406, -146, 'Q', 381, -238, 324, -317, 'L', 139, -317, 'Q', 198, -246, 235, -161, 'Q', 272, -76, 272, 0, 'L', 143, 0, 'L', 143, 305, 'Z']\n\n那这样是不是就大功告成了呢？我们将 ',A' 同时转换成 svg path，然后构建 svg 文件看看效果\nsvg_paths = []\nfor gl in gls:\ndata = gl.data\n\ndata = parse_glyf(data)\nsvg_path = simple_Glyphfunction(data)\nsvg_paths.extend(svg_path)\n\nprint(' '.join(map(str, svg_paths)))\nM 432 305 L 432 66 Q 432 -54 406 -146 Q 381 -238 324 -317 L 139 -317 Q 198 -246 235 -161 Q 272 -76 272 0 L 143 0 L 143 305 Z M 1425 0 L 1133 0 L 1008 360 L 471 360 L 346 0 L 51 0 L 565 1409 L 913 1409 Z M 760 1123 L 739 1192 L 733 1170 Q 723 1134 709 1088 Q 695 1042 537 582 L 942 582 L 803 987 Z\n然而结果并不是很理想，有两个问题：\n上下颠倒了\n没有间距，挤在一起了\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: Adobe Illustrator 26.0.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<svg\nversion=\"1.1\"\nid=\"图层_1\"\nxmlns=\"http://www.w3.org/2000/svg\"\nxmlns:xlink=\"http://www.w3.org/1999/xlink\"\nx=\"0px\"\ny=\"0px\"\nviewBox=\"0 0 190 160\"\nstyle=\"enable-background:new 0 0 190 160;\"\nxml:space=\"preserve\"\n>\n<g>\n<path\nd=\"M 432 305 L 432 66 Q 432 -54 406 -146 Q 381 -238 324 -317 L 139 -317 Q 198 -246 235 -161 Q 272 -76 272 0 L 143 0 L 143 305 Z M 1425 0 L 1133 0 L 1008 360 L 471 360 L 346 0 L 51 0 L 565 1409 L 913 1409 Z M 760 1123 L 739 1192 L 733 1170 Q 723 1134 709 1088 Q 695 1042 537 582 L 942 582 L 803 987 Z\n\"\n/>\n</g>\n</svg>\n首先是颠倒的问题，比较好解决：y 坐标轴全取复数即可\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: Adobe Illustrator 26.0.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<svg\nversion=\"1.1\"\nid=\"图层_1\"\nxmlns=\"http://www.w3.org/2000/svg\"\nxmlns:xlink=\"http://www.w3.org/1999/xlink\"\nx=\"0px\"\ny=\"0px\"\nviewBox=\"0 0 190 160\"\nstyle=\"enable-background:new 0 0 190 160;\"\nxml:space=\"preserve\"\n>\n<g>\n<path\nd=\"M 432 -305 L 432 -66 Q 432 54 406 146 Q 381 238 324 317 L 139 317 Q 198 246 235 161 Q 272 76 272 0 L 143 0 L 143 -305 Z M 1116 0 L 844 0 Q 840 -15 834 -75 Q 829 -136 829 -176 L 825 -176 Q 734 20 479 20 Q 290 20 187 -127 Q 84 -275 84 -540 Q 84 -809 192 -955 Q 301 -1102 500 -1102 Q 615 -1102 698 -1054 Q 782 -1006 827 -911 L 829 -911 L 827 -1089 L 827 -1484 L 1108 -1484 L 1108 -236 Q 1108 -136 1116 0 Z M 831 -547 Q 831 -722 772 -816 Q 714 -911 600 -911 Q 487 -911 432 -819 Q 377 -728 377 -540 Q 377 -172 598 -172 Q 709 -172 770 -269 Z\n\"\n/>\n</g>\n</svg>\n其次是间距的问题。","利用-hmtx-和-kern-调整间距#利用 hmtx 和 kern 调整间距":"hmtx: horizontal metrics\nkern: kerning\n我们可以看到 hmtx 为每个 character name 存储了两个信息：\nprint(tt['hmtx'].metrics)\n>>> {'.notdef': (1536, 205), '.null': (0, 0), 'nonmarkingreturn': (569, 0), 'space': (569, 0), 'exclam': (682, 193), 'quotedbl': (971, 135), 'numbersign': (1139, 35), 'dollar': (1139, 27), 'percent': (1821, 51), 'ampersand': (1479, 90), 'quotesingle': (487, 109), 'parenleft': (682, 102), 'parenright': (682, 2), 'asterisk': (797, 6), 'plus': (1196, 86), 'comma': (569, 139), 'hyphen': (682, 80), 'period': (569, 139), 'slash': (569, 20), 'zero': (1139, 81), 'one': (1139, 129), 'two': (1139, 71), 'three': (1139, 47), 'four': (1139, 31), 'five': (1139, 63), 'six': (1139, 75), 'seven': (1139, 88), 'eight': (1139, 65), 'nine': (1139, 71), 'colon': (682, 197), 'semicolon': (682, 195), 'less': (1196, 86), 'equal': (1196, 85), 'greater': (1196, 86), 'question': (1251, 94), 'at': (1997, 117), 'A': (1479, 51), 'B': (1479, 137), 'C': (1479, 84), 'D': (1479, 137), 'E': (1366, 137), 'F': (1251, 137), 'G': (1593, 84), 'H': (1479, 137), 'I': (569, 137), 'J': (1139, 31), 'K': (1479, 137), 'L': (1251, 137), 'M': (1706, 137), 'N': (1479, 137), 'O': (1593, 84), 'P': (1366, 137), 'Q': (1593, 84), 'R': (1479, 137), 'S': (1366, 59), 'T': (1251, 23), 'U': (1479, 123), 'V': (1366, 14)\n而 kern 则为每两个 character name 存储了一个长度：\nprint(tt['kern'].kernTables[0].kernTable)\n>>> {('space', 'A'): -76, ('space', 'Y'): -37, ('space', 'Alphatonos'): -76, ('space', 'Alpha'): -76, ('space', 'Delta'): -76, ('space', 'Lambda'): -76, ('space', 'Upsilon'): -37, ('space', 'Upsilondieresis'): -37, ('one', 'one'): -113, ('A', 'space'): -76, ('A', 'T'): -152, ('A', 'V'): -152, ('A', 'W'): -113, ('A', 'Y'): -188, ('A', 'v'): -76, ('A', 'w'): -37, ('A', 'y'): -76, ('A', 'quoteright'): -113, ('F', 'comma'): -227, ('F', 'period'): -227, ('F', 'A'): -113, ('L', 'space'): -37, ('L', 'T'): -152, ('L', 'V'): -152, ('L', 'W'): -113, ('L', 'Y'): -188, ('L', 'y'): -76, ('L', 'quoteright'): -113, ('P', 'space'): -37,\n其中 hmtx 定义了每个字的宽度，而 kern 则定义了一些特殊字形（比如上标 å ）的偏移距离。综上所述，我们就可以用这两个表计算出一个字符在一串字符中应该处于哪个位置。便于展示，这里省略了换行情况下 y 轴的处理：\nx = 0\ny = 0\nsvg_paths = []\nfor i, gl in enumerate(gls):\nax = tt['hmtx'].metrics[cname[i]][0]\n\ndata = gl.data\n\ndata = parse_glyf(data)\nprint(data)\ndata['xs'] = [i + ax + x for i in data['xs']]\n# data['ys'] = [i + ax + x for i in data['ys']]\nsvg_path = simple_Glyphfunction(data)\nsvg_paths.extend(svg_path)\n\nprint(' '.join(map(lambda x: x if isinstance(x, str) else str(x), svg_paths)))\n>>> M 1001 -305 L 1001 -66 Q 1001 54 975 146 Q 950 238 893 317 L 708 317 Q 767 246 804 161 Q 841 76 841 0 L 712 0 L 712 -305 Z M 2367 0 L 2095 0 Q 2091 -15 2085 -75 Q 2080 -136 2080 -176 L 2076 -176 Q 1985 20 1730 20 Q 1541 20 1438 -127 Q 1335 -275 1335 -540 Q 1335 -809 1443 -955 Q 1552 -1102 1751 -1102 Q 1866 -1102 1949 -1054 Q 2033 -1006 2078 -911 L 2080 -911 L 2078 -1089 L 2078 -1484 L 2359 -1484 L 2359 -236 Q 2359 -136 2367 0 Z M 2082 -547 Q 2082 -722 2023 -816 Q 1965 -911 1851 -911 Q 1738 -911 1683 -819 Q 1628 -728 1628 -540 Q 1628 -172 1849 -172 Q 1960 -172 2021 -269 Z\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: Adobe Illustrator 26.0.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<svg\nversion=\"1.1\"\nid=\"图层_1\"\nxmlns=\"http://www.w3.org/2000/svg\"\nxmlns:xlink=\"http://www.w3.org/1999/xlink\"\nx=\"0px\"\ny=\"0px\"\nviewBox=\"0 0 190 160\"\nstyle=\"enable-background:new 0 0 190 160;\"\nxml:space=\"preserve\"\n>\n<g>\n<path\nd=\"M 1001 -305 L 1001 -66 Q 1001 54 975 146 Q 950 238 893 317 L 708 317 Q 767 246 804 161 Q 841 76 841 0 L 712 0 L 712 -305 Z M 2367 0 L 2095 0 Q 2091 -15 2085 -75 Q 2080 -136 2080 -176 L 2076 -176 Q 1985 20 1730 20 Q 1541 20 1438 -127 Q 1335 -275 1335 -540 Q 1335 -809 1443 -955 Q 1552 -1102 1751 -1102 Q 1866 -1102 1949 -1054 Q 2033 -1006 2078 -911 L 2080 -911 L 2078 -1089 L 2078 -1484 L 2359 -1484 L 2359 -236 Q 2359 -136 2367 0 Z M 2082 -547 Q 2082 -722 2023 -816 Q 1965 -911 1851 -911 Q 1738 -911 1683 -819 Q 1628 -728 1628 -540 Q 1628 -172 1849 -172 Q 1960 -172 2021 -269 Z\"\n/>\n</g>\n</svg>\n至此，我们完成了从 unicode 字符到 SVG 图片的渲染，单从这一步来看，并没有多少技术难度，更多的是对字体文件标准的把握，作为入门，我觉得已经够了。所有上文中提到的代码统一整合后放在 ttf-render-demo"}},"/":{"title":"Hi, there","data":{"":""}},"/tutorial/algorithm/category/0":{"title":"README","data":{"":"","链表#链表":"","树#树":"题目简单，主要考察对 Python 语法的利用\n迭代器\n\n可以参考 halfrost 写的关于数据规模和时间复杂度要求的关系。\nhttps://github.com/BBuf/ACM_template/\nhttps://leetcode.wang/"}},"/tutorial/algorithm/category/backtracking/0":{"title":"广度优先遍历","data":{"":"","864-获取所有钥匙的最短路径#864. 获取所有钥匙的最短路径":"复杂度 $O(4mn*2^k)$\nclass Solution:\ndef shortestPathAllKeys(self, grid: List[str]) -> int:\ndirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\nm, n = len(grid), len(grid[0])\nsx = sy = 0\nkey_to_idx = dict()\n\n# 给所有的钥匙分配二进制位\nfor i in range(m):\nfor j in range(n):\nif grid[i][j] == \"@\":\nsx, sy = i, j\nelif grid[i][j].islower():\nkey_to_idx[grid[i][j]] = 1 << len(key_to_idx)\n\nall_mask = (1 << len(key_to_idx)) - 1\n\n# 广度优先遍历\nq = deque([(sx, sy, 0)])\ndist = dict()\ndist[(sx, sy, 0)] = 0\nwhile q:\nx, y, mask = q.popleft()\n# 沿四个方向迭代\nfor dx, dy in dirs:\nnx, ny = x + dx, y + dy\n\n# 边界判断\nif nx < 0 or nx >= m or ny < 0 or ny >= n or grid[nx][ny] == '#':\ncontinue\n\n# 普通路线\nif grid[nx][ny] == \".\" or grid[nx][ny] == \"@\":\n# 当前的 mask 没走过这条路，此时 dist[(nx,ny,mask)] 是当前 mask 状态到该房间的最短路线，一共有 2^k 个 mask 状态\nif (nx, ny, mask) not in dist:\ndist[(nx, ny, mask)] = dist[(x, y, mask)] + 1\nq.append((nx, ny, mask))\nelif grid[nx][ny].islower():\nidx = key_to_idx[grid[nx][ny]]\n# 这条时间线没拿过这个钥匙\nif (nx, ny, mask | idx) not in dist:\ndist[(nx, ny, mask | idx)] = dist[(x, y, mask)] + 1\n# 拿了这个钥匙后拿全所有钥匙了\nif (mask | idx) == all_mask:\nreturn dist[(nx, ny, mask | idx)]\nq.append((nx, ny, mask | idx))\nelse: # 大写字母，锁\nidx = key_to_idx[grid[nx][ny].lower()]\n# 该 mask 可以解锁，且之前没遍历过\nif (mask & idx) and (nx, ny, mask) not in dist:\ndist[(nx, ny, mask)] = dist[(x, y, mask)] + 1\nq.append((nx, ny, mask))\n\nreturn -1"}},"/tutorial/algorithm/category/backtracking/1":{"title":"深度优先遍历","data":{"":"dfs 一般用递归实现（也可以用栈模拟，有时会常数时间会低一些）。一般有两种情况，一种是遍历到最后一层时返回结果（生成类），一种是在每一层都会做一个标记（地图类）。","547-省份数量#547. 省份数量":"深度遍历一遍，每遇到一个未访问过的结点，就将该结点及其相邻节点全部标记为已访问\nclass Solution:\ndef findCircleNum(self, isConnected: List[List[int]]) -> int:\nrow = len(isConnected)\nvisited = [0] * row\ndef dfs(i):\nvisited[i] = 1\nfor j in range(row):\nif isConnected[i][j] == 1 and not visited[j]:\nisConnected[i][j] = -1\ndfs(j)\n\nans = 0\n\nfor i in range(row):\nif not visited[i]:\ndfs(i)\nans += 1\n\nreturn ans\n\n如果输入是邻接表的形式，也可以用并查集的方式来实现","130-被围绕的区域#130. 被围绕的区域":"一般都遍历思路是两层 for 循环，需要判断边界状态。重新考虑从外向内 dfs，只有在外侧的最终才会保持在 O 的状态，因此在最外侧来一次 dfs 标记状态既可以区分围绕区域和非围绕区域。还是要关注围绕区域和非围绕区域最本质的区别。\nclass Solution:\ndef solve(self, board: List[List[str]]) -> None:\n\"\"\"\nDo not return anything, modify board in-place instead.\n\"\"\"\n\nrow = len(board)\ncol = len(board[0])\n\nqueue = []\n\ndef dfs(i,j):\nif i < 0 or i >= row or j < 0 or j >= col or board[i][j] != 'O':\nreturn\n\nboard[i][j] = '-'\n(dfs(i-1,j),dfs(i+1,j),dfs(i,j+1),dfs(i,j-1))\n\nfor i in range(row):\ndfs(i,0)\ndfs(i,col-1)\n\nfor j in range(1,col-1):\ndfs(0,j)\ndfs(row-1,j)\n\nfor i in range(row):\nfor j in range(col):\nif board[i][j] == '-':\nboard[i][j] = 'O'\nelse:\nboard[i][j] = 'X'","784-字母大小写全排列#784. 字母大小写全排列":"第一遍循环拿到字母的下标，第二遍遍历下标的状态空间。\nclass Solution:\ndef letterCasePermutation(self, s: str) -> List[str]:\nidx = [i for i,c in enumerate(s) if c.isalpha()]\ns = list(s)\n\ndef dfs(ix):\nif ix >= len(idx):\nyield ''.join(s)\nreturn\ni = idx[ix]\n\n\ns[i] = s[i].upper()\nyield from dfs(ix+1)\n\ns[i] = s[i].lower()\nyield from dfs(ix+1)\n\nreturn list(dfs(0))","22-括号生成#22. 括号生成":"简单利用 dfs，每层都可以有添加左括号、右括号两个状态空间，左括号添加的边界是值 > 0，右括号添加的边界是值多于左括号。\nclass Solution:\ndef generateParenthesis(self, n: int) -> List[str]:\ndef dfs(l,r,c=''):\nif l == r == 0:\nyield c\nreturn\n\nif l > 0:\nyield from dfs(l-1,r,c+'(')\n\nif l < r:\nyield from dfs(l,r-1,c+')')\n\nreturn list(dfs(n,n))"}},"/tutorial/algorithm/category/backtracking":{"title":"Index","data":{"":""}},"/tutorial/algorithm/category/dynamic-programing/0":{"title":"0.简单","data":{"":"将 dp 数组中的最值或者最后一个值定义为问题的解，该解可以通过以求得的子问题的解 + 状态转移函数求得","1137-第-n-个泰波那契数#1137. 第 N 个泰波那契数":"dp[i] 的子问题： dp[i-1]/dp[i-2]/dp[i-3]\n状态转移函数：问题中的函数\n\n\nclass Solution:\ndef tribonacci(self, n: int) -> int:\ndp = list(range(38))\ndp[0] = 0\ndp[1] = 1\ndp[2] = 1\n\nfor i in range(3,n+1):\ndp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n\nreturn dp[n]","1646-获取生成数组中的最大值#1646. 获取生成数组中的最大值":"class Solution:\ndef getMaximumGenerated(self, n: int) -> int:\n# 边界判定\nif n == 0:\nreturn 0\nif n == 1:\nreturn 1\n\ndp = [0] * (n+1)\ndp[0] = 0\ndp[1] = 1\n# 直接根据公式推\nfor i in range(1,n+1):\nif i * 2 <= n:\ndp[2*i] = dp[i]\nif i * 2 + 1 <= n:\ndp[2*i+1] = dp[i] + dp[i+1]\n\nreturn max(dp) # 开销和在循环过程中进行是一样的 ON","1025-除数博弈#1025. 除数博弈":"可以查看题解 初步感受推导的过程\nclass Solution:\ndef divisorGame(self, n: int) -> bool:\nreturn n % 2 == 0","746-使用最小花费爬楼梯#746. 使用最小花费爬楼梯":"dp[i] 的子问题：dp[i-2]/dp[i-1]\n状态转移函数：爬两种台阶的最小值+当前爬楼梯的花费\n\n\nclass Solution:\ndef minCostClimbingStairs(self, cost: List[int]) -> int:\n# 题目范围 len(cost) >= 2，不需要边界判定\ndp = [0] * len(cost)\ndp[0] = cost[0]\ndp[1] = cost[1]\n\nfor i in range(2,len(cost)):\ndp[i] = min(\ndp[i-2], # 爬两个楼梯\ndp[i-1], # 爬一个楼梯\n) + cost[i]\n\nreturn min(dp[-1],dp[-2]) # 从倒数第一个或倒数第二个楼梯开始爬","53-最大子数组和#53. 最大子数组和":"子问题：nums[:i] 中的累积值\n状态转移函数 max_v = max(max_v, acc + nums[i])\n\n当遍历到 nums[i] 时，如果 sum(nums[:i]) 大于 0，那么 max_v = max(max_v, acc)：\n如果遍历到 i 时，i 之前的序列和 acc = sum(nums[:i]) < 0，那么之前的序列一定是可以被抛掉的（否则只会越加越小）\n如果遍历到 i 时，i 之前的序列和 acc = sum(nums[:i]) >= 0，那么最大值要么在遍历 i 之前的过程中产生，要么在 acc + nums[i] 中产生，所以 max_v = max(max_v, acc + nums[i])\n在第一个状态时 max_v = nums[0], acc = 0\n\n\nclass Solution:\ndef maxSubArray(self, nums: List[int]) -> int:\nacc = 0\nmax_v = nums[0]\n\nfor i in range(len(nums)):\nif acc < 0:\nacc = 0\n\nacc += nums[i]\nmax_v = max(max_v, acc)\n\nreturn max_v","338-比特位计数#338. 比特位计数":"# dp[i] 为 dp[i] 的1的个数\n# dp[i>>1] = dp[i] - 1 #如果 i 是奇数\n# dp[i>>1] = dp[i] #如果 i 是偶数\n\nclass Solution:\ndef countBits(self, n: int) -> List[int]:\ndp = list(range(n+1))\n\nfor i in range(n+1):\ndp[i] = dp[i>>1] + (i & 1)\n\nreturn dp\n\ndef countBits1(self, n: int) -> List[int]:\ndp = list(range(n+1))\n\nfor i in range(n+1):\nif i % 2 == 0:\ndp[i] = dp[i>>1]\nelse:\ndp[i] = dp[i>>1] + 1\n\nreturn dp","62-不同路径#62. 不同路径":"第一行和第一列都是 1，右下角的路径数等于在上面一行下来和左边过来的路径数的和\nclass Solution:\ndef uniquePaths(self, m: int, n: int) -> int:\n\ndp = [[0] * n for i in range(m)]\n\nfor i in range(m):\ndp[i][0] = 1\n\nfor j in range(n):\ndp[0][j] = 1\n\nfor i in range(1,m):\nfor j in range(1,n):\n\ndp[i][j] = dp[i-1][j] + dp[i][j-1]\n\nreturn dp[-1][-1]\n观察状态转移函数，dp[i-1][j] 来自上一次循环，dp[i][j-1] 来自同循环的前一个值，所以可以压缩二维数组为一维数组。\nclass Solution:\ndef uniquePaths(self, m: int, n: int) -> int:\ndp = [1] * n\nfor i in range(1,m):\nfor j in range(1,n):\ndp[j] = dp[j] + dp[j-1]\n\nreturn dp[-1]","63-不同路径-ii#63. 不同路径 II":"跟上题相同，唯一的区别是障碍物处的路径数归 0\nclass Solution:\ndef uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\nm = len(obstacleGrid)\nn = len(obstacleGrid[0])\n\ndp = [1] * n\n\nfor i in range(m):\nfor j in range(n):\nif obstacleGrid[i][j] == 1:\ndp[j] = 0\nelif i == 0 and j > 0: # 第一行判断\ndp[j] = dp[j-1]\nelif j > 0: # 边界判断\ndp[j] = dp[j] + dp[j-1]\n\nreturn dp[-1]","121-买卖股票的最佳时机#121. 买卖股票的最佳时机":"重点是注意到 $max(|j-j'|)$ 通过拆项可以从 $O(n^2)$ 优化到 $O(n)$。类似的题都可以通过类似的方式求解。\nclass Solution:\n\ndef maxProfit(self, prices: List[int]) -> int:\nright = prices[:]\n\nfor i in reversed(range(len(prices)-1)):\nright[i] = max(right[i],right[i+1])\n\nmax_v = 0\nfor i in range(len(prices)):\nmax_v = max(right[i]-prices[i],max_v)\n\nreturn max_v\n随后发现空间复杂度可以优化到 O(1)\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nright = prices[-1]\nmax_v = 0\nfor i in reversed(range(len(prices))):\nright = max(right,prices[i])\nmax_v = max(right-prices[i],max_v)\nreturn max_v","64-最小路径和#64. 最小路径和":"dp[n][m]，先写状态转移公式：dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]，随后可以根据状态转移公式直接压缩空间复杂度。\nclass Solution:\ndef minPathSum(self, grid: List[List[int]]) -> int:\n# dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\nn = len(grid)\nm = len(grid[0])\ndp = [0] * m\nfor i in range(n):\nfor j in (range(m)):\nif i == 0:\ndp[j] = dp[j-1] + grid[i][j]\nelse:\ndp[j] = min(dp[j],dp[j-1]) + grid[i][j]\nreturn dp[-1]","91-解码方法#91. 解码方法":"类似于爬楼梯，但是要注意 '0'\nclass Solution:\ndef numDecodings(self, s: str) -> int:\nm = {str(i):i for i in range(1,27)}\n\ndp = [1] + [0] * len(s)\n\nfor i in range(len(s)):\nif s[i] != '0':\ndp[i+1] += dp[i]\n\nif i>0 and s[i-1]+s[i] in m:\ndp[i+1] += dp[i-1]\n\nreturn dp[-1]\n上面的式子同一时间只出现三个状态，因此可以直接优化为 a,b,c 三个滚动变量\nclass Solution:\ndef numDecodings(self, s: str) -> int:\nm = {str(i):i for i in range(1,27)}\n\na,b,c = 0,1,0 # dp[i-1],dp[i],dp[i+1]\nfor i in range(len(s)):\nif s[i] != '0':\nc += b\n\nif i>0 and s[i-1]+s[i] in m:\nc += a\na,b,c = b,c,0\n\nreturn b","97-交错字符串#97. 交错字符串":"令 dp[i][j] 表示 s3[i+j-1] 是否存在交错字符串，则：\n如果 s3[i+j-1] == s2[j-1]，则 dp[i][j] = dp[i][j-1]\n如果 s3[i+j-1] == s1[i-1]，则 dp[i][j] = dp[i-1]\n\n\nclass Solution:\ndef isInterleave(self, s1: str, s2: str, s3: str) -> bool:\nif len(s1) + len(s2) != len(s3):\nreturn False\n\nif s1 == '':\nreturn s2 == s3\nif s2 == '':\nreturn s1 == s3\n\nn = len(s1)+1\nm = len(s2)+1\n\ndp = [[False] * m for i in range(n)]\ndp[0][0] = True\n\nfor i in range(n):\nfor j in range(m):\nif i == 0 and j == 0:\ncontinue\n\ndp[i][j] = (\ndp[i-1][j] and (s3[i+j-1] == s1[i-1]) or\ndp[i][j-1] and (s3[i+j-1] == s2[j-1])\n)\n\nreturn dp[-1][-1]\n根据转移公式可得状态空间优化代码：\nclass Solution:\ndef isInterleave(self, s1: str, s2: str, s3: str) -> bool:\nif len(s1) + len(s2) != len(s3):\nreturn False\n\nif s1 == '':\nreturn s2 == s3\nif s2 == '':\nreturn s1 == s3\n\nn = len(s1)+1\nm = len(s2)+1\n\ndp = [False] * m\ndp[0] = True\n\nfor i in range(n):\nfor j in range(m):\nif i == 0 and j == 0:\ncontinue\n\ndp[j] = (\ndp[j] and (s3[i+j-1] == s1[i-1]) or\ndp[j-1] and (s3[i+j-1] == s2[j-1])\n)\n\nreturn dp[-1]","120-三角形最小路径和#120. 三角形最小路径和":"简单分析可得状态转移函数为 dp[i][j] = min(dp[i-1][j],dp[i-1][j-1]) + triangle[i][j]\nclass Solution:\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\nn = len(triangle)\ndp = [[float('inf')] * n for _ in range(n)]\ndp[0][0] = triangle[0][0]\n\nfor i in range(1,n):\nfor j in range(i+1):\ndp[i][j] = min(dp[i-1][j],dp[i-1][j-1]) + triangle[i][j]\n\nreturn min(dp[-1])\n从上到下数组越来越多，从下到上数组越来越少。因此从下到上选择路径其实更容易从转移函数上直接优化空间复杂度。此时状态转移函数是 dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + triangle[i][j]。\nclass Solution:\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\nn = len(triangle)\ndp = triangle[-1]\n\nfor i in reversed(range(n-1)):\nfor j in range(i+1):\ndp[j] = min(dp[j],dp[j+1]) + triangle[i][j]\n\nreturn dp[0]\n\n从上到下压缩空间复杂度时，三角形右对齐更容易压缩空间复杂度。"}},"/tutorial/algorithm/category/dynamic-programing/1":{"title":"1.中等","data":{"":"","1937-扣分后的最大得分#1937. 扣分后的最大得分":"最初的动态规划公式的复杂度是 $O(mn^2)$，因为 $max({f[i-1][j'] - |j-j'|})$ 中 $|j-j'|$ 的状态空间是 $n^2$。该项可以根据 $j,j'$ 的相对关系拆分优化。\n$j<=j'$ 时， $max({f[i-1][j'] - |j-j'|}) = max({f[i-1][j'] - j + j'}) = max({f[i-1][j'] + j'}) - j $\n$j>j'$ 时， $max({f[i-1][j'] - |j-j'|}) = max({f[i-1][j'] - j' + j }) = max({f[i-1][j'] - j'}) + j $\n\n此时，max 的状态空间是 n。在每层 i 循环时，对每个 j，依次寻找 j<=j' 和 j>j' 时的最大值。这一操作等同于正序和逆序遍历，在第二次逆序遍历时取最大值。从而将复杂度优化为 $O(m2n) = O(mn)$\nclass Solution:\ndef maxPoints(self, points: List[List[int]]) -> int:\nm = len(points)\nn = len(points[0])\n\ndp = [[float(\"-inf\")] * n for i in range(m)]\n\nfor i in range(n):\ndp[0][i] = points[0][i]\n\nfor i in range(1,m):\nbest = float(\"-inf\")\nfor j in range(n):\nbest = max(best, dp[i-1][j] + j)\ndp[i][j] = best + points[i][j] - j\n\nbest = float(\"-inf\")\nfor j in reversed(range(n)):\nbest = max(best, dp[i-1][j] - j)\ndp[i][j] = max(dp[i][j],best + points[i][j] + j)\n\nreturn max(dp[-1])\n\n上述的空间复杂度可以由 $O(mn)$ 优化到 $O(2n)$，不再赘述","1402-做菜顺序#1402. 做菜顺序":"简单推理出需要排序和累积和，只要累积和大于 0，就可以继续做菜。\nclass Solution:\ndef maxSatisfaction(self, satisfaction: List[int]) -> int:\nsatisfaction = list(reversed(sorted(satisfaction)))\nans = 0\nacc = 0\ndp = [0] * len(satisfaction)\n\nfor i in range(len(satisfaction)):\nacc += satisfaction[i]\nif acc >= 0:\ndp[i] = satisfaction[i] + (dp[i-1] if i>0 else 0)\nans += dp[i]\nelse:\nbreak\n\nreturn ans","72-编辑距离#72. 编辑距离":"分别归类三种状态即可\nclass Solution:\ndef minDistance(self, word1: str, word2: str) -> int:\ndp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)]\n\nfor i in range(len(word1)+1):\ndp[i][0] = i\nfor j in range(len(word2)+1):\ndp[0][j] = j\n\nfor i in range(1, len(word1)+1):\nfor j in range(1, len(word2)+1):\nif word1[i-1] == word2[j-1]:\ndp[i][j] = min(dp[i-1][j-1],dp[i-1][j]+1,dp[i][j-1]+1)\nelse:\ndp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)\n\nreturn dp[-1][-1]","915-分割数组#915. 分割数组":"题目的要求可以转化为，要求找到一个最小的 i，i 左侧最大元素小于等于 i 右侧最小元素令 left[i] 表示 i 左侧最大的元素，right[i] 表示 i 右侧最小的元素，则返回第一个 left[i-1] <= right[i] 的 i 即可\nclass Solution:\ndef partitionDisjoint(self, nums: List[int]) -> int:\nleft = [0] * len(nums)\nright = [0] * len(nums)\nleft[0] = nums[0]\nright[-1] = nums[-1]\nfor i in range(1,len(nums)):\nleft[i] = max(left[i-1],nums[i])\n\nfor i in reversed(range(len(nums)-1)):\nright[i] = min(right[i+1],nums[i])\n\nfor i in range(1,len(nums)):\nif left[i-1] <= right[i]:\nreturn i\n注意最后一次遍历顺序和 left 更新顺序一致，因此可以压缩 left 的空间复杂度为 $O(1)$，此时整体空间时间复杂度不变。\nclass Solution:\ndef partitionDisjoint(self, nums: List[int]) -> int:\nright = [nums[-1]] * len(nums)\nleft = nums[0]\nfor i in reversed(range(len(nums)-1)):\nright[i] = min(right[i+1],nums[i])\n\nfor i in range(1,len(nums)):\nleft = max(left,nums[i-1])\nif left <= right[i]:\nreturn i\n最后注意到 left[i-1] <= right[i] 的判定并不是每次都要做，可以先假定一个 i，认定 left[i-1] < right[i]，一旦遍历过程中存在 nums[i] < left[i-1]，就更新 i 维持该假设。此时时间复杂度 $O(N)$,空间复杂度 $O(1)$\nclass Solution:\ndef partitionDisjoint(self, nums: List[int]) -> int:\nrl = left = nums[0]\nres = 0\nfor i in range(1,len(nums)):\nleft = max(left,nums[i-1])\nif rl > nums[i]:\nres = i\nrl = left\nreturn res+1","221-最大正方形#221. 最大正方形":"令 dp[i][j] 为以 i,j 为右下角可以组成的最大正方形。注意到当 i,j 左侧、上侧、左上侧均为相同长度的正方形时，dp[i][j] 可以组成一个长度 +1 的更大的正方形。\nclass Solution:\ndef maximalSquare(self, matrix: List[List[str]]) -> int:\nrow = len(matrix)\nif row == 0:\nreturn 0\n\ncol = len(matrix[0])\nif col == 0:\nreturn 0\n\ndp = [[0] * col for i in range(row)]\nans = 0\nfor i in range(row):\nfor j in range(col):\nif i == 0 or j == 0:\ndp[i][j] = int(matrix[i][j])\nelif matrix[i][j] == '0':\ndp[i][j] = 0\nelse:\ndp[i][j] = min(\ndp[i-1][j],\ndp[i][j-1],\ndp[i-1][j-1]\n) + 1\nans = max(ans,dp[i][j]**2)\n\nreturn ans\n该题也可以用 85. 最大矩形 的单调栈解法来解，需要把面积公式修改为 min(right[i]-left[i]-1,heights[i])**2。","764-最大加号标志#764. 最大加号标志":"分别从四个方向统计最大延伸长度并取最小值。复杂度 $O(N^2)$\nclass Solution:\ndef orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\ndp = [[n] * n for _ in range(n)]\nbanned = set(map(tuple, mines))\nfor i in range(n):\n# left\ncount = 0\nfor j in range(n):\ncount = 0 if (i, j) in banned else count + 1\ndp[i][j] = min(dp[i][j], count)\n# right\ncount = 0\nfor j in range(n - 1, -1, -1):\ncount = 0 if (i, j) in banned else count + 1\ndp[i][j] = min(dp[i][j], count)\nfor j in range(n):\n# up\ncount = 0\nfor i in range(n):\ncount = 0 if (i, j) in banned else count + 1\ndp[i][j] = min(dp[i][j], count)\n# down\ncount = 0\nfor i in range(n - 1, -1, -1):\ncount = 0 if (i, j) in banned else count + 1\ndp[i][j] = min(dp[i][j], count)\nreturn max(map(max, dp))"}},"/tutorial/algorithm/category/dynamic-programing/2":{"title":"2.复杂","data":{"":"","32-最长有效括号#32. 最长有效括号":"对于统计类的，一般是 $O(n)$ 的复杂度。令 dp[i] 是到 dp[i] 可组成的最长有效括号，最后返回的结果是 max(dp)。将连续括号的类型分情况讨论：\n嵌套括号 (())\n无效括号（包括有效括号） ())\n连续括号（包含嵌套可能） ()(())\n\n\n((()))\n000246\n())\n020\n()(())\n020026\n()((())\n0200024\n()()())\n0202020\n经过上面的示例，可以得出以下总结：\n( 一直是 0\n) 需要考虑三部分\n左侧相邻：左侧是 ( 时 + 2\n内侧相邻：左侧是 ) 时且对称侧是 ( 时 + dp[i-1] + 2\n左侧外相邻：对称侧是 ( 时 + dp[i-dp[i-1]-2] + 2\n\n\n\n其中，对称侧的下标是 i-dp[i-1]-1，左侧外相邻的下标是 i-dp[i-1]-2，需要检查下标是否越界。最后，观察到对于无嵌套的括号 ()(), i=3 时，dp[i-1] = 0 对称侧下标 i-dp[i-1]-1 就是 i-1，因此左侧相邻的情况可以直接和内侧相邻的情况合并。\n# 合并同类项\nclass Solution:\ndef longestValidParentheses(self, s: str) -> int:\n\ndp = [0] * len(s)\nmax_v = 0\nfor i in range(1,len(s)):\nif s[i] == ')':\noffset = 0\n\nmatch_index = i - dp[i-1] - 1\npre_index = match_index-1\n\nif match_index >= 0 and s[match_index] == '(':\noffset += dp[i-1] + 2\n\nif pre_index >= 0:\noffset += dp[pre_index]\n\ndp[i] = offset\nmax_v = max(max_v,dp[i])\nreturn max_v","907-子数组的最小值之和#907. 子数组的最小值之和":"目前的方法超时了，需要推导动态规划的式子进行优化\n\n\nclass Solution:\ndef sumSubarrayMins(self, arr: List[int]) -> int:\ndp = [[1e5] * len(arr) for i in arr]\n\nans = 0\nfor i in range(len(arr)):\nfor j in range(i,len(arr)):\nif i == j:\ndp[i][j] = arr[i]\ndp[i][j] = min(arr[j],dp[i][j-1])\n\nans = (ans + dp[i][j]) % (1e9+7)\n\nreturn int(ans)","524-通过删除字母匹配到字典里最长单词#524. 通过删除字母匹配到字典里最长单词":"暴力双指针可以通过\nclass Solution:\ndef findLongestWord(self, s: str, dictionary: List[str]) -> str:\ndef edit(s,t):\ni = j = 0\nwhile i < len(s) and j < len(t):\nif s[i] == t[j]:\ni += 1\nj += 1\nelse:\ni += 1\nif j == len(t):\nreturn True\nreturn False\n\nans = ''\nfor t in dictionary:\nif edit(s,t):\nans = min(ans,t,key=lambda x:(-len(x),x))\n\nreturn ans\n编辑距离的时间复杂度是 $O(m+n)$，注意到 i 遍历的过程实质是在找 i 之后下一个匹配到 t[j] 的元素，该部份 $O(m)$ 的复杂度可以通过预先计算的方式将复杂度降为 $O(1)$。用于这一转移过程的数组叫做序列自动机，可以用于子序列匹配。令 dp[n][26] 存储字符 s 的转移状态，dp[i][j] 表示下标 i 之后字母 j 出现的位置。\nord(s[i]) - 97 == j -> dp[i][j] = i：\n\n\nclass Solution:\ndef findLongestWord(self, s: str, dictionary: List[str]) -> str:\nn = len(s)\ndp = [[0] * 26 for _ in range(n)]\ndp.append([n] * 26)\n\nfor i in reversed(range(n)):\nfor j in range(26):\nif ord(s[i]) == j + 97:\ndp[i][j] = i\nelse:\ndp[i][j] = dp[i + 1][j]\n\ndef edit(s,t):\ni = j = 0\nfor j in range(len(t)):\nif dp[i][ord(t[j])-97] == n:\nreturn False\ni = dp[i][ord(t[j])-97] + 1\n\nreturn True\n\nans = ''\nfor t in dictionary:\nif edit(s,t):\nans = min(ans,t,key=lambda x:(-len(x),x))\n\nreturn ans\n\ndefaultdict 内存优化","790-多米诺和托米诺平铺#790. 多米诺和托米诺平铺":"!important该题的思路有平铺状态转移和推导状态转移两种。","平铺状态转移#平铺状态转移":"令 dp[i][4] 表示第 i 列之前全部铺好时，i 列和 i+1 列组成的正方形的状态，共有 4 种：\n[i][0]  [i][1]  [i][2]  [i][3]\n1 0     1 0     1 1     1 1\n1 0     1 1     1 0     1 1\n分析可得：\n# | 1 0\n# | 1 0\ndp[i][0] = dp[i - 1][3] # i-1 列 + Domino\n# 第一种\n# | 1 0\n# | 1 1\n# 第二种\n# | | 0\n# | 1 1\ndp[i][1] = dp[i - 1][0] + dp[i - 1][2] # [i-1][0] + Tromino 和 [i-1][2] + Domino\n# 第一种\n# | 1 1\n# | 1 0\n# 第二种\n# | 1 1\n# | | 0\ndp[i][2] = dp[i - 1][0] + dp[i - 1][1]\n# 第一种\n# | 1 1\n# | | 1\n# 第二种\n# | | 1\n# | 1 1\n# 第三种\n# | | 1\n# | | 1\ndp[i][3] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]\n\nMOD = 10 ** 9 + 7\nclass Solution:\ndef numTilings(self, n: int) -> int:\ndp = [[0] * 4 for _ in range(n + 1)]\ndp[0][3] = 1\nfor i in range(1, n + 1):\ndp[i][0] = dp[i - 1][3]\ndp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % MOD\ndp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % MOD\ndp[i][3] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % MOD\nreturn dp[n][3]","公式推导转移#公式推导转移":"直接令 dp[i] 为第 i 列的状态，细节图请看 大佬的题解\nMOD = 10 ** 9 + 7\n\nclass Solution:\ndef numTilings(self, n: int) -> int:\nif n == 1: return 1\nf = [0] * (n + 1)\nf[0] = f[1] = 1\nf[2] = 2\nfor i in range(3, n + 1):\nf[i] = (f[i - 1] * 2 + f[i - 3]) % MOD\nreturn f[n]","805-数组的均值分割#805. 数组的均值分割":"可以推导得出数组 A、数组 B 如果存在，则 A、B 数组的平均值 avg(A), avg(B)等于整个数组的平均值 avg(nums)\nclass Solution:\ndef splitArraySameAverage(self, nums: List[int]) -> bool:\nn = len(nums)\nif n == 1:\nreturn False\n\nnsum = sum(nums)\n# 避免浮点数运算的 trick，此时 avg(nums) == 0, 要寻找的 avg(A)/sum(A) 和 avg(B)/sum(B) 也为 0\nnums = [i*n - nsum for i in nums]\nleft = set()\nm = n // 2\n\n# tol == 0 时肯定不会导致全选，此时 tol == 0 的选择自行构造为数组 A，另一部分为数组 B 即可\nfor i in range(1,(1<<m)-1): # 每一个循环代表一种选择情况，相应的二进制位是 1 则选，否则不选\n# 对每个 num 的下标 j， j\ntol = sum([nums[j] for j in range(m) if 1<< j & i])\n\nif tol == 0: # 一部分为 0，一定有另一部分也为 0（因为总和为 0）\nreturn True\n\n# 加入候选集\nleft.add(tol)\n\nnums = nums[m:]\nrsum = sum(nums)\nfor i in range(1,1<<(n-m)):\ntol = sum([nums[j] for j in range(n-m) if 1<<j & i])\n\n# tol == 0 表示当前选择可行\n# -tol in left 表示当前选择在 left 中存在另一组选择可以组成数组 A\nif tol == 0 or (-tol in left):\nreturn True\n\n# 如何避免选中整个 nums 作为数组 A？\n# 此时 sum(nums) == 0, 所以 -tol in left 时，如果 [:m]中没有全选的状态，那一定是合法的 A\n# - [ ] 如果 [:m] 中有全选的状态，如果 rsum == tol，说明\n\nreturn False"}},"/tutorial/algorithm/category/dynamic-programing/3":{"title":"README","data":{"":""}},"/tutorial/algorithm/category/dynamic-programing":{"title":"Index","data":{"":""}},"/tutorial/algorithm/category/dynamic-programing/problem-set/0":{"title":"一次失败的背包优化","data":{"":"对多重背包问题，试图使用 Counter 计数的方式来加以约束，直接达到 $O(NW)$ 的复杂度\nclass Solution:\ndef packProblem3(self, weight: List[int], value: List[int], count: List[int], limit: int) -> int:\ndp = [[[0, Counter()] for _ in range(limit + 1)] for _ in range(len(weight))]\n\nfor i in range(len(weight)):  # 对第 i 个物品\nfor j in range(limit + 1):  # 容量限制是 j 时, range(limit+1) 的最后一个循环 j = limit\nif j - weight[i] >= 0:\nflag = False\nif dp[i - 1][j - weight[i]][1][i] < count[i] and (dp[i - 1][j - weight[i]][0] + value[i]) > \\\ndp[i - 1][j][0]:\ndp[i][j][0] = (dp[i - 1][j - weight[i]][0] + value[i])\ndp[i][j][1] = dp[i - 1][j - weight[i]][1].copy()\nflag = True\n\nif dp[i][j - weight[i]][1][i] < count[i] and (dp[i][j - weight[i]][0] + value[i]) > dp[i - 1][j][0]:\ndp[i][j][0] = (dp[i][j - weight[i]][0] + value[i])\ndp[i][j][1] = dp[i][j - weight[i]][1].copy()\nflag = True\n\nif flag:\ndp[i][j][1].update([i])\ncontinue\ndp[i][j][0] = dp[i - 1][j][0]\ndp[i][j][1] = dp[i - 1][j][1].copy()\nprint(dp[i])\nreturn dp[-1][-1][0]  # dp[N][W]\n后来发现存在问题\n[[0, Counter()], [15, Counter({0: 1})], [30, Counter({0: 2})], [45, Counter({0: 3})], [15, Counter({0: 1})], [30, Counter({0: 2})], [45, Counter({0: 3})]]\n[[0, Counter()], [15, Counter({0: 1})], [30, Counter({0: 2})], [50, Counter({1: 1})], [65, Counter({0: 1, 1: 1})], [80, Counter({0: 2, 1: 1})], [95, Counter({0: 3, 1: 1})]]\n[[0, Counter()], [15, Counter({0: 1})], [30, Counter({0: 2})], [50, Counter({1: 1})], [65, Counter({0: 1, 1: 1})], [80, Counter({0: 2, 1: 1})], [95, Counter({0: 3, 1: 1})]]\n95"}},"/tutorial/algorithm/category/dynamic-programing/problem-set/1":{"title":"入门","data":{"":"从递推式直接写状态转移+动态规划初步总结\n自行推导表达式\n入门\n爬楼梯\n路径题\n\n\n进阶\n面积题\n背包问题\n编辑距离\n回文串\n杂项\n\n\n\n\n算法优化\n优化状态公式\n1937. 扣分后的最大得分\n背包问题常数优化\n\n\n压缩空间复杂度"}},"/tutorial/algorithm/category/dynamic-programing/problem-set/2":{"title":"回文串","data":{"":"","5-最长回文子串#5. 最长回文子串":"","动态规划解法#动态规划解法":"复杂度 $O(n^2)$，令 dp[i][j] 表示 s[i:j+1] 是否是回文子串，则：\ndp[i][i] = True\nj-i == 1时，dp[i][j] = s[i] == s[j]\nj-1 > 1 且 s[i] == s[j] 时 dp[i][j] = dp[i+1][j-1]\n\n当 dp[i][j] == True 时，更新最长回文子串。因为状态转移函数是 dp[i][j] = dp[i+1][j-1]，所以要求第一层 i 循环是逆序遍历\nclass Solution:\ndef longestPalindrome(self, s: str) -> str:\ndp = [[False]*len(s) for _ in range(len(s))]\nmax_s = ''\n\nfor i in reversed(range(len(s))):\nfor j in range(i,len(s)):\nif i == j:\ndp[i][j] = True\nelif j-i == 1:\ndp[i][j] = s[j] == s[i]\nelif s[j] == s[i]:\ndp[i][j] = dp[i+1][j-1]\n\nif dp[i][j]:\nmax_s = max(s[i:j+1],max_s,key=len)\nreturn max_s\n压缩条件\nclass Solution:\ndef longestPalindrome(self, s: str) -> str:\ndp = [[False]*len(s) for _ in range(len(s))]\nmax_s = ''\n\nfor i in reversed(range(len(s))):\nfor j in range(i,len(s)):\nif (i== j) or (s[i] == s[j] and (j-i == 1 or dp[i+1][j-1])):\ndp[i][j] = True\nmax_s = max(s[i:j+1],max_s,key=len)\n\nreturn max_s\n压缩空间\nclass Solution:\ndef longestPalindrome(self, s: str) -> str:\n\nmax_s = ''\n\nf = [False]*len(s)\nfor i in reversed(range(len(s))):\ndp = [False]*len(s)\nfor j in range(i,len(s)):\nif (i== j) or (s[i] == s[j] and (j-i == 1 or f[j-1])):\ndp[j] = True\nmax_s = max(s[i:j+1],max_s,key=len)\nf = dp\nreturn max_s\n647. 回文子串 也可以顺便捞走","647-回文子串#647. 回文子串":"class Solution:\ndef countSubstrings(self, s: str) -> int:\nans = 0\n\nf = [False]*len(s)\nfor i in reversed(range(len(s))):\ndp = [False]*len(s)\nfor j in range(i,len(s)):\nif (i== j) or (s[i] == s[j] and (j-i == 1 or f[j-1])):\ndp[j] = True\nans += 1\nf = dp\n\nreturn ans","中心扩展法#中心扩展法":"中心扩展法是枚举每一个可能的回文中心，对每个回文中心，用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。可以假设字符串中间有间隙，则 n 个字符共有 2n-1 个回文中心（n 个奇数中心，n-1个偶数中心）\na#b#c#b#c\nn=5 时，共有 2n-1 个回文中心\n可以分两遍遍历，第一遍奇数中心，第二遍偶数中心\nclass Solution:\ndef countSubstrings(self, s: str) -> int:\nans = 0\nn = len(s)\nfor i in range(n):\n# 奇数中心，n次\nl = r = i\nwhile l>=0 and r<len(s) and s[l] == s[r]:\nl-=1\nr+=1\nans += 1\n# 偶数中心\nl=i\nr=i+1 # 根据边界条件会少遍历一遍，即 n-1\nwhile l>=0 and r<len(s) and s[l] == s[r]:\nl-=1\nr+=1\nans +=1\n\nreturn ans\n当合并两次遍历时，可以通过找规律发现 l 和 r 对应 i 的值：\nclass Solution:\ndef countSubstrings(self, s: str) -> int:\nans = 0\nn = len(s)\nfor i in range(2*n-1):\nl = i // 2\nr = i // 2 + i % 2\nwhile l>=0 and r<len(s) and s[l] == s[r]:\nl-=1\nr+=1\nans += 1\n\nreturn ans","manacher-算法#Manacher 算法":"Manacher 的思想基于中心扩展法。假设已得到一个回文子串 s,回文中心为 i，则在该回文中心右侧的下标 j(j>i)，可以复用对称侧的信息，避免直接以 j 为中心进行扩展，这是 Manacher 算法的核心思想，从而实现了近似一遍遍历的复杂度。\n... c b c b c b\n... 1 3 5\n3(该中心的回文长度至少为 3)\n|___|\n|_______|\n历史能到达的最长回文子串\n算法在实现过程中维护了历史遍历中回文子串能到达的最右边界下标 jr 和该最右边界对应的回文子串的回文中心 j，此时，对于当前遍历下标 i：\n如果 i > jr，说明历史信息不可用，此时仍然按中心扩展法的思路处理\n如果 i <= jr，此时 j 是 jr 对应的回文中心，假设 il 是以 j 为中心 i 的左侧对称点，因为 i+il == 2*j，可得 il = 2*j-i，此时：\ndp[il] 可能大于 dp[j]，因为更新原则，此时 il+dp[il] < j+dp[j] and il < j，此时初始化 dp[i] 不能按照 dp[il] 的值初始化，因为可能会无效，因此可以初始化 dp[i] = rj-i（i 到子串边界的长度）\n否则，dp[i] = dp[il]\n\n\n最后，对于任意长度为 n 的回文串，保证中心不变的情况下，一共可以得到 (n+1)//2 个回文子串。\n在本题的处理中，dp[i] 存储的是最大回文半径，但因为字符串之间都插入了 #，按照下面两个推论，用 ans += (dp[i]+1)//2 更新即可\ns[i] == # 表示回文串长度是偶数，回文子串数量为 dp[i]//2 == (dp[i]+1)//2\ns[i] != # 表示回文串长度是奇数，回文子串数量为 (dp[i]+1)//2 == dp[i]//2+1\n\n\n\n\n\nn=5, n//2=2\nabcba\nbcb\nc\n\nn=4, n//2=2\nabba\nbb\n\nclass Solution:\ndef countSubstrings(self, s: str) -> int:\ns = ''.join(['$#', '#'.join(s), '#!'])\nn = len(s)\ndp = [0] * n\n\n# jr: 回文子串能到达的最右侧下标\n# j: jr 对应的回文子串的回文中心\nj = jr = 0\nans = 0\nfor i in range(2, n - 2):\n# i 被包含在当前最大回文子串内(right与当前点的距离, i关于j对称的点的f值)，不被包含(0)\n# 这里将 right−i 和 f[对称点] 取小，是先要保证这个回文串在当前最大回文串内。\ndp[i] = min(jr - i, dp[2 * j - i]) if i <= jr else 0\nwhile s[i + dp[i] + 1] == s[i - dp[i] - 1]:\ndp[i] += 1\n\nif i + dp[i] > jr:\nj = i\njr = i + dp[i]\n\nans += (dp[i] + 1) // 2\n\nreturn ans\n具体的实现思路：\n将偶数中心通过在字符间（包括两边）添加违禁字符 # 的方式处理成奇数中心\n将 dp[i] 定义为以 i 为奇数中心的最大回文半径，dp[i]-1 为以 i 为中心的真实的回文长度（如下图所示）\n为了边界判断，在两侧再添加 $ 和 ^ 保证两边字符不等\n\n\n$ # c # b # c # b # c # c # d # e # ^\n0 0 1 0 3 0 5 0 3 0 1 2 1 0 1 0 1 0 0\n\nclass Solution:\ndef countSubstrings(self, s: str) -> int:\ns = ''.join(['$#', '#'.join(s), '#!'])\nn = len(s)\ndp = [0] * n\n\n# jr: 回文子串能到达的最右侧下标\n# j: jr 对应的回文子串的回文中心\nj = jr = 0\nans = 0\nfor i in range(2, n - 2):\n# i 被包含在当前最大回文子串内(right与当前点的距离, i关于j对称的点的f值)，不被包含(0)\n# 这里将 right−i 和 f[对称点] 取小，是先要保证这个回文串在当前最大回文串内。\ndp[i] = min(jr - i, dp[2 * j - i]) if i <= jr else 0\nwhile s[i + dp[i] + 1] == s[i - dp[i] - 1]:\ndp[i] += 1\n\nif i + dp[i] > jr:\nj = i\njr = i + dp[i]\n\nans += (dp[i] + 1) // 2\n\nreturn ans","6236-不重叠回文子字符串的最大数目#6236. 不重叠回文子字符串的最大数目":"主要逻辑：\n对每个回文中心，用中心扩展法（或 Manacher 法）得到回文子串的左右边界为 l,r，对每个 r-l+1 >= k （符合题目要求）的子串，用贪心算法更新最大数量\n令 f[i] 为到 s[:i] 的最大数目，则 f[r] = max(f[r],f[l-1]+1)，f[i] = max(f[i-1],f[i])\n\n\nclass Solution:\ndef maxPalindromes(self, s: str, k: int) -> int:\nn = len(s)\nf = [0] * (n)\nfor i in range(n):\n# 初始化，不需要边界判断（f[-1] == 0）\nf[i] = max(f[i - 1], f[i])\n\n# 奇数长子串\nl = r = i\nwhile l>=0 and r<n and s[l] == s[r]:\n# 贪心判断，不需要更长的\nif r-l+1 >= k:\nf[r] = max(f[l-1]+1,f[r])\nbreak\nl -= 1\nr += 1\n\n# 偶数长子串\nl = i\nr = i+1\nwhile l>=0 and r<n and s[l] == s[r]:\nif r-l+1 >= k:\nf[r] = max(f[l-1]+1,f[r])\nbreak\nl-=1\nr+=1\n\nreturn f[-1]\n用 Manacher 优化时，需要两个数组，一个用于求最长子串长度（算法要求），一个用于求最大数量（题目要求）。需要注意s[i] == '#' 时的 l,r 的取值\n边界处理问题"}},"/tutorial/algorithm/category/dynamic-programing/problem-set/3":{"title":"背包","data":{"":"本文为背包问题专项，主要参考资料是背包九讲，根据自己的理解分了三节，分别是：\n背包问题入门：介绍背包问题状态转移函数的推导和理解\n背包问题拓展：介绍背包问题中一些其他的求解问题\n背包问题优化：针对背包问题时间复杂度和空间复杂度的优化\n背包问题转化：其他能转换为背包问题的 LeetCode 题解\n\n标 * 的小节暂定为超纲，近期事务繁忙，暂不做研究。给定一个背包重量上限 limit，给定n种物品的价值 value[n] 及其对应重量 weight[n]，希望在重量约束下使得物品价值最大化。","0-1-背包#0-1 背包":"每种物品只有一个，可以选择放入或者不放。此时状态转移函数较简单，对每个物品分拿或者不拿，且拿不拿当前物品可以达到的最大价值可以由之前物品来决定，此时：\n拿：dp[i][j] = dp[i-1][j-weight[i]] + value[i] （需要容量有效，即 j-weight[i] >= 0）\n不拿：dp[i][j] = dp[i-1][j]\n\n\nclass Solution:\ndef packProblem1(self, weight: List[int], value: List[int], limit: int) -> int:\ndp = [[0] * (limit + 1) for _ in range(len(weight))]\n\n# dp[N+1][W+1]\n# dp[i][j] 表示第 i 个物品和容量为 j 的最大值\n# dp[0][:] = 0\n# dp[:][0] = 0\n\nfor i in range(len(weight)):  # 对第 i 个物品\nfor j in range(limit + 1):  # 容量限制是 j 时, range(limit+1) 的最后一个循环 j = limit\ndp[i][j] = max(\ndp[i - 1][j],  # 不拿这个物品\n(dp[i - 1][j - weight[i]] + value[i]) if j - weight[i] >= 0 else 0  # 拿这个物品\n)\n\nreturn dp[-1][-1]  # dp[N-1][W]\n以 weight=[1, 3, 4], value=[15, 20, 30], limit=4 为例，算法运行过程中 dp 的更新过程为：\n# i=0\n#0   0   0   0\n#|--↓|--↓|--↓|--↓ # 是从 i-1 的空间取\n[0, 15, 15, 15, 15]\n\n# i=1\n#   |-----------↓ #\n#|----------↓ #\n#↓  ↓   ↓\n[0, 15, 15, 20, 35]\n\n# i=2\n#↓  ↓   ↓   ↓   ↓\n[0, 15, 15, 20, 35]\n# 没有取第三个物品","完全背包#完全背包":"每种物品有无限多个，即一个物品可以重复拿，会发现此时只需要把拿的状态转移函数从 dp[i-1][j-weight[i]] + value[i] 改为dp[i][j-weight[i]] + value[i]稍加修改即可，此时：\n拿：dp[i][j] = dp[i][j-weight[i]] + value[i] （需要容量有效，即 j-weight[i] >= 0）\n不拿：dp[i][j] = dp[i-1][j]\n\n\nclass Solution:\ndef packProblem2(self, weight: List[int], value: List[int], limit: int) -> int:\ndp = [[0] * (limit + 1) for _ in range(len(weight))]\n\nfor i in range(len(weight)):  # 对第 i 个物品\nfor j in range(limit + 1):  # 容量限制是 j 时, range(limit+1) 的最后一个循环 j = limit\ndp[i][j] = max(\ndp[i - 1][j],  # 不拿这个物品\n(dp[i][j - weight[i]] + value[i]) if j - weight[i] >= 0 else 0  # 拿这个物品\n)\nreturn dp[-1][-1]  # dp[N][W]\n以 weight=[1, 3, 4], value=[15, 50, 30], limit=6 为例，算法运行过程中 dp 的更新过程为：\n# ↓ 表示 不拿， |__↑ 表示拿，\n\n# i = 0\n[0, 15, 30, 45, 60, 75, 90]\n#|__↑|__↑|__↑|__↑|__↑|__↑\n#       不断的重复拿\n\n# i = 1\n#↓  ↓   ↓\n[0, 15, 30, 50, 65, 80, 100]\n#\n#|__________↑ # 拿第一个\n#    |___________↑\n#        |___________↑\n#            |___________↑ # 拿了第二个\n\n# i = 2\n#↓  ↓   ↓   ↓   ↓   ↓   ↓\n[0, 15, 30, 50, 65, 80, 100]\n#     一直没有拿第三个\n和 01 背包的过程对比，可以用来理解 i-1 到 i 的过程的本质。","多重背包#多重背包":"介于多重背包和完全背包之间，此时每个物品的个数是有限的。可以理解为 01 背包和完全背包是多重背包的特殊形式，多重背包是 01 和完全的通解。\n完全背包中，物品也可以拥有上限数量，只需要令 count[i] = limit//weight[i] 即可\n作为通解，复杂度在不额外引入优化数据结构（九讲中提到的单调队列）的情况下，没有办法达到 $O(NW)$，最多达到 $O(O(W\\sum^N_i(log_2K_i)))$和完全背包不同，多重背包中的物品是有限的，因此第 i 个物品可以被展开为 count[i] 个等价值等重量的物品，从而将问题转化为 01 背包问题：\nclass Solution:\ndef packProblem3(self, weight: List[int], value: List[int], count: List[int], limit: int) -> int:\n# 展开物品\nfor i in range(len(count)):\nfor _ in range(count[i]): # 展开\nweight.append(weight[i])\nvalue.append(value[i])\n\n# 01 背包\nreturn self.packProblem1(weight, value, limit)\n这种展开也可以理解为，对第 i 个物品，决定拿 k 个还是不拿 k 个，同样也是 01 背包的问题：\nclass Solution:\ndef packProblem3(self, weight: List[int], value: List[int], count: List[int], limit: int) -> int:\ndp = [[0] * (limit + 1) for _ in range(len(weight))]\n\nfor i in range(len(weight)):  # 对第 i 个物品\nfor j in range(limit + 1):  # 容量限制是 j 时, range(limit+1) 的最后一个循环 j = limit\nfor k in range(count[i] + 1): # 第 i 个物品一次拿 k 个拿不拿？\nnweight = j - k * weight[i]  # 容量 j 时一次需要拿 k 个物品还剩的容量\nif nweight < 0:\nbreak\ndp[i][j] = max(\ndp[i - 1][j],  # 不拿这个物品\n(dp[i - 1][nweight] + k * value[i]) if nweight >= 0 else 0  # 拿 k 个 i 物品\n)\nreturn dp[-1][-1]  # dp[N-1][W]\n该算法复杂度为 $O(W\\sum^{N}_{i}C_i)$，其中 $C_i$ 的数量会显著影响到算法开销。","对数级优化#对数级优化":"在展开物品时，令 k = limit // weight[i]，用二进制表示 k，则二进制的位数 kb 为 $log_2(k)$，令 kb 二进制串中第 j 位的物品的价值 value_k[j] = value[i]*2^j，重量 weight_k[j] = weight[i]*2^j。此时对二进制位的组合可以模拟所有 k 个物品的选择情况，且二进制位数 kb << k，可以实现开销更小的展开，即开头所说的最优复杂度。\nclass Solution:\ndef packProblem3(self, weight: List[int], value: List[int], count: List[int], limit: int) -> int:\nfor i in range(len(count)):\nk = min(limit // weight[i], count[i])\nj = 1\nwhile j <= k:\nweight.append(weight[i] * j)\nvalue.append(value[i] * j)\nj *= 2\n\n# 01 背包\nreturn self.packProblem1(weight, value, limit)","对数级展开过程和背包过程结合#对数级展开过程和背包过程结合":"当 count[i] * weight[i] > limit 时，第 i 个物品可以看成是完全背包中的情况（不可能不够用）；当 count[i] * weight[i] <= limit 时，可以按照对数级优化进行二进制展开。这两种情况可以合并在一起，从而省略了对原数组的操作\nclass Solution:\ndef packProblem3(self, weight: List[int], value: List[int], count: List[int], limit: int) -> int:\ndp = [[0] * (limit + 1) for _ in range(len(weight))]\n\nfor i in range(len(weight)):  # 对第 i 个物品\nfor j in range(limit + 1):  # 容量限制是 j 时, range(limit+1) 的最后一个循环 j = limit\nif count[i] * weight[i] >= limit:\n# 完全背包\ndp[i][j] = max(\ndp[i - 1][j],  # 不拿\ndp[i][j - weight[i]] + value[i] if j - weight[i] >= 0 else 0  # 拿\n)\nelse:\n# 01 背包，分 log(count[i]) 次选择\nk = 1  # k = 2^b\nwhile k < count[i]:\ndp[i][j] = max(\ndp[i - 1][j],  # 不拿\ndp[i - 1][j - weight[i] * k] + value[i] * k if j - weight[i] * k >= 0 else 0\n)\nk *= 2\n\nreturn dp[-1][-1]  # dp[N-1][W]\n该代码可以通用与混合背包问题（九讲第四讲）。","分组背包#分组背包":"分组背包问题中，物品被分作 N 个组，每组中的物品互相冲突。该题目可以看成是 01 背包的变种，题目由每个物品拿或不拿变成了每个组拿或不拿，拿的话拿哪个物品，所以每次比较第 k 组的第 i 个物品时，要比较三个状态：\ndp[k-1][j] ：不拿第 k 组的物品\ndp[k][j] ：拿第 k 组之前的物品\ndp[k-1][j-weight[i]]+value[i]：拿新物品\n\n\nclass Solution:\ndef packProblem4(self, weight: List[int], value: List[int], group: List[List[int]], limit: int) -> int:\ndp = [[0] * (limit + 1) for _ in range(len(group))]\n\nfor k, g in enumerate(group):\nfor j in range(limit + 1):\nfor i in g:  # g 组的第 i 个物品\ndp[k][j] = max(\ndp[k - 1][j],  # 第k 组什么都不拿\ndp[k][j],  # 保持原来选择的物品不变\ndp[k-1][j - weight[i]] + value[i] if j - weight[i] >= 0 else 0,  # 拿第 k 组第 i 个物品\n)\n\nreturn dp[-1][-1]  # dp[N-1][W]","二维背包#二维背包":"[ ]","依赖背包#依赖背包*":"","泛化背包#泛化背包*":"","卡牌游戏能达到的最大攻击力#卡牌游戏能达到的最大攻击力":"一个卡牌游戏，游戏中初始攻击力为 1，有两种卡牌，使用祝福每次攻击力 + 1，使用血怒让当前攻击力减半（向下取整），但让下次祝福的攻击力增益多 1 点。现在，按顺序给定一个卡牌序列，序列里 0 表示祝福，1 表示血怒。对每张卡牌可以选择是否使用。求最终能达到的最大攻击力。序列长度在 [1,10000]。令 mem[j] 为 i 价值时存储的最大攻击力数值，每个卡牌遍历更新一遍 mem。复杂度 $O(N^2)$\nclass Solution:\ndef packProblemGeneral(self, nums: List[int]):\nn = len(nums)\nmem = defaultdict(int)\nmem[0] = 1\nans = 0\nfor i in range(n):\nfor k, v in list(mem.items()):\nif nums[i] == 0:\nmem[k + v] = max(mem[k + v], v)\nans = max(k + v, ans)\nelse:\nmem[k // 2] = max(mem[k // 2], v + 1)\nreturn ans\n\n# m = [1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1]\n# print(Solution().packProblemGeneral(m))\n一些背包问题的变种","恰好装满#恰好装满":"[ ]","输出方案#输出方案":"[ ]","输出字典序最小的最优方案#输出字典序最小的最优方案":"[ ]","方案总数#方案总数":"[ ]","最优方案总数#最优方案总数":"[ ]","第-k-优解次优解#第 K 优解、次优解":"[ ]","空间复杂度优化#空间复杂度优化":"背包问题的初始算法空间复杂度为 $O(NW)$，一般通过观察状态转移公式或算法代码可以将初始分配空间进行压缩为$O(W)$，这里 W 是背包容量 limit。","01-背包#01 背包":"因为 dp[i][j] 依赖于 dp[i-1][j] 和 dp[i-1][j - weight[i]] ，即对 f[j] 和 f[j - weight[i] < j] 的要求是上一次外循环的，所以可以通过逆序更新 j 到 dp[i][j] 节省 dp[i-1] 的数组空间。\nclass Solution:\ndef packProblem1(self, weight: List[int], value: List[int], limit: int) -> int:\ndp = [0] * (limit + 1)\n\nfor i in range(len(weight)):  # 对第 i 个物品\nfor j in reversed(range(limit + 1)):  # 容量限制是 j 时, range(limit+1) 的最后一个循环 j = limit\ndp[j] = max(\ndp[j],  # 不拿这个物品\n(dp[j - weight[i]] + value[i]) if j - weight[i] >= 0 else 0  # 拿这个物品\n)\n\nreturn dp[-1]  # dp[N-1][W]","完全背包-1#完全背包":"因为 dp[i][j] 依赖于上一外循环的 dp[i-1][j] 和当前循环的 dp[i][j - weight[i]] ，上一循环的 dp[i-1][j] 可以直接被压缩，当前循环的 dp[i][j - weight[i]] 要求 j 顺序遍历\nclass Solution:\ndef packProblem2(self, weight: List[int], value: List[int], limit: int) -> int:\ndp = [0] * (limit + 1)\n\nfor i in range(len(weight)):  # 对第 i 个物品\nfor j in range(limit + 1):  # 容量限制是 j 时, range(limit+1) 的最后一个循环 j = limit\ndp[i][j] = max(\ndp[j],  # 不拿这个物品\n(dp[j - weight[i]] + value[i]) if j - weight[i] >= 0 else 0  # 拿这个物品\n)\nreturn dp[-1]  # dp[N][W]","多重背包和分组背包#多重背包和分组背包":"根据上面的思路，会发现多重背包同时依赖了 j 两侧的状态，没有办法直接压缩。但注意到完全背包的分支可以转换到 01 背包，因此在转换后，可以按照 01 背包的方式压缩。\nclass Solution:\ndef packProblem3(self, weight: List[int], value: List[int], count: List[int], limit: int) -> int:\ndp = [0] * (limit + 1)\n\nfor i in range(len(weight)):  # 对第 i 个物品\nfor j in reversed(range(limit + 1)):  # 容量限制是 j 时, range(limit+1) 的最后一个循环 j = limit\nmax_v = min(count[i], limit//weight[i])\n# 01 背包，分 log(count[i]) 次选择\nk = 1  # k = 2^b\nwhile k < max_v:\ndp[i][j] = max(\ndp[j],  # 不拿\ndp[j - weight[i] * k] + value[i] * k if j - weight[i] * k >= 0 else 0\n)\nk *= 2\n\nreturn dp[-1]  # dp[N-1][W]\n分组背包的优化思路和 01 背包完全相同，依赖的是上一次循环的左侧，所以是逆序遍历。唯一注意的是之前代码中的 max(dp[k-1][j], dp[k][j], ...) 合并为 max(dp[j], ...) 的过程没有问题，不会导致错误比较。\nclass Solution:\ndef packProblem4(self, weight: List[int], value: List[int], group: List[List[int]], limit: int) -> int:\ndp = [0] * (limit + 1)\n\nfor k, g in enumerate(group):\nfor j in reversed(range(limit + 1)):\nfor i in g:  # g 组的第 i 个物品\ndp[j] = max(\ndp[j],  # 第 k 组什么都不拿\ndp[j - weight[i]] + value[i] if j - weight[i] >= 0 else 0,  # 拿第 k 组第 i 个物品\n)\n\nreturn dp[-1]  # dp[N-1][W]","时间复杂度优化#时间复杂度优化":"","内外循环置换#内外循环置换":"在背包容量范围内物品的最大价值问题也可以转化为最大价值问题，找到某个价值下的最小重量。此时复杂度由 $O(NW)$ 转换为 $O(NV)$。和重量不同，不同物品组合出的价值数量是有限的，此时用 dict 会更好。在最差情况下，算法退化为 $O(2^N)$\nclass Solution:\ndef packProblem1(self, weight: List[int], value: List[int], limit: int) -> int:\ndp = defaultdict(lambda: defaultdict(lambda: float('inf')))\n\n# trick，表示什么都不拿\ndp[-1][0] = 0\n\nmax_v = 0\nfor i in range(len(value)):  # 对第 i 个物品\nfor k, w in dp[i - 1].items():  # 遍历前 i-1 能达到的所有可能的价值\ndp[i][k] = min(w, dp[i][k])  # 不拿\nmax_v = max(k, max_v)\nif w + weight[i] <= limit:  # 拿，注意检查重量边界\ndp[i][k + value[i]] = min(dp[i][k + value[i]], w + weight[i])\nmax_v = max(k + value[i], max_v)\n\nreturn max_v\n\n适用场景 & 使用是否正确？","常数级优化#常数级优化*":"在《九讲》中，提到了针对 limit 层循环的一个常数级优化。以 01 背包问题为例。\n在有空间复杂度优化的情况下，遍历到第 i 个物品时，对 limit 的内循环可以省略 j = [0,weight[i])，因为此时 j - weight[i] < 0，dp[i][j] = dp[i-1][j]。\n第 n-1 个物品（最后一个物品）的最后一个循环（j==limit）依赖的拿的状态是 dp[n-2][limit-weight[n-1]]，要得到第 dp[n-2][limit-weight[n-1]]（算法的循环执行到 i=n-2, j=limit-weight[n-1]） 则要求 dp[i-1][j-weight[i]] 即 dp[n-3][limit-weight[n-1]-weight[n-2]]...推导可得第 i 个物品至少要求得的状态是 dp[i][limit-sum(weight[j+1:])]\n因为不拿的最终状态是 dp[n-1][limit] ，所以最终第 i 个物品的内循环次数是 range(b, limit+1)，其中 b = max(weight[i], limit - sum(weight[i+1:]))，即上面两种可以省略的情况取并集，表现为 max 操作。\n\n\nclass Solution:\ndef packProblem1(self, weight: List[int], value: List[int], limit: int) -> int:\ndp = [0] * (limit + 1)\n\nfor i in range(len(weight)):  # 对第 i 个物品\nb = max(weight[i], limit - sum(weight[i+1:]))\nfor j in range(b, limit + 1):  # 容量限制是 j 时, range(limit+1) 的最后一个循环 j = limit\ndp[j] = max(\ndp[j],  # 不拿这个物品\n(dp[j - weight[i]] + value[i]) if j - weight[i] >= 0 else 0  # 拿这个物品\n)\n\nreturn dp[-1][-1]  # dp[N-1][W]\n\n原文提到，该优化在 limit 较大时作用较显著。","单调队列优化#单调队列优化*":"单调队列优化","搜索剪枝#搜索剪枝":"搜索剪枝","01-背包-1#01 背包":"","1049-最后一块石头的重量-ii#1049. 最后一块石头的重量 II":"","879-盈利计划#879. 盈利计划":"","474-一和零#474. 一和零":"","494-目标和#494. 目标和":"","322-零钱兑换#322. 零钱兑换":"","416-分割等和子集#416. 分割等和子集":"dd 背包问题九讲\nhttps://blog.bill.moe/DP-backpack-notes/\nLeetCode 背包问题整理\nhttps://blog.csdn.net/No_Game_No_Life_/article/details/117753452\nhttps://zhuanlan.zhihu.com/p/93857890"}},"/tutorial/algorithm/category/dynamic-programing/problem-set":{"title":"Index","data":{"":""}},"/tutorial/algorithm/category/graph/0":{"title":"二分图","data":{"":"","785-判断二分图#785. 判断二分图":"二分图的特质是可以按遍历时奇数深度和偶数深度来染色，因此可以使用并查集, 和深搜、广搜三种方法来判断。广度优先遍历：\nclass Solution:\ndef isBipartite(self, graph: List[List[int]]) -> bool:\ncolors = [-1] * len(graph)\nqueue = [(0,0)]\n\nfor i in range(len(colors)):\nwhile queue: # 每次广度优先遍历一个结点\nu,color = queue.pop(0)\nif colors[u] >= 0:\nif colors[u] != color:\nreturn False\ncontinue\n\ncolors[u] = color\nncolor = (color + 1) % 2\nfor neighbor in graph[u]:\nif colors[neighbor] >= 0 and colors[neighbor] != ncolor:\nreturn False\n\nqueue.append((neighbor,ncolor))\n\nif colors[i] < 0:\nqueue.append((i,0))\n\nreturn True\n\n可以优化为只用一个 visited 结点解决\n深度优先遍历：\n\n\n\n并查集：当且仅当图是二分图时，节点和该节点的邻接结点不在同一个集合中。\nclass Solution:\ndef isBipartite(self, graph: List[List[int]]) -> bool:\narr = list(range(len(graph)))\n\ndef merge(i,j):\narr[find(i)] = find(j)\n\ndef find(i):\nif arr[i] != i:\narr[i] = find(arr[i])\nreturn arr[i]\n\nfor i in range(len(graph)):\nfor neighbor in graph[i]:\nif find(i) == find(neighbor): # 结点和邻接矩阵在一个集合中\nreturn False\nmerge(graph[i][0],neighbor) # 将该结点的邻接结点放到同一个集合中\nreturn True"}},"/tutorial/algorithm/category/graph/1":{"title":"最短路","data":{"":"floyd 算法，输入是邻接矩阵，输出是同 shape 的二维数组 graph，graph[i][j] 表示从 i 到 j 的最短路径。算法复杂度是 $O(n^3)$","743-网络延迟时间#743. 网络延迟时间":"class Solution:\ndef networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\ngraph = [[float('inf')] * n for i in range(n)]\ngraph[k-1][k-1] = 0\nfor u,v,w in times:\ngraph[u-1][v-1] = w\n\nans = 0\n\nfor m in range(n):\nfor i in range(n):\nfor j in range(n):\ngraph[i][j] = min(graph[i][j],graph[i][m]+graph[m][j])\n\nfor i in range(n):\nif graph[k-1][i] == float('inf'):\nreturn -1\n\nans=max(ans,graph[k-1][i])\n\nreturn ans\nDisjKstra 算法是单源最短路径算法，求的是一个源到其他所有节点的最短路，输入是邻接矩阵，输出一维数组 dist，dist[i] 表示 src 到 i 的最短路径，算法复杂度可以通过优化到 $O(m\\log m)$","743-网络延迟时间-1#743. 网络延迟时间":"class Solution:\ndef networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\ng = [[float('inf')] * n for _ in range(n)]\nfor x, y, time in times:\ng[x - 1][y - 1] = time\n\ndist = [float('inf')] * n\ndist[k - 1] = 0\nused = [False] * n\n\nfor _ in range(n):\nx = -1\n\n# 从 dist 中选一个最小的作为 x(tgt)\nfor y, u in enumerate(used):\nif not u and (x == -1 or dist[y] < dist[x]):\nx = y\n\nused[x] = True # 标记 x 已经选择\n\n#\nfor y, time in enumerate(g[x]):\ndist[y] = min(\ndist[y],  # 保持原来的不变\ndist[x] + time # graph[src][x] + graph[x][y]\n)\n\nans = max(dist)\nreturn ans if ans < float('inf') else -1\n堆优化版本\nclass Solution:\ndef networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\ng = [[] for _ in range(n)]\nfor x, y, time in times:\ng[x - 1].append((y - 1, time))\n\ndist = [float('inf')] * n\ndist[k - 1] = 0\nq = [(0, k - 1)]\n\nwhile q:\nxtime, x = heapq.heappop(q) # 从 dist 中选一个最小的作为 x(tgt)\n# 需要知道 xtime = dist[x]\n\nif dist[x] < xtime: # heap 提供了另外一条 graph[src][x] 的通路，但是并不比之前更新的最短通路 dist[x] 小，所以不需要再去遍历这一条 graph[src][x] 到其他 y 的路线，因为都不可能有 dist[x] 到 y 的路线短。\ncontinue\nfor y, time in g[x]: # 这里的 time 是从 x 到 y 的 time，不是上面 heap 出来的从 src 到 x 的 time\nd = xtime + time\nif (d) < dist[y]:\ndist[y] = d\nheapq.heappush(q, (d, y)) # dist 和堆是同步更新的，表现为下次从 dist 中选最小的\n\nans = max(dist)\nreturn ans if ans < float('inf') else -1\nBellman-Ford 是一种动态规划解单源最短路径的算法。定义 d(i,k) 为源点 s 到 i 最多经过 k 条边的最短距离\n初始化: d(i,1) = e[s,i]\n更新 n 次: for all (u,v): d(v,k)=min(d(v,k-1), d(u,k-1)+e[u,v])\n确认下能否压缩状态数组？好像顶多压成两行？\n\n适合输入为邻接表的数据。","787-k-站中转内最便宜的航班#787. K 站中转内最便宜的航班":"# f[i][dst] 表示第 i 步到 dst 的最短路径\n# f[0][src] = 0\n# f[0][!= src] = inf\n# f[1][src] = min(f[1-1][x]] + cost[x][src]])\nclass Solution:\ndef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\nf = [[float(\"inf\")] * n for _ in range(k + 2)]\nf[0][src] = 0\n\nfor t in range(1, k + 2):\nfor j, i, cost in flights:\nf[t][i] = min(f[t][i], f[t - 1][j] + cost)\n\nans = min(f[t][dst] for t in range(1, k + 2))\nreturn -1 if ans == float(\"inf\") else ans\nDisjKstra 实现（超时）\nclass Solution:\ndef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\ngraph = [[] for _ in range(n)]\nfor l,r,cost in flights:\ngraph[l].append((r,cost))\n\nq = [(0,0,src)]\n\nwhile q:\nxcost,f, x = heapq.heappop(q) # src -> x\nif f > k+1:\ncontinue\n\nif x == dst:\nreturn xcost\n\nfor y,cost in graph[x]: # x -> y\n# if xcost + cost < dist[y]: 该题不能维护 dist[y]，因为会丢失 k 次中转内的一些状态空间\nheapq.heappush(q,(xcost+cost,f+1,y))\n\nreturn -1","882-细分图中的可到达节点#882. 细分图中的可到达节点":"核心是单源最短路径，在遍历过程中，遍历到 0->i 时，更新 i->x 的最大剩余步数，即 maxMoves - dist[i]\nclass Solution:\ndef reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\ng = [[] for i in range(n)]\nremain = {}\n\nfor i,j,cnt in edges:\ng[i].append([j,cnt])\ng[j].append([i,cnt])\n\ndist = [float('inf')] * n\ndist[0] = 0\n\nq = [(0,0)]\n\nans = 0\nwhile q and q[0][0] <= maxMoves:\n# 选一个当前 0-x 距离最小的\n(cost,x) = heappop(q)\nif dist[x] < cost:\ncontinue\n\n# q 本质上最多每个结点遍历一遍\n# while 条件 q[0][0] <= maxMoves，保证了该节点有效可到达\nans += 1\n\n# 记录 x->y 时还剩下的最大步数\n# 到 x 的最大剩余步数\nremain[x] = max(maxMoves - cost,remain.get(x,0))\n\nfor j,cnt in g[x]:\nd = cost + cnt + 1\nif d < dist[j]:\ndist[j] = d\nheappush(q,(d, j))\n\n# 遍历获取，可以在遍历 q 时一步到位\n# for i in range(n):\n#     if dist[i] <= maxMoves:\n#         ans += 1\n\nfor i,j,cnt in edges:\nans += min(cnt, remain.get(j,0) + remain.get(i,0))\n\nreturn ans"}},"/tutorial/algorithm/category/graph/2":{"title":"生成树","data":{"":"每次从已有的选择集合的边连接中选择一条最小的加入","1584-连接所有点的最小费用#1584. 连接所有点的最小费用":"class Solution:\ndef minCostConnectPoints(self, points: List[List[int]]) -> int:\nn = len(points)\ngraph = []\n\ndef dist(i,j):\nreturn abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n\nfor i in range(n):\ngraph.append([(dist(i,j),i,j) for j in range(n)])\n\n\nvset = {0}\ncandi = []\nfor d in graph[0]:\nheapq.heappush(candi, d)\n\nans = 0\nwhile candi:\ndist,i,j = heapq.heappop(candi)\nif j in vset:\ncontinue\n\nif j not in vset:\nvset.add(j)\nfor d in graph[j]:\nheapq.heappush(candi,d)\n\nans += dist\n\nreturn ans\n通过并查集，每次选择不同集合中的两个点组成的边中最小的一条。复杂度是 $O(mlogm)$, m 是边的数量","1584-连接所有点的最小费用-1#1584. 连接所有点的最小费用":"class Solution:\ndef minCostConnectPoints(self, points: List[List[int]]) -> int:\nn = len(points)\ngraph = []\ndef dist(i,j):\nreturn abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n\n# 初始化过程，把所有边加入到候选集中\nfor i in range(n):\ngraph.extend([(dist(i,j),i,j) for j in range(i+1,n)])\n\n# 堆化候选集\nheapq.heapify(graph)\n\ndp = list(range(n))\ndef find(i):\nif dp[i] != i:\ndp[i] = find(dp[i])\nreturn dp[i]\n\ndef merge(i,j):\ndp[find(i)] = find(j)\n\nans = 0\n\nwhile graph:\n# 挑选不在同一个集合中的最短边\ndist,i,j = heapq.heappop(graph)\nif find(i) != find(j):\nmerge(i,j)\nans += dist\n\nreturn ans\n\n关于 Prim 和 Kruskal 算法的图示：https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html"}},"/tutorial/algorithm/category/graph":{"title":"Index","data":{"":""}},"/tutorial/algorithm/category/greedy/0":{"title":"中等","data":{"":"","134-加油站#134. 加油站":"需要浅做分析。从 start 出发，只可以走到 end，说明在 end 之前的油量都是正的。此时从任意 (start, end) 之间的站点出发，都无法通过 end，因为油量到 end 前时只会更少。\nclass Solution:\ndef canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\nstart = 0\nend = 0\n\nwhile start < len(gas):\nans = 0\nwhile True:\nans += gas[end]\nans -= cost[end]\nend = (end + 1) % len(gas) # 下一站的 index\n\nif ans < 0:\nif start < end:\nstart = end\nelse:\nreturn -1\nbreak\n\nif start == end:\nreturn start\n\nreturn -1","11-盛最多水的容器#11. 盛最多水的容器":"需要浅做分析。左右两侧双指针，每次将短边指针缩进，求过程中的最大面积。这一过程需要证明缩进时被剪枝的状态空间不存在最大面积。暴力解法是 O(N^2) 复杂度，即双指针遍历所有的 S(i,j) 取最大。当 i 是短边缩进时，需要证明 $S(i,j) S(i,1)~S(i,N) < S(i,j)$。因为短边为 i，且短边宽度比 (j-i) 更短，所以得证。通过不严谨的反证法速记：每次收缩一边，收缩短边后面积可能更大（虽然宽度减小，但是高度可能更高），收缩长边面积不可能更大（因为收缩长边宽度减小，高度仍然由短边决定）\n可参考该题题解\n\nclass Solution:\ndef maxArea(self, height: List[int]) -> int:\nmax_v = 0\nleft = 0\nright = len(height) - 1\n\nwhile left != right:\nmax_v = max(min(height[left],height[right]) * (right-left),max_v)\nif height[left] < height[right]:\nleft += 1\nelse:\nright -= 1\n\nreturn max_v"}},"/tutorial/algorithm/category/greedy/1":{"title":"简单","data":{"":"","122-买卖股票的最佳时机-ii#122. 买卖股票的最佳时机 II":"因为可以任意买卖，所以最优解就是任意上升序列的差值。\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nans = 0\nfor i in range(1,len(prices)):\nans += max(0,prices[i] - prices[i-1])\nreturn ans","55-跳跃游戏#55. 跳跃游戏":"最初的遍历想法是 $O(mn)$,m 是 nums 的平均长度。之后可以发现遍历时只需要维护遍历到当前台阶时可以到达的最远长度即可，如果当前台阶大于最远长度，则返回 False，否则遍历完一遍后就可以返回 True\nclass Solution:\ndef canJump(self, nums: List[int]) -> bool:\nmax_k = 0\nfor i in range(len(nums)):\nif i > max_k:\nreturn False\nif max_k >= len(nums) - 1: # 可选\nreturn True\n\nmax_k = max(max_k,i + nums[i])\n\nreturn True","45-跳跃游戏-ii#45. 跳跃游戏 II":"和 55. 跳跃游戏 类似，仍然是一遍遍历，关键是思考什么时候将步数 +1。假设跳的每一个台阶都是最优的（初始是在第 0 个台阶上），那么下一次选择在哪里跳的范围是在当前台阶上可以跳的全部范围 [i+1, i + nums[i]]。也就是说要在这一个范围内贪心的选一个能到达最远的台阶。\nclass Solution:\ndef jump(self, nums: List[int]) -> int:\nn = len(nums)\nmaxPos, end, step = 0, 0, 0\nfor i in range(n - 1):\nmaxPos = max(maxPos, i + nums[i])\nif i == end:\nend = maxPos\nstep += 1\nreturn step\n一个更容易理解的版本（直接模拟）：\nclass Solution:\ndef jump(self, nums: List[int]) -> int:\nn = len(nums)\nmaxJ, end, step = 0, 0, 0\n\ni = 0\nwhile i < n-1: # 还没跳到最后一个台阶\n# 当前台阶可以到达的最远的台阶\nend = i + nums[i]\n\n# 如果能直接跳到最后，那就直接跳\nif end >= n-1:\nstep += 1\nbreak\n\n# 在 i 能到达的范围内选择一个能跳的最远的台阶\nfor j in range(i+1,end+1):\nif maxJ + nums[maxJ] < j + nums[j]:\nmaxJ = j\n\n# 选好后跳到 maxJ\ni = maxJ\nstep += 1\n\nreturn step"}},"/tutorial/algorithm/category/greedy":{"title":"Index","data":{"":""}},"/tutorial/algorithm/category":{"title":"Index","data":{"":""}},"/tutorial/algorithm/category/linear/0":{"title":"优先级队列","data":{"":"优先级队列是一个完全二叉树，保证了所有的父节点均大于相应的子节点，此时根节点为所有元素的最大值。作为一个队列，相应的操作接口为 push/pop/top。push/pop 操作的复杂度均为 O(nlogn)，过程中核心算法是上升(lift_up)和下降(lift_down)。\nclass PHeap:\ndef __init__(self):\nself.lis = []\n\ndef lift_up(self, ci, j):\nwhile ci > j:\npi = (ci - 1) // 2\nif self.lis[ci][0] < self.lis[pi][0]:\nself.lis[ci], self.lis[pi] = self.lis[pi], self.lis[ci]\nelse:\nbreak\nci = pi\n\ndef lift_down(self, i):\nwhile i < len(self.lis):\nci = i * 2 + 1\nif ci >= len(self.lis):\nbreak\n\nif ci + 1 < len(self.lis) and self.lis[ci + 1][0] < self.lis[ci][0]:\nci += 1\n\nif self.lis[i][0] > self.lis[ci][0]:\nself.lis[ci], self.lis[i] = self.lis[i], self.lis[ci]\nelse:\nbreak\ni = ci\n\ndef push(self, item):\nself.lis.append(item)\nself.lift_up(len(self.lis) - 1, 0)\n\ndef pop(self, ):\nres = self.lis[0]\ntail = self.lis.pop()\n\nif len(self.lis):\nself.lis[0] = tail\nself.lift_down(0)\nreturn res\n\ndef top(self):\nif len(self.lis):\nreturn self.lis[0]\nelse:\nreturn None","23-合并-k-个升序链表#23. 合并 K 个升序链表":"class Solution:\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n# 全放在一起然后 sort， nlogn\n# 递归每次 nlogk\n# 优先级队列 nlogk\n\np = PHeap()\nfor lis in lists:\nif lis:\np.push((lis.val,lis))\n\ndummy = ListNode()\nhead = dummy\nwhile len(p.lis):\n_,lis = p.pop()\nhead.next = lis\nhead = lis\nlis = lis.next\nif lis:\np.push((lis.val,lis))\n\nreturn dummy.next\n\n简单子问题 21. 合并两个有序链表","4-寻找两个正序数组的中位数#4. 寻找两个正序数组的中位数":"非最优解法\n\nimport heapq\nfrom itertools import chain\nclass Solution:\ndef findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\nres = []\nfor i in chain(nums1,nums2):\nheapq.heappush(res,i)\n\nif len(res) == 0:\nreturn 0\n\nsize = len(nums1) + len(nums2)\n\nif size % 2 == 0:\nfor i in range(size//2 - 1):\nheapq.heappop(res)\na = heapq.heappop(res)\nb = heapq.heappop(res)\nreturn (a+b) / 2\nelse:\nfor i in range(size//2):\nheapq.heappop(res)\nprint(res)\nreturn heapq.heappop(res)","862-和至少为-k-的最短子数组#862. 和至少为 K 的最短子数组":"前缀和 + 贪心 + 优先级队列。一遍循环，更新前缀和，同时将每个前缀和及其下标插入到小根堆中。每个更新前缀和时，从优先级队列中判断栈顶元素是否符合并更新最小 i-i'，注意当 i-i' 是更小时，后续的循环中 i-i' 一定更大，所以弹出 i' 是有效的剪枝，不会丢失状态空间。在队列顶部的元素是值更小，下标不一定距离当前 i 更近，因此需要通过 while 循环取到最后。该题还可以通过双端队列实现 $O(N)$ 的复杂度。\nclass Solution:\ndef shortestSubarray(self, nums: List[int], k: int) -> int:\nans = 0\nqueue = []\n\n# 最小堆\nheapq.heappush(queue,(0,-1))\nmin_l = 1e6\nfor i in range(len(nums)):\nans += nums[i]\ntgt = ans - k\nwhile queue and tgt - queue[0][0] >= 0:\nmin_l = min(min_l,i-heapq.heappop(queue)[1])\nheapq.heappush(queue,(ans,i))\n\nif min_l == 1e6:\nreturn -1\nreturn min_l\n解释一下单调双端队列的思想。该过程是不断的维护一个前缀和的单调递增（第二个 while 循环）的双端队列。同时在遍历到当前的前缀和时，从左到右尝试是否存在符合要求 curSum - preSumArr[q[0]] >= k 的队列元素，如果有则尝试更新最小区间（第一个 while 循环）并弹出左侧元素。不会丢掉有效状态空间的原因：\n第一个循环弹出左侧元素，哪怕之后的前缀和跟弹出的元素也符合要求 curSum - preSumArr[index] >= k ，区间也只可能更大，所以第一个循环的弹出一定是有效的\n第二个循环弹出右侧元素，因为在之前已经遍历过第一个循环，所以该元素的左侧不存在区间更小的值（存在也已经在之前循环更新完了）；而当前遍历的元素之后也会插入到队列中，且满足 preSumArr[q[-1]] >= curSum，即使在后续遍历过程中，存在一个元素 curSum 使得 curSum - preSumArr[q[-1]] >= k，也至少要比当前的元素的区间大，所以弹出符合条件的队列右侧元素也一定是有效的。\n\n\nclass Solution:\ndef shortestSubarray(self, nums: List[int], k: int) -> int:\npreSumArr = [0]\nres = len(nums) + 1\nfor num in nums:\npreSumArr.append(preSumArr[-1] + num)\nq = deque()\nfor i, curSum in enumerate(preSumArr):\nwhile q and curSum - preSumArr[q[0]] >= k:\nres = min(res, i - q.popleft())\nwhile q and preSumArr[q[-1]] >= curSum:\nq.pop()\nq.append(i)\nreturn res if res < len(nums) + 1 else -1","2462-雇佣-k-位工人的总代价#2462. 雇佣 K 位工人的总代价":"class Solution:\ndef totalCost(self, costs: List[int], k: int, candidates: int) -> int:\nans, n = 0, len(costs)\nif candidates * 2 < n:\npre = costs[:candidates]\nheapify(pre)\nsuf = costs[-candidates:]\nheapify(suf)\ni, j = candidates, n - 1 - candidates\nwhile k and i <= j:\nif pre[0] <= suf[0]:\nans += heapreplace(pre, costs[i])\ni += 1\nelse:\nans += heapreplace(suf, costs[j])\nj -= 1\nk -= 1\ncosts = pre + suf\ncosts.sort()\nreturn ans + sum(costs[:k])","215-数组中的第-k-个最大元素#215. 数组中的第 K 个最大元素":"该题可以用快速选择、大根堆、小根堆来实现，其中，大根堆（O(nlogn)）比小根堆（O(nlogk)）的时间复杂度要大一些。大根堆实现\nclass Solution:\ndef findKthLargest(self, nums: List[int], k: int) -> int:\nnums = [-i for i in nums]\nheapify(nums)\nfor i in range(k):\nans = heappop(nums)\nreturn -ans\n小根堆实现\nclass Solution:\ndef findKthLargest(self, nums: List[int], k: int) -> int:\nres = []\nfor i in range(len(nums)):\nif len(res) < k:\nheappush(res,nums[i])\nelif nums[i] > res[0]:\nheapreplace(res,nums[i])\n\nreturn res[0]\n快速选择虽然复杂度是 $O(n)$，但是分治的常数时间似乎过大，导致过不了。","895-最大频率栈#895. 最大频率栈":"python 自带的 heapq 维护的是小根堆，维护成大根堆需要内部数值取反\nclass FreqStack:\ndef __init__(self):\nself.cnt = Counter()\nself.heap = []\nself.index = 0\n\ndef push(self, val: int) -> None:\nself.cnt[val] += 1\nheappush(self.heap, (-self.cnt[val],self.index,val))\nself.index -= 1\n\ndef pop(self) -> int:\ncnt,ind,val = heappop(self.heap)\nself.cnt[val] -= 1\nreturn val","6260-矩阵查询可获得的最大分数#6260. 矩阵查询可获得的最大分数":"class Solution:\ndef maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\nmem = Counter()\n\nn = len(grid)\nm = len(grid[0])\n\nvisited = [[0] * m for i in range(n)]\n\nq = [(grid[0][0],0,0)]\n\nlast = 0\nwhile q:\ncur, i, j = heappop(q)\nif visited[i][j] == 1:\ncontinue\n\nvisited[i][j] = 1\nlast = max(last, cur)\nmem[last] += 1\n\nfor x, y in sorted([(x, y) for x, y in [\n(i + 1, j),\n(i - 1, j),\n(i, j + 1),\n(i, j - 1),\n] if not (x < 0 or x >= n or y < 0 or y >= m)],\nkey=lambda x: grid[x[0]][x[1]]):\nheappush(q, (grid[x][y], x, y))\n\nsq = sorted(queries)\n\nsq_mem = {}\n\nans = 0\nfor k in sorted(mem.keys()):\nwhile sq and k >= sq[0]:\nsq_mem[sq.pop(0)] = ans\nans += mem[k]\n\nwhile sq:\nsq_mem[sq.pop(0)] = ans\n\nreturn [sq_mem[k] for k in queries]\n\nclass Solution:\ndef maxPoints(self, G: List[List[int]], Q: List[int], dirs4 = ((-1, 0), (1, 0), (0, -1), (0, 1))) -> List[int]:\nm, n, q = len(G), len(G[0]), [(G[0][0], 0, 0)]\nss, cur, res = [[False] * n for _ in range(m)], 0, [-1] * len(Q)\nss[0][0] = True\nfor idx, h in sorted(enumerate(Q), key=lambda t: t[1]):\nwhile q and q[0][0] < h:\ncur += 1\n_, x, y = heappop(q)\nfor u, v in dirs4:\ni, j = x + u, y + v\nif 0 <= i < m and 0 <= j < n and not ss[i][j]:\nss[i][j] = True\nheappush(q, (G[i][j], i, j))\nres[idx] = cur\nreturn res"}},"/tutorial/algorithm/category/linear/1":{"title":"前缀和","data":{"":"","#":"","1641-统计字典序元音字符串的数目#1641. 统计字典序元音字符串的数目":"找规律即可发现这道题可以用前缀和（其实算后缀和）来解决\n# 1+1+1+1+1\n# 5+4+3+2+1\n# (15) + (4+3+2+1) + (3+2+1) + (2+1) + (1)\n\nclass Solution:\ndef countVowelStrings(self, n: int) -> int:\ndp = [1] * 5\n\nfor i in range(n):\nfor j in reversed(range(4)):\ndp[j] = dp[j] + dp[j+1]\n\nreturn dp[0]"}},"/tutorial/algorithm/category/linear/2":{"title":"单调栈","data":{"":"https://blog.csdn.net/qq_17550379/article/details/86519771Leetcode 42Leetcode 496","503-下一个更大元素-ii#503. 下一个更大元素 II":"环结构 + 单调栈\nclass Solution:\ndef nextGreaterElements(self, nums: List[int]) -> List[int]:\nsize = len(nums)\ndp = [-1] * size\nstack = []\nfor i in range(size * 2):\ni = i % size\nnum = nums[i]\nwhile stack and nums[stack[-1]] < num:\nif stack[-1] < size:\ndp[stack[-1]] = num\nstack.pop()\nstack.append(i)\nreturn dp","739-每日温度#739. 每日温度":"class Solution:\ndef dailyTemperatures(self, temperatures: List[int]) -> List[int]:\ndp = [0] * len(temperatures)\n\nstack = []\nfor i in range(len(temperatures)):\ntemp = temperatures[i]\nwhile stack and temperatures[stack[-1]] < temp:\ndp[stack[-1]] = i - stack[-1]\nstack.pop()\nstack.append(i)\n\nreturn dp","84-柱状图中最大的矩形#84. 柱状图中最大的矩形":"暴力是遍历所有可能的矩形，矩形面积是长乘宽，宽度是 i-j+1，高度是遍历的时候动态得到的 ij 之间的最小高度。复杂度 $O(N^2)$\nclass Solution:\ndef largestRectangleArea(self, heights: List[int]) -> int:\nans = 0\nfor i in range(len(heights)):\nrh = heights[i]\nfor j in range(i,len(heights)):\nrh = min(rh,heights[j]) #求 j-i 的最小高度\nans = max(ans,rh * (j-i+1))\nreturn ans\n转换一下思路，改题本质上是对每一个柱，求出它能圈出的最大矩形的面积 area[i]，并返回 max(area) 的过程。这要求对每个 heights[i]，要找出 i 左侧第一个小于 heights[i] 的下标 left[i] 和右侧第一个小于 heights[i] 的下标 right[i]。最后发现，得到 left[i] 的过程是一个单调栈遍历的过程，栈内保存下标，遍历到 heights[i] 时，如果栈顶元素更高，则出栈，直到栈为空（表明到 heights[i] 是到 i 为止最小的）或者栈顶元素比 heights[i] 小（表明栈顶下标对应的 heights[j] 是左侧第一个小于 heights[i] 的）。该算法复杂度为 $O(N)$\nclass Solution:\ndef largestRectangleArea(self, heights: List[int]) -> int:\nn = len(heights)\nleft, right = [0] * n, [0] * n\n\nstack = []\nfor i in range(n):\nwhile stack and heights[stack[-1]] >= heights[i]:\nstack.pop()\nleft[i] = stack[-1] if stack else -1\nstack.append(i)\n\nstack.clear()\nfor i in reversed(range(n)):\nwhile stack and heights[stack[-1]] >= heights[i]:\nstack.pop()\nright[i] = stack[-1] if stack else n\nstack.append(i)\n\nans = 0\nfor i in range(n):\nans = max(ans,(right[i]-left[i]-1) * heights[i])\nreturn ans\n注意到左侧遍历，单调栈出栈时，表明 stack[-1] 是 i 左侧更大的元素，也就是 i 是 stack[-1] 右侧更小的元素，因此，可以直接更新 right[stack[-1]] = i。更细一点的讨论该情况：\n如果栈内元素 j 弹栈了，那 i 就是 j 右侧第一个比 j 小的柱子。\n如果栈内有元素 j 一直没弹栈，说明遍历过程中 heights[j] <= heights[i]，那么 right[j] 为默认值 n（即 j 右侧不存在比 j 低的柱子）\n\n\nclass Solution:\ndef largestRectangleArea(self, heights: List[int]) -> int:\nn = len(heights)\nleft, right = [0] * n, [n] * n\n\nstack = []\nfor i in range(n):\nwhile stack and heights[stack[-1]] >= heights[i]:\nright[stack[-1]] = i\nstack.pop()\nleft[i] = stack[-1] if stack else -1\nstack.append(i)\n\nans = 0\nfor i in range(n):\nans = max(ans,(right[i]-left[i]-1) * heights[i])\nreturn ans","85-最大矩形#85. 最大矩形":"令 dp[i][j] 为第 i 行以 j 为底的柱状图的最大高度，此时问题转化为 84. 柱状图中最大的矩形。复杂度 $O(mn)$\nclass Solution:\ndef maximalRectangle(self, matrix: List[List[str]]) -> int:\nrow = len(matrix)\ncol = len(matrix[0])\ndp = [[1] * col for _ in range(row)]\n\n# 统计 matrix[:i][j] 作为柱状图的高度\nfor i in range(row):\nfor j in range(col):\nif i == 0:\ndp[i][j] = int(matrix[i][j])\nelif matrix[i][j] == '0':\ndp[i][j] = 0\nelse:\ndp[i][j] = dp[i][j] + dp[i-1][j]\n\n# 柱状图中最大的矩形单调栈优化解法\ndef findArea(heights):\nn = len(heights)\nleft, right = [0] * n, [n] * n\n\nstack = []\nfor i in range(n):\nwhile stack and heights[stack[-1]] >= heights[i]:\nright[stack[-1]] = i\nstack.pop()\nleft[i] = stack[-1] if stack else -1\nstack.append(i)\n\nans = 0\nfor i in range(n):\nans = max(ans,(right[i]-left[i]-1) * heights[i])\nreturn ans\n\n# 对每一行统计一次\nans = 0\nfor i in range(row):\nans = max(ans,findArea(dp[i]))\n\nreturn ans"}},"/tutorial/algorithm/category/linear/3":{"title":"并查集","data":{"":"并查集的基本操作为 find/merge，用来判断两个元素是否在一个集合内。其中 merge(i,j) 用于将两个集合放在一个集合中，find(i) == find(j) 用来判断两个元素是否在一个集合内一个基本的并查集实现：\nclass Union:\ndef __init__(self,n):\nself.union = list(range(n))\n\ndef find(self,c):\nif c != self.union[c]:\nself.union[c] = self.find(self.union[c])\nreturn self.union[c]\n\ndef merge(self,i,j):\nself.union[self.find(i)] = self.find(j)","684-冗余连接#684. 冗余连接":"树的奇数层和偶数层结点可以恰好分到两个集合中。\nclass Union:\ndef __init__(self,n):\nself.union = list(range(n))\n\ndef find(self,c):\nif c != self.union[c]:\nself.union[c] = self.find(self.union[c])\nreturn self.union[c]\n\ndef merge(self,i,j):\nself.union[self.find(i)] = self.find(j)\n\nclass Solution:\ndef findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\nunion = Union(len(edges)+1)\nfor i, j in edges:\nif union.find(i) != union.find(j):\nunion.merge(i,j)\ncontinue\nreturn [i,j]\nreturn []","1971-寻找图中是否存在路径#1971. 寻找图中是否存在路径":"使用 Python 语言，并查集可以用更方便的方式实现：\nclass Solution:\ndef validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\narr = list(range(n))\n\ndef find(i):\nif arr[i] != i:\narr[i] = find(arr[i])\nreturn arr[i]\n\ndef merge(i,j):\narr[find(i)] = find(j)\n\nfor i,j in edges:\nif find(i) != find(j):\nmerge(i,j)\n\nreturn find(source) == find(destination)"}},"/tutorial/algorithm/category/linear/4":{"title":"散列","data":{"":"[ ]"}},"/tutorial/algorithm/category/linear/5":{"title":"树状数组","data":{"":"树状数组是一种可以动态维护序列前缀和的数据结构，它的功能是：\n单点更新 update(i, v)： 把序列 i 位置的数加上一个值 v，这题 v = 1\n区间查询 query(i)： 查询序列 [1...i] 区间的区间和，即 i 位置的前缀和","剑指-offer-51-数组中的逆序对#剑指 Offer 51. 数组中的逆序对":""}},"/tutorial/algorithm/category/linear/6":{"title":"链表","data":{"":"链表题提前在头部或尾部设置一个 dummy 结点会方便很多。这个节点一般叫做“哨兵”","160-相交链表#160. 相交链表":"class Solution:\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\nl,r = headA,headB\nc = 2\nwhile l != r: # 各自遍历一遍如果不相交则均为 None\nl = l.next if l else headB\nr = r.next if r else headA\n\nreturn l","83-删除排序链表中的重复元素#83. 删除排序链表中的重复元素":"class Solution:\ndef deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\ndummy = ListNode(None,head)\ncur = dummy.next\nwhile cur:\nif cur.next and cur.val == cur.next.val:\ncur.next = cur.next.next\nelse:\ncur = cur.next\nreturn dummy.next","21-合并两个有序链表#21. 合并两个有序链表":"和合并两个有序数组一样，有序遍历两个链表并实现一个 append 函数即可\nclass Solution:\ndef mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\nc1 = list1\nc2 = list2\nif c1 is None:\nreturn c2\nif c2 is None:\nreturn c1\n\ndummy = ListNode()\ncur = dummy\n\ndef append(node):\nnonlocal cur\ncur.next = node\ncur = cur.next\nreturn node.next\n\n\nwhile c1 or c2:\nif c2 is None:\nc1 = append(c1)\nelif c1 is None:\nc2 = append(c2)\nelse:\nif c1.val < c2.val:\nc1 = append(c1)\nelse:\nc2 = append(c2)\n\nreturn dummy.next","206-反转链表#206. 反转链表":"反转链表需要在每一个结点步维护 pre/cur/next 三个变量，维护好后，就能够实现反转 cur 指向的同时不丢失遍历顺序。\nclass Solution:\ndef reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\nif head is None: # 边界判断，用来避免 cur 不移动，返回 pre 的问题\nreturn None\n\ndummy = ListNode(next=head)\npre = dummy\ncur = head\nwhile cur:\nnext = cur.next\ncur.next = pre\npre = cur\ncur = next\n\ndummy.next.next = None\nreturn pre","92-反转链表-ii#92. 反转链表 II":"维护反转区间左右两个边界处的结点 left/right，区间内翻转后校正 left 和 left.next 的结点即可。\nclass Solution:\ndef reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\ndummy = ListNode(next=head)\npre = dummy\ncur = head\nleftNode = dummy\nfor i in range(1,right+1):\nif i < left:\npre = cur\ncur = cur.next\nelse:\nif i == left:\nleftNode = pre\nnext = cur.next\ncur.next = pre\npre = cur\ncur = next\n# 退出时，cur 是 right， pre 是 right-1\n\nleftNode.next.next = cur\nleftNode.next = pre\n\nreturn dummy.next","24-两两交换链表中的节点#24. 两两交换链表中的节点":"维护好 left 和 right，然后 2 个一组递推就好\nclass Solution:\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\nleft = dummy = ListNode(next=head)\n\npre = head\ncur = head.next if pre is not None else None\n\nwhile pre and cur:\nif cur is not None:\nright = cur.next\n\nleft.next = cur\ncur.next = pre\npre.next = right\n\nleft = pre\npre = right\nif pre is not None:\ncur = pre.next\n\nreturn dummy.next","25-k-个一组翻转链表#25. K 个一组翻转链表":"和两个一组没有根本区别，因为是 k 不固定，所以用一个 list 存即可，还是维护好 left 和 right\nclass Solution:\ndef reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\ndummy = ListNode(next=head)\nleft = dummy\ncur = head\n\nres = []\nwhile cur is not None:\nfor i in range(k):\nres.append(cur)\ncur = cur.next\nif cur is None:\nbreak\nright = cur\nif len(res) < k:\nbreak\n\nres[0].next = right\nfor i in range(1, k):\nres[i].next = res[i-1]\nleft.next = res[-1]\nleft = res[0]\nres = []\n\nreturn dummy.next","146-lru-缓存#146. LRU 缓存":"哈希 + 双向链表\nclass Node:\ndef __init__(self,key=None,value=None,pre=None,next=None):\nself.val = value\nself.key = key\nself.next = next\nself.pre = pre\n\n\nclass LRUCache:\n\ndef __init__(self, capacity: int):\nself.head = Node()\nself.tail = Node()\nself.head.next = self.tail\nself.tail.pre = self.head\nself.memo = {}\nself.capacity = capacity\n\ndef move_to_end(self,key):\nnode = self.memo[key]\n# remove from original pos\nnode.pre.next = node.next\nnode.next.pre = node.pre\n\n# append at last\nnode.next = self.tail\nnode.pre = self.tail.pre\nnode.next.pre = node\nnode.pre.next = node\n\ndef append(self,key,value):\n# append at last\nnode = Node(key,value)\nself.memo[key] = node\n\nnode.next = self.tail\nnode.pre = self.tail.pre\nnode.next.pre = node\nnode.pre.next = node\n\ndef __str__(self):\nres = []\ncur = self.head\nwhile cur:\nres.append(f'{cur.key}')\ncur = cur.next\na = '->'.join(res)\n\nres = []\ncur = self.tail\nwhile cur:\nres.append(f'{cur.key}')\ncur = cur.pre\n\nb = '<-'.join(reversed(res))\nreturn a + \" | \" + b\n\ndef remove_head(self):\nself.head.next = self.head.next.next\nself.head.next.pre = self.head\nself.memo.pop(head.key)\n\ndef get(self, key: int) -> int:\n\n# 有返回 value，无返回 -1\n# print(self)\nif key in self.memo:\nself.move_to_end(key)\nreturn self.memo[key].val\nreturn -1\n\ndef put(self, key: int, value: int) -> None:\n# print(self.memo.keys(),key,value)\n# print(self)\nif key in self.memo:\n# 有 move_to_end\nself.move_to_end(key)\nself.memo[key].val = value\nelse:\nif len(self.memo) >= self.capacity:\nself.remove_head()\n# 无 append and remove head\nself.append(key,value)","#[]":""}},"/tutorial/algorithm/category/linear/7":{"title":"队列与栈","data":{"":"队列：先进先出，排队\n栈：先进后出，摞盘子","1700-无法吃午餐的学生数量#1700. 无法吃午餐的学生数量":"可以用栈模拟，直接计数也可以\nclass Solution:\ndef countStudents(self, students: List[int], sandwiches: List[int]) -> int:\nqueue = Counter(students)\n\nfor i in range(len(sandwiches)):\nif queue[sandwiches[i]] > 0:\nqueue[sandwiches[i]] -= 1\nelse:\ni -= 1 # 退回，当前三明治无法被消化\nbreak\n\nreturn len(sandwiches) - i - 1 # 从 0 开始，所以是 len(sandwiches) - (i+1)","20-有效的括号#20. 有效的括号":"简单的栈操作\nclass Solution:\ndef isValid(self, s: str) -> bool:\nstack = []\n\nfor c in s:\nif c in '[({':\nstack.append(c)\nelse:\nif len(stack) == 0:\nreturn False\nelif stack[-1]+c in {'[]','()',\"{}\"}:\nstack.pop()\nelse:\nreturn False\n\nreturn len(stack) == 0","1678-设计-goal-解析器#1678. 设计 Goal 解析器":"简单的栈。\nclass Solution:\ndef interpret(self, command: str) -> str:\nstack = []\n\nfor c in command:\nif c == ')':\nif stack[-1] == 'l':\nstack = stack[:-3]\nstack.append('al')\nelse:\nstack.pop()\nstack.append('o')\nelse:\nstack.append(c)\n\nreturn ''.join(stack)\n其实这道题不用栈也行，因为不存在递归解析的过程：\nclass Solution:\ndef interpret(self, command: str) -> str:\nres = []\nfor i, c in enumerate(command):\nif c == 'G':\nres.append(c)\nelif c == '(':\nres.append('o' if command[i + 1] == ')' else 'al')\nreturn ''.join(res)","1106-解析布尔表达式#1106. 解析布尔表达式":"栈操作，遇到右括号后出栈左括号内的内容和操作符，然后将操作结果重新入栈。难度较低\nclass Solution:\ndef parseBoolExpr(self, expression: str) -> bool:\nstack = []\n\nfor i in range(len(expression)):\nc = expression[i]\nif c == ')':\ncontent = []\ncur = stack.pop()\nwhile cur != '(':\nif cur == 't':\ncontent.append(True)\nelif cur == 'f':\ncontent.append(False)\ncur = stack.pop()\nop = stack.pop()\nif op == '&':\nres = all(content)\nelif op == '|':\nres = any(content)\nelse: # !\nres = not content[-1]\n\nres = 't' if res else 'f'\nstack.append(res)\n\nelse:\nstack.append(c)\n\nreturn stack[-1] == 't'\n\n225. 用队列实现栈"}},"/tutorial/algorithm/category/linear":{"title":"Index","data":{"":""}},"/tutorial/algorithm/category/math/0":{"title":"其他","data":{"":"","43-字符串相乘#43. 字符串相乘":"傅里叶变换","754-到达终点数字#754. 到达终点数字":"推理长，代码短\nclass Solution:\ndef reachNumber(self, target: int) -> int:\ntarget = abs(target)\nk = 0\nwhile target > 0:\nk += 1\ntarget -= k\nreturn k if target % 2 == 0 else k + 1 + k % 2","878-第-n-个神奇数字#878. 第 N 个神奇数字":"容斥原理。官方题解\nclass Solution:\ndef nthMagicalNumber(self, n: int, a: int, b: int) -> int:\nMOD = 10 ** 9 + 7\nl = min(a, b)\nr = n * min(a, b)\nc = lcm(a, b)\nwhile l <= r:\nmid = (l + r) // 2\ncnt = mid // a + mid // b - mid // c\nif cnt >= n:\nr = mid - 1\nelse:\nl = mid + 1\nreturn (r + 1) % MOD"}},"/tutorial/algorithm/category/math/1":{"title":"平均值和最大的分组的子数组数目","data":{"":"","813-最大平均值和的分组#813. 最大平均值和的分组":"已知前提：\n平均值和最大的分组的子数组数目必定是 k\n长度为 k 的数组最多可以划分为 k 份\n\n令 dp[i][j] 为表示将 nums[:i] 分为 j 个子数组的最大平均值和，则 dp[n][k] 即为最终结果。可得初始化为：\ndp[n+1][k+1]\ndp[:][0] = 0, dp[0][:] = 0\ni>0 : dp[i][1] = mean(0,i), 其中 mean(i,j) 简化表示 i-j 区间数组的平均值，可以用前缀和初始化后在 O(1) 内求得。\ndp[i][i] = sum(nums[:i]) (因为长度为 k 的数组最多可以划分为 k 份)\n\n因为长度为 k 的数组最多可以划分为 k 份，所以 dp[1][2] 等不赋值，仅计算 dp[2:][2], dp[3:][3], ..., dp[k:][k] 的值真正的状态转移函数可以从 dp[3][2] 开始分析dp[3][2] 表示 nums 前三个数字分两组可能的分法，对示例输入 nums = [9,1,2,3,9], k = 3，nums[:3] = [9,1,2]，有 [9],[1,2] 和 [9,1],[2]两种分法，分别表示为 dp[1][1] + means(2,3) 和 dp[2][1] + mean(3,3)，dp[3][2] 最终值为两者取最大。dp[4][2] 以此类推，需要分别考虑：\ndp[1][1] + mean(2,4)，即 [9],[1,2,3]\ndp[2][1] + mean(3,4)，即 [9,1],[2,3]\ndp[3][1] + mean(4,4)，即 [9,1,2],[3]\n\n规律已经出现了，最后再考虑 dp[4][3]，dp[5][3]，dp[4][3]需要考虑：\ndp[2][2] + mean(3,4)\ndp[3][2] + mean(4,4)\n\n上面的考虑过程中，dp[2][2], dp[3][2] 的最大值之前已经求得，不需要管它是什么划分，只需要考虑剩下的第三部份划分加上前面的最大划分是否更大即可。最后，dp[5][3] 需要考虑：\ndp[2][2] + mean(3,5)\ndp[3][2] + mean(4,5)\ndp[4][2] + mean(5,5)\n\n上述推导归纳得到的信息为：\nmean(i,j) 可以通过前缀和算法一遍遍历得到\n前 i 个子数组分为 j 个需要考虑 j-i+1 个划分取最大，将这 j-i+1 个划分的遍历变量设置为 x，x 在每个循环的初始值是 j-1，最大到 i-1 （留最后一个数字给最新的划分），表示划分数等于数组数的情况 dp[j-1][j-1] 。最终的算法是一个三层循环。\n\n\nclass Solution:\ndef largestSumOfAverages(self, nums: List[int], k: int) -> float:\nn = len(nums)\nprefix = list(accumulate(nums, initial=0)) # 前缀和\n\ndp = [[0] * (k + 1) for _ in range(n + 1)] # dp[n+1][k+1]\n\n# dp[:][1] = mean(0,i)\nfor i in range(1, n + 1):\ndp[i][1] = prefix[i] / i\n\nfor j in range(2, k + 1): # 从 dp[i][2] 开始\nfor i in range(j, n + 1): # dp[:j][j] 没有意义\nfor x in range(j - 1, i): # x in [j-1, i)\ndp[i][j] = max(\ndp[i][j],\n#              {-------mean(x,i)---------------}\ndp[x][j - 1] + (prefix[i] - prefix[x]) / (i - x)\n)\n\nreturn dp[n][k]","reference#Reference":"https://leetcode.cn/problems/largest-sum-of-averages/solution/by-superzyc-3ic2/"}},"/tutorial/algorithm/category/math/2":{"title":"最小公倍数和最大公约数","data":{"":"公约数：X 能够整除多个整数，则 X 是这些整数的公约数\nGCD（Greatest Common Divisor）最大公约数：公约数中最大的公约数。","2447-最大公因数等于-k-的子数组数目#2447. 最大公因数等于 K 的子数组数目":"暴力循环\nclass Solution:\ndef subarrayGCD(self, nums: List[int], k: int) -> int:\nans = 0\nfor i in range(len(nums)):\ng = 0\nfor j in range(i, len(nums)):\ng = gcd(g, nums[j])\nif g % k: break\nif g == k: ans += 1\nreturn ans\n\nhttps://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/solution/by-endlesscheng-3qnt/\n\n\n公倍数：X 可以被 A 和 B 整除，则 X 是 A 和 B 的公倍数。任意两个数的公倍数有无限个。\nLCM（Least Common Multiple）最小公倍数：所有正的公倍数中最小的公倍数。\n\n最大公约数和最小公倍数之间的关系是：lcm(a,b) = abs(a*b)/gcd(a,b)","6234-最小公倍数为-k-的子数组数目#6234. 最小公倍数为 K 的子数组数目":"class Solution:\ndef subarrayLCM(self, nums: List[int], k: int) -> int:\nans, n = 0, len(nums)\nfor i in range(n):\nres = 1\nfor j in range(i, n):\nres = lcm(res, nums[j])\nif k % res: break  # 剪枝：LCM 必须是 k 的因子\nif res == k: ans += 1\nreturn ans\n\nhttps://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/solution/by-endlesscheng-3qnt/\n\n\nwiki-最大公因数\nwiki-最小公倍数\nGCD 算法\nLCM 算法"}},"/tutorial/algorithm/category/math/3":{"title":"素数","data":{"":""}},"/tutorial/algorithm/category/math":{"title":"Index","data":{"":""}},"/tutorial/algorithm/category/others/0":{"title":"二分","data":{"":"","4-寻找两个正序数组的中位数#4. 寻找两个正序数组的中位数":"","两个正序无重复数组中的二分查找#两个正序无重复数组中的二分查找":"某次面试考到的，没找着原题\n\n思路就是加一个 offset"}},"/tutorial/algorithm/category/others/1":{"title":"位运算","data":{"":"相同数字的两次异或运算会变成 0","136-只出现一次的数字#136. 只出现一次的数字":"class Solution:\ndef singleNumber(self, nums: List[int]) -> int:\nfor i in accumulate(nums,lambda i,j:i^j):\npass\nreturn i\n```\n\n## [面试题 05.07. 配对交换](https://leetcode.cn/problems/exchange-lcci/)\n\n2^31 限定了是四字节整数，`01010101` 和 `10101010` 分别做掩码\n\n```python\nclass Solution:\ndef exchangeBits(self, num: int) -> int:\nreturn ((num & 0xaaaaaaaa) >> 1) | ((num & 0x55555555) << 1)","190-颠倒二进制位#190. 颠倒二进制位":"[ ]\n\n\nM1 = 0x55555555; # 01010101010101010101010101010101\nM2 = 0x33333333; # 00110011001100110011001100110011\nM4 = 0x0f0f0f0f; # 00001111000011110000111100001111\nM8 = 0x00ff00ff; # 00000000111111110000000011111111\nn = n >> 1 & M1 | (n & M1) << 1;\nn = n >> 2 & M2 | (n & M2) << 2;\nn = n >> 4 & M4 | (n & M4) << 4;\nn = n >> 8 & M8 | (n & M8) << 8;\nreturn n >> 16 | n << 16;","268-丢失的数字#268. 丢失的数字":"位运算\nclass Solution:\ndef missingNumber(self, nums: List[int]) -> int:\nfor ans in accumulate(chain(nums,range(len(nums)+1)),lambda i,x:i^x):\npass\n\nreturn ans\n除了位运算，抵消的思想还可以通过加减来实现\nclass Solution:\ndef missingNumber(self, nums: List[int]) -> int:\nans = len(nums)\nfor i in range(len(nums)):\nans += (i-nums[i])\nreturn ans"}},"/tutorial/algorithm/category/others/10":{"title":"旋转的模拟方法","data":{"":"四个方向的旋转一般可以通过二维数组存储来解决\nstep = [\n[1,0],# ↓\n[0,1], # →\n[-1,0], # ↑\n[0,-1], # ←\n]\nK = 0 # down\nK = (K+1) % 4 # 逆时针旋转\nK = (K+3) % 4 # 顺时针旋转\n\n\nLCP 63. 弹珠游戏：不需要 DFS，直接每个出发点模拟一遍即可"}},"/tutorial/algorithm/category/others/11":{"title":"暴力","data":{"":"也叫 Brute-Force","1620-网络信号最好的坐标#1620. 网络信号最好的坐标":"关键是算好计算量\nclass Solution:\ndef bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:\nx_max = max(t[0] for t in towers)\ny_max = max(t[1] for t in towers)\ncx = cy = max_quality = 0\nfor x in range(x_max + 1):\nfor y in range(y_max + 1):\nquality = 0\nfor tx, ty, q in towers:\nd = (x - tx) ** 2 + (y - ty) ** 2\nif d <= radius ** 2:\nquality += int(q / (1 + d ** 0.5))\nif quality > max_quality:\ncx, cy, max_quality = x, y, quality\nreturn [cx, cy]\n\n抄的题解"}},"/tutorial/algorithm/category/others/12":{"title":"移位","data":{"":"","9-回文数#9. 回文数":"一个简单的想法是字符串化后双指针\nclass Solution:\ndef isPalindrome(self, x: int) -> bool:\nx = str(x)\ni = 0\n\nfor i in range(len(x)//2):\nif x[i] != x[-i-1]:\nreturn False\n\nreturn True\n更极端一点\nclass Solution:\ndef isPalindrome(self, x: int) -> bool:\nx = str(x)\nreturn x == x[::-1]\n但因为这道题是数字，因此另外一个考点是通过移位构造一个反向数字\nclass Solution:\ndef isPalindrome(self, x: int) -> bool:\nif x < 0:\nreturn False\n\nre = 0\ner = x\nwhile x > 0:\nre = re * 10 + x % 10\nx //= 10\n\nreturn re == er"}},"/tutorial/algorithm/category/others/13":{"title":"置换次数","data":{"":"对 n 个无重复乱序数组通过两两元素交换转变为有序数组的最小交换次数。[2,0,1,4,3] 中，[2,0,1] 和 [4,3] 分别是两个置换环，环与环之间是数字是不需要发生交换的，只会在环内发生交换。对每个环，交换次数为环的大小减 1。对 [0,n) 的元素，可以直接遍历过程中交换得到交换次数。\ndef swapCount(arr):\nans = 0\n\ndef swap(i, j):\narr[i], arr[j] = arr[j], arr[i]\nreturn arr[i]\n\nfor i in range(len(arr)):\nif arr[i] == i:\ncontinue\ntmp = i\nwhile arr[tmp] != tmp:\ntmp = swap(tmp, arr[tmp])\nans += 1 # 交换一次\n\nreturn ans\n对 n 个不完全处于 [0,n) 的元素，可以通过排序获取下标的方式将其映射到 [0,n)\nimport bisect\n\ndef swapCount(arr):\nans = 0\n\ndef swap(i, j):\narr[i], arr[j] = arr[j], arr[i]\nreturn arr[i]\n\nsarr = sorted(arr)\narr = [bisect.bisect_left(sarr, i) for i in arr]\n\nfor i in range(len(arr)):\nif arr[i] == i:\ncontinue\ntmp = i\nwhile arr[tmp] != tmp:\ntmp = swap(tmp, arr[tmp])\nans += 1 # 交换一次\n\n\nreturn ans\n如果要求不实际进行交换操作（或者为了省交换时间），则可以通过构建一个 visited 数组模拟交换\ndef swapCount(arr):\nans = len(arr)\n\nvis = [False] * ans\nfor i in range(len(arr)):\nif vis[i]:\ncontinue\n\ntmp = i\nwhile not vis[tmp]:\nvis[tmp] = True\ntmp = arr[tmp]\n\nans -= 1 #\n\nreturn ans","6235-逐层排序二叉树所需的最少操作数目#6235. 逐层排序二叉树所需的最少操作数目":"周赛题，通过层序遍历和置换环求解，模拟交换 Python 会超时，需要用 visited 数组做。参考了 大佬的题解。\nclass Solution:\ndef minimumOperations(self, root: Optional[TreeNode]) -> int:\nans, q = 0, [root]\n\ndef swap(arr,i,j):\narr[i],arr[j] = arr[j],arr[i]\nreturn arr[i]\n\n# 层序遍历\nwhile q:\narr = []\ntmp = q\nq = []\nfor node in tmp:\narr.append(node.val)\nif node.left: q.append(node.left)\nif node.right: q.append(node.right)\n\n# 遍历\nsarr = sorted(arr) # 排序\narr = [bisect_left(sarr, v) for v in arr]  # 从 0 对齐下标\n\nvis = [False] * len(arr)\nans += len(arr)\nfor i in range(len(arr)):\nif vis[i]:\ncontinue\ntmp = i\n\nwhile not vis[i]:\nvis[i] = True\ni = arr[i]\nans -= 1\n\nreturn ans","2134-最少交换次数来组合所有的-1-ii#2134. 最少交换次数来组合所有的 1 II":"假设数组内共有 n 个 1，那么维护一个长度为 n 的滑动窗口，遍历一遍，当滑动窗口内包含最多 1 时，此时将该窗口内的 0 和窗口外的 1 交换，即为最少的交换次数。\nclass Solution:\ndef minSwaps(self, nums: List[int]) -> int:\nc1 = sum(nums)\nn = len(nums) + c1\nans = 0\ncnt = 0\nfor i in range(n):\ncnt += nums[i % len(nums)]\nif i >= c1:\ncnt -= nums[i-c1]\nans = max(ans,cnt)\nreturn c1 - ans"}},"/tutorial/algorithm/category/others/14":{"title":"遍历两遍","data":{"":"","1752-检查数组是否经排序和轮转得到#1752. 检查数组是否经排序和轮转得到":"class Solution:\ndef check(self, nums: List[int]) -> bool:\ncnt = 0\nn = len(nums)\nfor i in range(len(nums) * 2):\nif nums[i % n] > nums[(i + 1) % n]:\ncnt += 1\n\nreturn cnt <= 2"}},"/tutorial/algorithm/category/others/2":{"title":"全排列","data":{"":"有 n 个元素，n 个元素不放回抽取抽取 n 次，总共有 $n!$ 种抽取结果（按抽取顺序排列）。这一过程就是全排列的过程。输出全排列的过程可以用递归很好的模拟，最外层循环 n 次，每个循环步内递归的循环 n-1 次。\ndef permutation(arr,idx=0): # idx 为当前位置要挑选的元素\nif idx == len(arr): #\nyield arr[:]\n\nfor i in range(idx,len(arr)):\narr[idx],arr[i] = arr[i],arr[idx] # 挑选 i 为当前 idx 的主元素\nyield from permutation(arr,idx+1) # 递归挑选下一次\narr[idx],arr[i] = arr[i],arr[idx] # 回复挑选状态\n\nprint(list(permutation([1,2,3])))\n该思路和 dfs 的思路基本一致：\nres = []\ndef dfs(a,b):\nif len(b) == len(nums):\nres.append(b)\n\nfor i in range(len(a)):\ndfs(a[:i]+a[i+1:],b + [a[i]])\n\ndfs(nums,[])\nprint(res)\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]","有重复元素的全排列47-全排列-ii#有重复元素的全排列(47. 全排列 II)":"对有重复元素的全排列（如 1,2,2），全排列结果中会出现重复。在第 idx 位挑选剩余元素时，有 n-idx 个可挑选元素，如果 arr[i] 对应的数字挑选过，就应该在当前循环中跳过。\ndef permutation(arr,idx=0): # idx 为当前位置要挑选的元素\nif idx == len(arr): #\nyield arr[:]\n\ncheck = set()\nfor i in range(idx,len(arr)):\nif arr[i] in check:\ncontinue\ncheck.add(arr[i])\narr[idx],arr[i] = arr[i],arr[idx] # 挑选 i 为当前 idx 的主元素\nyield from permutation(arr,idx+1) # 递归挑选下一次\narr[idx],arr[i] = arr[i],arr[idx] # 回复挑选状态\n\nprint(list(permutation([1,2,2])))\n# [[1, 2, 2], [2, 1, 2], [2, 2, 1]]","31-下一个排列#31. 下一个排列":"下一个排列是指全排列中，当前排列在有序全排列列表中的下一个元素。\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n# [[1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1], [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1], [3, 4, 1, 2], [3, 4, 2, 1], [4, 1, 2, 3], [4, 1, 3, 2], [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1]]\n\n\n思路和全排列的思路完全不一致，待整理","60-排列序列#60. 排列序列":"全排列的过程是替每一位重新选择一个数字的过程，注意从左往右选，固定该位置后可能的排列个数是 (n-1)!，因此可以依次对 k 按照位数取模计算当前位。\n总结写的好烂，这会没脑子，以后重写 2022-10-31-16-06\n\n\n第一位选 2 个，第二位只能选 1 个\n\"123\"\n\"132\"\n\"213\"\n\"231\"\n\"312\"\n\"321\"\n\nclass Solution:\ndef getPermutation(self, n: int, k: int) -> str:\ndp = [1] * (n + 1)\nfor i in range(1, n + 1):\ndp[i] = dp[i - 1] * i\n\nselection = list(range(1, n + 1))\n\nk -= 1\n\nc = n - 1\nres = []\nwhile k > 0:\nidx = (k // dp[c])\nk = k % dp[c]\nc -= 1\nres.append(selection.pop(idx))\n\nres.extend(selection)\nreturn ''.join([str(i) for i in res])"}},"/tutorial/algorithm/category/others/3":{"title":"分治","data":{"":"","归并排序#归并排序":"class Solution:\n\ndef mergeSort(self, nums: List[int]) -> None:\ndef merge(l, m, r):\n# 假设 l~m, m+1~r 都已经有序\ni = l\nj = m + 1\nres = []\n\nwhile i <= m and j <= r:\nif nums[i] < nums[j]:\nres.append(nums[i])\ni += 1\nelse:\nres.append(nums[j])\nj += 1\n\nwhile i <= m:\nres.append(nums[i])\ni += 1\nwhile j <= r:\nres.append(nums[j])\nj += 1\n\nfor k in range(l, r + 1):\nnums[k] = res[k - l]\n\ndef mergeSort(l, r):\nif l < r:\nmid = (l + r) // 2\nmergeSort(l, mid)\nmergeSort(mid + 1, r)\nmerge(l, mid, r)\n# print(l, r, nums[l:r + 1], nums)\n\nmergeSort(0, len(nums) - 1)\n\nclass Solution:\ndef mergeSort(self, nums: List[int]) -> List[int]:\nif len(nums) <= 1:\nreturn nums\n\nmid = len(nums) // 2\n\nl = self.mergeSort(nums[:mid])\nr = self.mergeSort(nums[mid:])\n\nres = []\nwhile l and r:\nres.append(l.pop(0) if l[0] <= r[0] else r.pop(0))\n\nres.extend(r if r else l)\nreturn res\n此外，还可以通过栈模拟函数栈的调用来减少常数开销/防止爆栈：\nclass Solution:\ndef mergeSort(self, nums: List[int]) -> None:\nq = deque()\nq.append((0, len(nums) - 1, False))\n\ndef merge(l, m, r):\n# 假设 l~m, m+1~r 都已经有序\ni = l\nj = m + 1\nres = []\n\nwhile i <= m and j <= r:\nif nums[i] < nums[j]:\nres.append(nums[i])\ni += 1\nelse:\nres.append(nums[j])\nj += 1\n\nwhile i <= m:\nres.append(nums[i])\ni += 1\nwhile j <= r:\nres.append(nums[j])\nj += 1\n\nfor k in range(l, r + 1):\nnums[k] = res[k - l]\n\nwhile q:\nl, r, visited = q.pop()\nmid = (l + r) // 2\nif visited:\nmerge(l, mid, r)\nelse:\nq.append((l, r, True))\nif l < r:\nq.append((l, mid, False))\nq.append((mid + 1, r, False))\n\nreturn nums","快速排序#快速排序":"class Solution:\ndef quickSort(self, nums: List[int]):\ndef partition(l, r):\nx = nums[r]\ni = l\n\n# 遍历 [l, r) 的元素，把所有小于 x（即 pivot）的元素按顺序移到左侧\nfor j in range(l, r):\nif nums[j] <= x:\nnums[i], nums[j] = nums[j], nums[i]\ni += 1\n\n# 如果 i == l，说明 for 循环中没有 nums[j] <= x 的，即 nums[i] > x\n# 如果 l < i <= r，则 i 经过了多次 nums[j] <= x 的遍历，每次遍历 nums[i] 的位置存储了小于 x 的nums[j] 元素\n# 最后一次 i+=1 结束后，所有小于 x 的元素位于 i 左侧，此时将 x 的位置 r 和 i 进行交换即可\n# （i 可能等于 r，此时交换和不交换等价）\nnums[i], nums[r] = nums[r], nums[i]\nreturn i\n\ndef sort(l, r):\nif l < r:\nprint(nums)\nq = partition(l, r)\nsort(l, q - 1)\nsort(q + 1, r)\n\nsort(0, len(nums) - 1)\nreturn nums","215-数组中的第-k-个最大元素#215. 数组中的第 K 个最大元素":"利用快排中 partition 的思想，每次取一个区间进行 partition 操作，复杂度最差是 $O(n)$，平均是 $O(log(n))$\nclass Solution:\ndef findKthLargest(self, nums: List[int], k: int) -> int:\nseed(42)\nshuffle(nums)\ndef partition(l, r):\nx = nums[r]\ni = l\nfor j in range(l, r):\nif nums[j] >= x:\nnums[i], nums[j] = nums[j], nums[i]\ni += 1\nnums[i], nums[r] = nums[r], nums[i]\nreturn i\n\nk -= 1\nl = 0\nr = len(nums) - 1\ni = partition(l, r)\nwhile i != k:\nif i > k:\nr = i - 1\nelif i < k:\nl = i + 1\ni = partition(l, r)\n\nreturn nums[i]\n还可以利用最小堆，复杂度$O(nlogn)$\nclass Solution:\ndef findKthLargest(self, nums: List[int], k: int) -> int:\nnums = [-i for i in nums]\nheapify(nums)\nfor i in range(k):\nans = heappop(nums)\nreturn -ans\n还可以用更简单的最大堆，维护最大的 k 个元素，遍历后的栈顶即为最终元素，复杂度是 $O(nlogk)$\nclass Solution:\ndef findKthLargest(self, nums: List[int], k: int) -> int:\nk-=1\nres = nums[:k+1]\nheapify(res)\nfor i in range(k+1,len(nums)):\nif res[0] < nums[i]:\nheapreplace(res,nums[i])\nreturn res[0]\n结果没有直接排序快\nclass Solution:\ndef findKthLargest(self, nums: List[int], k: int) -> int:\nreturn sorted(nums,reverse=True)[k-1]\n另一种写法，比 sorted 内存开销小一些\nclass Solution:\ndef findKthLargest(self, nums: List[int], k: int) -> int:\nreturn nums[k-1] if nums.sort(reverse=True) is None else None","剑指-offer-51-数组中的逆序对#剑指 Offer 51. 数组中的逆序对":"可以先通过暴力方式了解逆序对\n# 0 <= 数组长度 <= 50000，超时\nclass Solution:\ndef reversePairs(self, nums: List[int]) -> int:\nn = len(nums)\nans = 0\nfor i in range(n):\nfor j in range(i+1,n):\nif nums[i] > nums[j]:\nans += 1\nreturn ans\n考虑对任意两个有序数组 a,b，a+b 组成的序列中逆序对的数量：\n[5,7],[4,6] -> [5,7,4,6]\n会发现该子问题的求解过程是将两个数组通过双指针 i,j 合并为一个有序数组的过程。当 b 数组中存在更小的数时，就计数 n-i 个逆序对：\nclass Solution:\ndef reversedCount(self, a: List[int], b: List[int]) -> int:\ni = j = 0\nn = len(a)\nm = len(b)\n\nans = 0\nwhile i < n and j < m:\nif b[j] < a[i]:\nans += len(a)\nj += 1\nelse:\ni += 1\n\nreturn ans\n最终，一个乱序数组的逆序对的数量可以通过归并排序的过程来完成：\n# 仍然超时\nclass Solution:\ndef reversePairs(self, nums: List[int]) -> int:\nans = 0\ndef merge(l,r):\nnonlocal ans\n\nres = []\nwhile l and r:\nif r[0] < l[0]:\nans += len(l)\nres.append(r.pop(0))\nelse:\nres.append(l.pop(0))\n\nres.extend(l if l else r)\nreturn res\n\ndef mergeSort(arr):\nif len(arr) <= 1:\nreturn arr\n\nmid = len(arr) // 2\n\nl = mergeSort(arr[:mid])\nr = mergeSort(arr[mid:])\nreturn merge(l,r)\n\nmergeSort(nums)\n\nreturn ans\n\n因为上面存在较多的数组复制过程，因此在该题上仍然超时。相同思路代码优化后的版本如下：\nclass Solution:\ndef reversePairs(self, nums: List[int]) -> int:\nans = 0\nmem = nums[:]\n\ndef merge(l,m,r):\nnonlocal ans\ni = l\nj = m+1\nk = l\nwhile i <= m and j <= r:\nif nums[j] < nums[i]:\nans += m-i+1\nmem[k] = nums[j]\nj+=1\nelse:\nmem[k] = nums[i]\ni+=1\nk+=1\n\nwhile i <= m:\nmem[k] = nums[i]\nk+=1\ni+=1\nwhile j<= r:\nmem[k] = nums[j]\nk+=1\nj+=1\n\nnums[l:r+1] = mem[l:r+1]\n\ndef mergeSort(l,r):\nif l < r:\nmid = (l+r) // 2\nmergeSort(l,mid)\nmergeSort(mid+1,r)\nmerge(l,mid,r)\n\nmergeSort(0,len(nums)-1)\nreturn ans\n可以用队列模拟函数调用来减少常数开销/防止爆栈：\nclass Solution:\ndef reversePairs(self, nums: List[int]) -> int:\nans = 0\nmem = nums[:]\n\ndef merge(l,m,r):\nnonlocal ans\ni = l\nj = m+1\nk = l\nwhile i <= m and j <= r:\nif nums[j] < nums[i]:\nans += m-i+1\nmem[k] = nums[j]\nj+=1\nelse:\nmem[k] = nums[i]\ni+=1\nk+=1\n\nwhile i <= m:\nmem[k] = nums[i]\nk+=1\ni+=1\nwhile j<= r:\nmem[k] = nums[j]\nk+=1\nj+=1\n\nnums[l:r+1] = mem[l:r+1]\n\nq = deque()\nq.append((0, len(nums) - 1, False))\n\nwhile q:\nl, r, visited = q.pop()\nmid = (l + r) // 2\nif visited or r - l <= 1:\nmerge(l, mid, r)\nelse:\nq.append((l, r, True))\nq.append((l, mid, False))\nq.append((mid + 1, r, False))\n\nreturn ans"}},"/tutorial/algorithm/category/others/4":{"title":"双指针","data":{"":"","27-移除元素#27. 移除元素":"class Solution:\ndef removeElement(self, nums: List[int], val: int) -> int:\nj = 0\n\nfor i in range(len(nums)):\nif nums[i] != val:\nnums[j] = nums[i]\nj += 1\n\nreturn j","125-验证回文串#125. 验证回文串":"class Solution:\ndef isPalindrome(self, s: str) -> bool:\ns = s.lower()\nl,r = 0,len(s) -1\nwhile l <= r:\nwhile l<=r and not s[l].isalnum():\nl+=1\nwhile l<=r and not s[r].isalnum():\nr-=1\n\nif l <= r and s[l] != s[r]:\nreturn False\nl+=1\nr-=1\n\nreturn True\n更简单的做法：\nclass Solution:\ndef isPalindrome(self, s: str) -> bool:\ns = ''.join(filter(lambda x:x.isalnum(),s)).lower()\nreturn s == s[::-1]","88-合并两个有序数组#88. 合并两个有序数组":"逆序思想\nclass Solution:\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\ni,j,k = m-1,n-1,m+n-1\nwhile i>=0 or j>=0:\nif i < 0:\nnums1[k] = nums2[j]\nj-=1\nelif j < 0:\nnums1[k] = nums1[i]\ni-=1\nelse:\nif nums1[i] < nums2[j]:\nnums1[k] = nums2[j]\nj-=1\nelse:\nnums1[k] = nums1[i]\ni-=1\nk-=1","26-删除有序数组中的重复项#26. 删除有序数组中的重复项":"经典双指针，一个快指针用于遍历，一个慢指针存放无重复元素\nclass Solution:\ndef removeDuplicates(self, nums: List[int]) -> int:\ni = 0\nsize = len(nums)\ncur = None\nc = 0\nfor j in range(size): # 遍历一遍的用 for 循环，不要用 while，逻辑会更清楚\nif cur is None or cur != nums[j]:\nnums[i] = nums[j]\ni += 1\nc += 1\ncur = nums[j]\nreturn c","15-三数之和#15. 三数之和":"排序后，固定一个搜另外两个，四数值和同理\nclass Solution:\ndef threeSum(self, nums: List[int]) -> List[List[int]]:\n\nsize = len(nums)\nnums = sorted(nums)\nif size == 0 or nums[0] > 0 or nums[-1] < 0:\nreturn []\n\n\ndef sum3():\nif nums[k] > 0:\nreturn 1\nif nums[j] < 0:\nreturn -1\nreturn nums[i] + nums[j] + nums[k]\n\ndef current():\nreturn [nums[i] , nums[j] , nums[k]]\n\nres = []\nfor k in range(size):\ni = k+1\nj = size - 1\n\nif nums[k] > 0:\nbreak\n\nif k > 0 and nums[k] == nums[k-1]:\ncontinue\n\nwhile i < j:\nans =  sum3()\nif ans > 0:\nj -= 1\nelif ans < 0:\ni += 1\nelse:\nres.append(current())\n\nwhile i < j and nums[i] == nums[i+1]: # 跳过重复元素\ni += 1\nwhile i < j and nums[j-1] == nums[j]: # 跳过重复元素\nj -= 1\n\ni += 1\nj -= 1\n\nreturn res","16-最接近的三数之和#16. 最接近的三数之和":"排序+双指针，nums 排序后\na+b+c < target，则 j++，更新 offset\na+b+c > target，则 k--，更新 offset\na+b+c == target，直接返回 target\n\n$O(n^2)$ 复杂度\nclass Solution:\ndef threeSumClosest(self, nums: List[int], target: int) -> int:\nnums = sorted(nums)\noffset = nums[0] + nums[1] + nums[-1] - target\nfor i in range(len(nums)):\nj = i+1\nk = len(nums) - 1\nwhile j < k:\ncur = nums[i] + nums[j] + nums[k]\nif cur < target:\nj += 1\nelif cur > target:\nk -= 1\nelse:\nreturn target\n\nif abs(cur-target) < abs(offset):\noffset = cur - target\n\nreturn target + offset","904-水果成篮#904. 水果成篮":"针对元素类型数量而不是长度的双指针\nclass Solution:\ndef totalFruit(self, fruits: List[int]) -> int:\nmemo = Counter()\nj = 0 # left\n\nmax_v = 0\nfor i in range(len(fruits)):\nmemo[fruits[i]] += 1\nwhile len(memo) > 2:\nmemo[fruits[j]] -= 1\nif memo[fruits[j]] == 0:\nmemo.pop(fruits[j])\nj += 1\nmax_v = max(max_v,i-j+1)\nreturn max_v","481-神奇字符串#481. 神奇字符串":"class Solution:\ndef magicalString(self, n: int) -> int:\na = [1,2,2]\ni = 1\n\nwhile i < n and len(a) <= n:\nflag = 1 if a[-1] == 2 else 2\ni+=1\nfor _ in range(a[i]):\na.append(flag)\n\nans = 0\nfor i in range(n):\nif a[i] == 1:\nans += 1\nreturn ans","141-环形链表#141. 环形链表":"class Solution:\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\nif head is None:\nreturn False\ns,f = head, head.next\nwhile s and f:\nif s == f:\nreturn True\ns = s.next\nf = f.next\nif f:\nf = f.next\nreturn False","6246-追加字符以获得子序列#6246. 追加字符以获得子序列":"class Solution:\ndef appendCharacters(self, s: str, t: str) -> int:\ni = j = 0\nwhile i < len(s) and j < len(t):\nif s[i] == t[j]:\ni += 1\nj += 1\nelse:\ni += 1\nreturn len(t) - j","1775-通过最少操作次数使数组的和相等#1775. 通过最少操作次数使数组的和相等":"主要分两步分析\n边界判断：nums1 的最大最小范围是否和 nums2 的最大最小范围有重叠\n每次选哪个元素改变：当 sum(nums1) < sum(nums2) 时（在 sum(nums1) > sum(nums2) 时可以直接置换数组），更改范围最大的分别是 1<->6/2<->5/3<->4，所以每次从 nums1 或 nums2 选择一个更改范围更大的。\n\n选择需要排序时 $O(nlogn)$，双指针遍历是 $O(n)$，最终复杂度 $O(nlogn)$。常数复杂度。\nclass Solution:\ndef minOperations(self, nums1: List[int], nums2: List[int]) -> int:\nm = len(nums1)\nn = len(nums2)\nl1,l2,r1,r2 = 1 *m,1*n,6*m,6*n\n\nif l1 > r2 or l2 > r1:\nreturn -1\n\ns1,s2 = sum(nums1),sum(nums2)\nif s1 == s2:\nreturn 0\nif s1 > s2:\ns1,s2 = s2,s1\nnums1,nums2 = nums2,nums1\n\nnums1.sort()\nnums2.sort()\nl = 0\nr = len(nums2) - 1\ncnt = 0\nprint(s1,s2,l,r)\nwhile s1 < s2:\nif 3.5 - nums1[l] > nums2[r] - 3.5:\ns1 += 6 - nums1[l]\nl+=1\ncnt += 1\nelse:\ns2 -= nums2[r] - 1\nr-=1\ncnt +=1\n\nreturn cnt"}},"/tutorial/algorithm/category/others/5":{"title":"哈希","data":{"":"","49-字母异位词分组#49. 字母异位词分组":"质数哈希/二进制哈希/计数哈希...\n\n\nclass Solution:\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\nm = {}\n\ndef hash(w):\nres = [0] * 26\noff = ord('a')\nfor c in w:\nres[ord(c)-off] += 1\nres = ','.join([str(i) for i in res])\nreturn res\n\nfor word in strs:\nm.setdefault(hash(word),[]).append(word)\n\nreturn list(m.values())"}},"/tutorial/algorithm/category/others/6":{"title":"子序列","data":{"":"","392-判断子序列#392. 判断子序列":"注意是子序列，不是子串。使用双指针即可\nclass Solution:\ndef isSubsequence(self, s: str, t: str) -> bool:\nif s == '':\nreturn True\n\ni = 0\nj = 0\n\nwhile j < len(t):\nwhile j < len(t) and s[i] != t[j]:\nj+=1\n\nif j >= len(t):\nreturn False\n# s[i] == t[j]\ni+=1\nj+=1\n\nif i == len(s):\nreturn True\n\nreturn False","792-匹配子序列的单词数#792. 匹配子序列的单词数":"建立序列自动机\nclass Solution:\ndef numMatchingSubseq(self, s: str, words: List[str]) -> int:\nn = len(s)\nindex = {k: v for v, k in enumerate('qwertyuiopasdfghjklzxcvbnm')}\ndp = [[n] * len(index)]\nfor i in reversed(range(n)):\ncur = dp[-1][:]\ncur[index[s[i]]] = i\ndp.append(cur)\ndp = list(reversed(dp))\n\ndef sub(w):\nj = 0\nfor c in w:\nj = dp[j][index[c]] + 1\nif j > n:  # 没找着\nreturn False\n\nreturn True\n\nreturn sum(sub(w) for w in words)\n二分查找思路（利用 bisect_right 寻找指针右侧是否存在）\nclass Solution:\ndef numMatchingSubseq(self, s: str, words: List[str]) -> int:\npos = defaultdict(list)\nfor i, c in enumerate(s):\npos[c].append(i)\nans = len(words)\nfor w in words:\nif len(w) > len(s):\nans -= 1\ncontinue\np = -1\nfor c in w:\nps = pos[c]\nj = bisect_right(ps, p)\nif j == len(ps):\nans -= 1\nbreak\np = ps[j]\nreturn ans\n多指针思路\nclass Solution:\ndef numMatchingSubseq(self, s: str, words: List[str]) -> int:\np = defaultdict(list)\nfor i, w in enumerate(words):\np[w[0]].append((i, 0))\nans = 0\nfor c in s:\nq = p[c]\np[c] = []\nfor i, j in q:\nj += 1\nif j == len(words[i]):\nans += 1\nelse:\np[words[i][j]].append((i, j))\nreturn ans"}},"/tutorial/algorithm/category/others/7":{"title":"子数组","data":{"":"","6248-统计中位数为-k-的子数组#6248. 统计中位数为 K 的子数组":"K 是中位数，要求比 K 大的数和比 K 小的数相等或插值为 1容易理解的思路：先考虑单边有效的情况，再考虑双边有效的情况\nclass Solution:\ndef countSubarrays(self, nums: List[int], k: int) -> int:\nindex = nums.index(k)\nn = len(nums)\nans = 1  # 自身\nlmem = Counter()  # 右侧的不匹配的差值\nrmem = Counter()  # 左侧不匹配的差值\n\nc = 0\nfor i in range(index + 1, n):\nc += 1 if nums[i] > k else -1\nlmem[c] += 1\n\nc = 0\nfor i in reversed(range(index)):\nc += 1 if nums[i] > k else -1\nrmem[c] += 1\n\nans += lmem[0] + lmem[1] + rmem[0] + rmem[1]  # 单边有效\n\nfor k, cnt in rmem.items():  # 双边有效\nans += lmem[-k] * cnt\nans += lmem[1 - k] * cnt\n\nreturn ans\n简化版本\nclass Solution:\ndef countSubarrays(self, nums: List[int], k: int) -> int:\npos = nums.index(k)\ncnt = defaultdict(int)\nans = 1 # 自身\n\n# 右侧有效\nc = 0\nfor i in range(pos + 1, len(nums)):\nc += 1 if nums[i] > k else -1\ncnt[c] += 1\n\nans += cnt[0] + cnt[1]  # i=pos 的时候 c 是 0，直接加到答案中，这样下面不是大于就是小于\nc = 0\nfor i in range(pos - 1, -1, -1): # == reversed(range(index))\nc += 1 if nums[i] < k else -1 # 注意这里和上面的条件是相反的\nans += cnt[c] + cnt[c + 1]\nreturn ans"}},"/tutorial/algorithm/category/others/8":{"title":"找规律","data":{"":"","6-z-字形变换#6. Z 字形变换":"模拟 Z 字形即可。发现 Z 字形是上下来回移动追加字符串。\nclass Solution:\ndef convert(self, s: str, numRows: int) -> str:\nif numRows < 2: return s\nres = [\"\" for _ in range(numRows)]\ni, flag = 0, -1\nfor c in s:\nres[i] += c\nif i == 0 or i == numRows - 1: flag = -flag\ni += flag\nreturn \"\".join(res)","902-最大为-n-的数字组合#902. 最大为 N 的数字组合":"分成小于最高位数的和等于最高位数的两种情况各自讨论\nclass Solution:\ndef atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\nans = [1]\n\nn = str(n)\nsize = len(n)\ni = 1\nsub = len(digits)\n\n# 组合数位数小于 n，任意组合\nwhile i < size:\nans.append(sub)\nsub *= len(digits)\ni += 1\n\nsans = 0 # 同位 < n 的组合数\nsame = 1 #\nfor i in range(size):\ncount = 0\nfor j in digits:\nif j < n[i]: # 小于的情况，直接该组合 + 子组合数\nsans += ans[size - 1 - i]\nelif j == n[i]: # 等于的情况，该位下只可能有一种情况\ncount += 1\nsame &= count\nif same == 0:\nbreak\n\nreturn sum(ans) + sans + same - 1","2310-个位数字为-k-的整数之和#2310. 个位数字为 K 的整数之和":"个位数字限定，其实就是要求 num - K 的 N 倍 后可以被 10 整除。一些特殊情况讨论\n10 0 = 0 + (10)\n2 8 = -1\n8 2 = (2*4) + (0)\n\nclass Solution:\ndef minimumNumbers(self, num: int, k: int) -> int:\nif num == 0:\nreturn 0\n\nfor i in range(1, 11):\nif k * i <= num and (num - k * i) % 10 == 0:\nreturn i\n\nreturn -1","1328-破坏回文串#1328. 破坏回文串":"分规律讨论：\nlen <= 1 时，返回空字符串\n遍历一遍，将一开始的非 a 变成 a，变更后返回\n需要考虑一个边界条件：i 在中心时变更不会破坏回文，需要跳过\n\n\n将最后一个 a 变成 b，返回\n\n\nclass Solution:\ndef breakPalindrome(self, palindrome: str) -> str:\nif len(palindrome) <= 1:\nreturn \"\"\n\nfor i in range(len(palindrome)):\nif palindrome[i] == 'a':\ncontinue\nelse:\nif len(palindrome) % 2 == 1 and i == len(palindrome) // 2:\ncontinue\nreturn palindrome[:i] + 'a' + palindrome[i+1:]\n\nreturn palindrome[:-1] + 'b'","48-旋转图像#48. 旋转图像":"分析三阶和四阶矩阵，找一下旋转的 ij 变换规律即可\nclass Solution:\ndef rotate(self, matrix: List[List[int]]) -> None:\ndef rotate(i,j):\n(matrix[j][n-i-1],matrix[n-i-1][n-j-1],matrix[n-j-1][i],matrix[i][j]) = (\nmatrix[i][j], # 1\nmatrix[j][n-i-1], # 10\nmatrix[n-i-1][n-j-1], # 12\nmatrix[n-j-1][i] # 13\n)\n\nn = len(matrix)\nfor i in range(n//2):\nfor j in range(i,n-1-i):\nrotate(i,j)","13-罗马数字转整数#13. 罗马数字转整数":"","75-全局倒置与局部倒置#75. 全局倒置与局部倒置":"看起来是逆序对，但规律上不需要找出逆序对。因为所有局部倒置都是全局倒置，因此只需要找出一个非局部倒置即可。对任意 nums[i], i>0，令 pre = max(nums[:i-1])，一旦存在 pre < nums[i+1]，则存在非局部倒置，返回 False。\nclass Solution:\ndef isIdealPermutation(self, nums: List[int]) -> bool:\npre = nums[0]\nfor i in range(1,len(nums)-1):\npre = max(pre,nums[i-1])\nif pre > nums[i+1]:\nreturn False\nreturn True\n\n通过归纳法还有另一种通过归纳的解法，参考 LeetCode 官方题解","795-区间子数组个数#795. 区间子数组个数":"class Solution:\ndef numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:\nres = 0\nlast2 = last1 = -1\nfor i, x in enumerate(nums):\nif left <= x <= right:\nlast1 = i\nelif x > right:\nlast2 = i\nlast1 = -1\nif last1 != -1:\nres += last1 - last2\nreturn res"}},"/tutorial/algorithm/category/others/9":{"title":"排序","data":{"":"","快速排序#快速排序":"","快速选择#快速选择":""}},"/tutorial/algorithm/category/others":{"title":"Index","data":{"":""}},"/tutorial/algorithm/category/python-grammer/0":{"title":"set","data":{"":"","1684-统计一致字符串的数目#1684. 统计一致字符串的数目":"class Solution:\ndef countConsistentStrings(self, allowed: str, words: List[str]) -> int:\nb = set(allowed)\n\nans = 0\nfor word in words:\nif all([i in b for i in word]):\nans += 1\n\nreturn ans"}},"/tutorial/algorithm/category/python-grammer/1":{"title":"sorted","data":{"":"","1710-卡车上的最大单元数#1710. 卡车上的最大单元数":"class Solution:\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\nboxTypes = sorted(boxTypes,key=lambda x:x[1],reverse=True)\nans = 0\nfor cnt,c in boxTypes:\ncnt = min(truckSize,cnt)\nans += cnt * c\ntruckSize -= cnt\nif truckSize == 0:\nbreak\nreturn ans"}},"/tutorial/algorithm/category/python-grammer/2":{"title":"乘法","data":{"":"","1668-最大重复子字符串#1668. 最大重复子字符串":"class Solution:\ndef maxRepeating(self, sequence: str, word: str) -> int:\nans = 0\nwhile ans * word in sequence:\nans += 1\nans -= 1\nreturn ans\n复杂度 $O(mn)$ 的一版实现\nclass Solution:\ndef maxRepeating(self, sequence: str, word: str) -> int:\n\ndef check(i):\nc = 0\nwhile True:\nfor k in range(len(word)):\nif i >= len(sequence):\nreturn c\n\nif sequence[i] != word[k]:\nreturn c\ni+=1\nc+=1\nreturn c\n\nmax_v = 0\nfor i in range(len(sequence)):\nmax_v = max(max_v,check(i))\nreturn max_v"}},"/tutorial/algorithm/category/python-grammer/3":{"title":"位运算","data":{"":"","1832-判断句子是否为全字母句#1832. 判断句子是否为全字母句":"class Solution:\ndef checkIfPangram(self, sentence: str) -> bool:\nfor i in accumulate([1<< (ord(i)-ord('a')) for i in sentence],lambda i,j:i | j):\npass\nreturn i == 0b11111111111111111111111111\n还可以使用 collections.Counter\nclass Solution:\ndef checkIfPangram(self, sentence: str) -> bool:\nreturn len(Counter(sentence)) == 26"}},"/tutorial/algorithm/category/python-grammer/4":{"title":"迭代器","data":{"":"","1662-检查两个字符串数组是否相等#1662. 检查两个字符串数组是否相等":"充分利用迭代器特性\nclass Solution:\ndef arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\ndef flatten(lis):\nans = 0\nfor i in lis:\nyield from i\nans += len(i)\nyield ans\n\nfor i, j in zip(flatten(word1), flatten(word2)):\nif i != j:\nreturn False\n\nreturn True"}},"/tutorial/algorithm/category/python-grammer":{"title":"Index","data":{"":""}},"/tutorial/algorithm/category/tree/0":{"title":"1.树的遍历","data":{"":"","前序遍历#前序遍历":"前序遍历 Leetcode-144\n\n递归写法\nclass Solution:\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\nstack = [root]\nres = []\n\ndef iter(cur):\nif cur is None:\nreturn\nres.append(cur.val)\niter(cur.left)\niter(cur.right)\niter(root)\nreturn res\n非递归写法\nclass Solution:\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\nstack = [root]\nres = []\nwhile stack:\ncur = stack.pop()\nif cur is None:\ncontinue\n\nres.append(cur.val)\n\nstack.append(cur.right)\nstack.append(cur.left)\n\nreturn res","中序遍历#中序遍历":"中序遍历 Leetcode-94\n\n递归写法\nclass Solution:\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n\nres = []\ndef iter(cur):\nif cur is None:\nreturn\niter(cur.left)\nres.append(cur.val)\niter(cur.right)\n\niter(root)\nreturn res\n非递归写法\nclass Solution:\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\nstack = [(root,False)]\nres = []\n\nwhile stack :\ncur,visited = stack.pop()\nif cur is None:\ncontinue\n\nif visited:\nres.append(cur.val)\nelse:\nstack.append((cur.right,False))\nstack.append((cur,True))\nstack.append((cur.left,False))\n\nreturn res","后序遍历#后序遍历":"后序遍历 Leetcode-145\n\n递归写法\nclass Solution:\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n\nres = []\ndef iter(cur):\nif cur is None:\nreturn\niter(cur.left)\niter(cur.right)\nres.append(cur.val)\n\niter(root)\nreturn res\n非递归写法\nclass Solution:\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n\nstack = [(root,False)]\nres = []\nwhile stack:\ncur,visited = stack.pop()\nif cur is None:\ncontinue\n\nif visited:\nres.append(cur.val)\nelse:\nstack.append((cur,True))\nstack.append((cur.right,False))\nstack.append((cur.left,False))\n\nreturn res"}},"/tutorial/algorithm/category/tree/1":{"title":"2.二叉搜索树","data":{"":"特性：\n中序遍历是有序的\n左子树所有节点小于父节点，右子树所有节点大于父节点，该特性是递归的（一般算法题中不存在重复元素）\n\n相关题\n96. 不同的二叉搜索树\n\n\n# dp[N+1]\n# 记忆化搜索\nclass Solution:\ndef numTrees(self, n: int) -> int:\ndp = [0] * (n+1)\ndp[0] = 1\ndp[1] = 1\n\ndef dfs(n): # 返回 n 个节点的树的可能个数\nif dp[n] > 0:\nreturn dp[n]\n\n# n >= 2\nans = 0\nfor i in range(n): # 选中其中一个作为根节点后总情况数是 左子树的情况 * 右子树的情况\nans += dfs(i)*dfs(n-i-1)\ndp[n] = ans\nreturn ans\nreturn dfs(n)\n\n95. 不同的二叉搜索树 II\n\n\nclass Solution:\ndef generateTrees(self, n: int) -> List[Optional[TreeNode]]:\n# dfs 返回的是 [l,r] 的所有树的可能情况\ndef dfs(l,r):\nif l > r: # 左大于右，不存在\nreturn [None]\n\nif l == r: # 相等，单节点树\nreturn [TreeNode(l)]\n\nres = []\nfor i in range(l,r+1): # 以 i 为根节点\nleft = dfs(l,i-1) # i 的左子树\nright = dfs(i+1,r) # i 的右子树\nfor lsub in left: # 二重循环构建所有子树情况\nfor rsub in right:\nres.append(TreeNode(i,lsub,rsub))\nreturn res\nreturn dfs(1,n)","110-平衡二叉树#110. 平衡二叉树":"class Solution:\ndef isBalanced(self, root: Optional[TreeNode]) -> bool:\ndef height(root):\nif root is None:\nreturn 0\n\nlh,rh = height(root.left),height(root.right)\n\nif abs(lh-rh) > 1 or lh == -1 or rh == -1:\nreturn -1\n\nreturn max(lh,rh) + 1\n\nreturn height(root) >=0","avl-树#AVL 树":"","红黑树#红黑树":""}},"/tutorial/algorithm/category/tree/2":{"title":"3.红黑树","data":{"":"2-3-4 树\n2-3-4 树是四阶的 B 树(Balance Tree)，他属于一种多路查找树，它的结构有以下限制：所有叶子节点都拥有相同的深度\n节点只能是 2-节点（包含 1 个元素的节点，有 2 个子节点）、3-节点（包含 2 个元素的节点，有 3 个子节点）、4-节点（包含 3 个元素的节点，有 4 个子节点）之一\n所有节点必须至少包含 1 个元素\n元素始终保持排序顺序，整体上保持二叉查找树的性质，即父结点大于左子结点，小于右子结点。而且结点有多个元素时，每个元素必须大于它左边的和它的左子树中元素\nhttps://blog.csdn.net/m0_53199081/article/details/121629548\nhttps://www.jianshu.com/p/e136ec79235c\nJDK 1.8 后 HashMap 的红黑树（桶的树型化）\nhttps://blog.csdn.net/wushiwude/article/details/75331926"}},"/tutorial/algorithm/category/tree":{"title":"Index","data":{"":""}},"/tutorial/algorithm":{"title":"index","data":{"":""}},"/tutorial/algorithm/leetcode/0":{"title":"1752","data":{"":"","1752-检查数组是否经排序和轮转得到#1752. 检查数组是否经排序和轮转得到":"class Solution {\npublic:\nbool check(vector<int>& nums) {\nint n = nums.size();\nint cnt = 0;\nfor(int i = 0;i< n*2; i++ ){\nif(nums[i % n] > nums[(i+1) % n]){\n++cnt;\n}\n}\nreturn cnt <= 2;\n}\n};\n\nclass Solution:\ndef check(self, nums: List[int]) -> bool:\ncnt = 0\nn = len(nums)\nfor i in range(len(nums) * 2):\nif nums[i % n] > nums[(i + 1) % n]:\ncnt += 1\n\nreturn cnt <= 2"}},"/tutorial/algorithm/leetcode/1":{"title":"1812","data":{"":"class Solution {\npublic:\nbool squareIsWhite(string coordinates) {\nreturn ((coordinates[0] - 'a') + (coordinates[1] - '1')) % 2;\n}\n};\n\nclass Solution {\npublic:\nbool squareIsWhite(string coordinates) {\nreturn (coordinates[0]+coordinates[1]) & 1;\n}\n};"}},"/tutorial/algorithm/leetcode/2":{"title":"1827","data":{"":"","1827-最少操作使数组递增#1827. 最少操作使数组递增":"class Solution:\ndef minOperations(self, nums: List[int]) -> int:\nans = 0\npre = nums[0] - 1\n\nfor i in nums:\npre = max(i,pre+1)\nans += pre - i\nreturn ans"}},"/tutorial/algorithm/leetcode/3":{"title":"882","data":{"":"","882-细分图中的可到达节点#882. 细分图中的可到达节点":"class Solution {\npublic:\nint reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {\nvector<vector<pair<int,int>>> g(n,vector<pair<int,int>>());\nfor(auto &i:edges){\ng[i[0]].push_back({i[1],i[2]});\ng[i[1]].push_back({i[0],i[2]});\n}\n\nvector<int> dist(n,1e6);\ndist[0] = 0;\nunordered_map<int,int> remain;\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> q;\nq.push({0,0});\n\nint ans = 0;\nwhile (!q.empty() && q.top().first <= maxMoves){\nint cost = q.top().first,x = q.top().second;\nq.pop();\nif(cost > dist[x]){\ncontinue;\n}\n\n++ans;\nremain[x] = max(remain[x],maxMoves - cost);\n\nfor(auto i:g[x]){\nint d = cost + i.second + 1;\nif(d < dist[i.first]){\ndist[i.first] = d;\nq.push({d,i.first});\n}\n}\n}\n\nfor(auto &i:edges){\nans += min(i[2],remain[i[0]]+remain[i[1]]);\n}\nreturn ans;\n}\n};\n\nclass Solution:\ndef reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\ng = [[] for i in range(n)]\nremain = {}\n\nfor i,j,cnt in edges:\ng[i].append([j,cnt])\ng[j].append([i,cnt])\n\ndist = [float('inf')] * n\ndist[0] = 0\n\nq = [(0,0)]\n\nans = 0\nwhile q and q[0][0] <= maxMoves:\n# 选一个当前 0-x 距离最小的\n(cost,x) = heappop(q)\nif dist[x] < cost:\ncontinue\nprint(cost,x,dist[x])\n# q 本质上最多每个结点遍历一遍\n# while 条件 q[0][0] <= maxMoves，保证了该节点有效可到达\nans += 1\n\n# 记录 x->y 时还剩下的最大步数\n# 到 x 的最大剩余步数\nremain[x] = max(maxMoves - cost,remain.get(x,0))\n\nfor j,cnt in g[x]:\nd = cost + cnt + 1\nif d < dist[j]:\ndist[j] = d\nheappush(q,(d, j))\n\n# 遍历获取，可以在遍历 q 时一步到位\n# for i in range(n):\n#     if dist[i] <= maxMoves:\n#         ans += 1\n\nfor i,j,cnt in edges:\nans += min(cnt, remain.get(j,0) + remain.get(i,0))\n# print(ans,min(cnt, remain.get(j,0) + remain.get(i,0)))\n# print(i,j,remain.get(i),remain.get(j))\nreturn ans"}},"/tutorial/algorithm/leetcode/4":{"title":"895","data":{"":"","895-最大频率栈#895. 最大频率栈":"","优先级队列解法#优先级队列解法":"class FreqStack:\ndef __init__(self):\nself.cnt = Counter()\nself.heap = []\nself.index = 0\n\ndef push(self, val: int) -> None:\nself.cnt[val] += 1\nheappush(self.heap, (-self.cnt[val],self.index,val))\nself.index -= 1\n\ndef pop(self) -> int:\ncnt,ind,val = heappop(self.heap)\nself.cnt[val] -= 1\nreturn val\n\nclass FreqStack {\npublic:\nFreqStack() {\n}\n\nvoid push(int val) {\ntuple<int,int,int> res = {++cnt[val],++index,val};\nq.push(res);\n}\n\nint pop() {\nint val = get<2>(q.top());q.pop();\n--cnt[val];\nreturn val;\n}\nprivate:\nunordered_map<int,int> cnt;\npriority_queue<tuple<int,int,int>> q;\nint index = 0;\n};","双哈希表#双哈希表":"双哈希表"}},"/tutorial/algorithm/leetcode":{"title":"Index","data":{"":""}},"/tutorial/algorithm/others/0":{"title":"美团笔试题血怒记录","data":{"":"一个卡牌游戏，游戏中初始攻击力为 1，有两种卡牌，使用祝福每次攻击力 + 1，使用血怒让当前攻击力减半（向下取整），但让下次祝福的攻击力增益多 1 点。现在，按顺序给定一个卡牌序列，对每张卡牌可以选择是否使用。求最终能达到的最大攻击力。序列长度在 [1,10000]令 mem[j] 为 i 价值时存储的最大攻击力数值，每个卡牌遍历更新一遍 mem。复杂度 $O(N^2)$\ndef solve2(m):\nn = len(m)\nmem = defaultdict(int)\nmem[0] = 1\n\nans = 0\nfor i in range(n):\nfor k, v in list(mem.items()):\nif m[i] == 0:\nmem[k + v] = max(mem[k + v], v)\nans = max(k + v, ans)\nelse:\nmem[k // 2] = max(mem[k // 2], v + 1)\nreturn ans\n\nrandom.seed(1)\nfor j in range(1000):\nseq = [0] * j + [1] * (1000 - j)\nrandom.shuffle(seq)\nsolve2(seq)"}},"/tutorial/algorithm/others":{"title":"Index","data":{"":""}},"/tutorial/chrome-extension/0":{"title":"css","data":{"":"在 popup 和 option 中应用样式，在相应的 html 页面的 head 下添加样式声明即可：\n<link rel=\"stylesheet\" type=\"text/css\" href=\"output.css\" />"}},"/tutorial/chrome-extension/1":{"title":"option_ui 和 option_page 的区别","data":{"":"options_page 可以直接打开一个扩展网页\n{\n\"name\": \"My extension\",\n...\n\"options_page\": \"options.html\",\n...\n}\noptions_ui 则更类似 popup\n{\n\"name\": \"My extension\",\n...\n\"options_ui\": {\n\"page\": \"options.html\",\n\"open_in_tab\": false\n},\n...\n}\n\nhttps://developer.chrome.com/docs/extensions/mv3/options/"}},"/tutorial/chrome-extension/2":{"title":"storage","data":{"":"local：本地存储，限制为 5 MB，但可以通过添加 unlimitedStorage 权限取消大小限制\nsync：同步存储，总大小 100KB，单个 item 大小 8KB。 The quota limitation is 100 KB approx, 8 KB per item.\nsession：in-memory，不保存在硬盘中\n\nStorage 只能通过键值对存取，没有检索功能：\nchrome.storage.local.set({ key: value }).then(() => {\nconsole.log(\"Value is set to \" + value);\n});\n\nchrome.storage.local.get([\"key\"]).then((result) => {\nconsole.log(\"Value currently is \" + result.key);\n});\n\n\nchrome.storage.sync.set({ key: value }).then(() => {\nconsole.log(\"Value is set to \" + value);\n});\n\nchrome.storage.session.set({ key: value }).then(() => {\nconsole.log(\"Value is set to \" + value);\n});\n但是有回调函数，可以在值更改时接到通知：\nchrome.storage.onChanged.addListener(\ncallback: function,\n)\n\nhttps://developer.chrome.com/docs/extensions/reference/storage/#event-onChanged"}},"/tutorial/chrome-extension/3-a2c-2023-04-13-3":{"title":"基础","data":{"":"Chrome 的插件环境"}},"/tutorial/chrome-extension/4-1ad-2023-04-13-4":{"title":"sendMessage","data":{"":"sendMessage 有两种方式，一种是 content script 向 background 发送消息，一种 background 向 content script 发送消息。开发过程中要注意的点包括:\n只能两方通讯，一次 sendMessage 未结束不能调用另一个 sendMessage，否则先 sendMessage 的 sender 会接受不到回复的消息（应该是出于安全考虑）"}},"/tutorial/chrome-extension":{"title":"Index","data":{"":""}},"/tutorial/computer-network/0":{"title":"0.总述","data":{"":"TCP/IP 协议是事实上的传输协议标准。自顶向下分为应用层、传输层、网络层和数据链路层，每一层有不同的功能和协议。各个层可以看成是由小到大，由局部到完整的定义了一个物流系统。\n链路层可以再分为物理层和数据链路层。\n物理层向同层的设备建立物理连接、发送和接收模拟信号并转换为数字信号，向上传递给数据链路层；接受数据链路层的帧数据，按比特转换为模拟信号传递给目标物理层设备。（这一步是广播还是单播？）\n数据链路层由上到下接受网络层的数据，装帧后传递给下层的物理层；接收来自物理层的数字信号，成帧、校验后解帧传递给上层网络层。\n\n\n网络层由上到下通过 IP 协议、ARP 协议获得目标设备的 MAC 地址，通过路由协议选择合适的路径写入链路层；由下到上接收链路层的数据，封包后传递给上层的传输层。\nIP 协议：定义逻辑地址（Ip 地址）\nARP 协议：通过 IP 地址获取 Mac 地址\n路由协议：选择合适的路径转发数据包\n\n\n传输层由上到下将 UDP 协议和 TCP 协议中定义的数据格式写入到网络层；由下到上接收网络层的数据，组成 UDP 和 TCP 协议封包的格式，并通过预先标识好的端口传递给上层的应用层（具体的应用程序）。\nTCP 协议：面向连接的数据流协议\nUDP 协议：面向无连接的数据包协议\n\n\n应用层定义数据格式、目标机器和目标端口，由上到下写入传输层；绑定监听端口，由下到上接受来自传输层的协议封包并解包为应用层需要的数据格式。常见数据格式和传输协议的包括\nHTTP 协议：超文本传输协议\nDNS 协议：负责域名解析\nFTP 协议\n...","数据封装#数据封装":"物理层\n数据链路层\n网络层\n传输层\n会话层\n表示层\n应用层\n\nhttp://arthurchiao.art/blog/rfc1180-a-tcp-ip-tutorial-zh/"}},"/tutorial/computer-network/1":{"title":"1.链路层","data":{"":"链路层可以进一步细分为物理层和数据链路层解决两台物理机之间二进制比特流的通信/传输。也即解决模拟信号和数字信号之间的相互转换问题。物理层的设备包括各种传输介质、调制解调器","差错控制#差错控制":"差错检测和纠正","流量控制#流量控制":"捎带确认\n滑动窗口协议","ppp-协议#PPP 协议":"https://www.zhihu.com/question/23939177/answer/129836905\nPPP 协议用于有线全双工的点对点通信，该协议定义了链路层的一种帧的结构和一种点对点链路之间建立通信和传输数据的方式。PPP 链路操作包含五种状态：\n链路不可用（Link Dead）\n链路建立（Link Establishment Phase）：交换配置包（Configure Packets）建立连接。\n认证阶段（Authentication Phase）：通过 PAP 或 CHAP 两种方式对链接进行认证\n网络层协议阶段（Network Layer Protocol Phase）\n链接终止阶段（Link Termination Phase）\n\n\nPPP 协议已不是纯粹的数据链路层的协议，还包含了物理层和网络层的内容。","帧类型#帧类型":"有线通信：802.3/Ethernet_V2\n无线通信：802.11"}},"/tutorial/computer-network/10":{"title":"4.应用层","data":{"":"DNS 是一种应用层协议。用于域名解析功能。主要有区域传送（同步）和域名解析两个操作。","一次查询-dns-的过程#一次查询 DNS 的过程":"DNS 查询经历客户端->本地 DNS 服务器->外网 DNS 服务器三个流程，分递归和迭代两个部分。\n递归：客户端只发一次请求给本地 DNS 服务器，要求本地 DNS 服务器给出最终结果（IP 地址或出错）。\n迭代：本地 DNS 服务器检查自身缓存不存在后，从根域名服务器出发，发送请求报文，要求返回下一级域名服务器的地址或域名的 IP 地址。","dns-服务器之间如何选择-or-同步#DNS 服务器之间如何选择 or 同步":"","dns-通过哪些传输层协议解析-ip-地址#DNS 通过哪些传输层协议解析 IP 地址？":"DNS 占用 53 号端口，同时使用 TCP 和 UDP 协议。\n区域传送时使用 TCP，主要有一下两点考虑：\n辅域名服务器会定时（一般时 3 小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用 TCP 而不是 UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。\nTCP 是一种可靠的连接，保证了数据的准确性。\n\n\n域名解析时，因为返回的内容很短，为了减少请求负担，使得相应更快，一般使用 UDP 协议\n\n\nhttps://www.cnblogs.com/wuyepeng/p/9835839.html","dns-劫持#DNS 劫持":"DNS 劫持指在域名解析的过程中，返回了错误的 IP，从而进入了伪造的 DNS 服务器。见 4.1 RPC 协议见 4.2 DHCP 协议"}},"/tutorial/computer-network/11":{"title":"5.总结与辨析","data":{"":"拥塞的具体原因包括：\n节点存储容量（缓冲区）不够\n处理机速度太低\n线路容量（带宽）不够\n\n在不同的模型层，都需要在一定程度上解决该问题\n在数据链路层，实现的是点对点的通信，双方缓冲区的大小根据滑动窗口协议而定\n传输层实现的是端到端的通信，某一时刻，一台主机可能同时与多台主机建立了连接，多个连接必须有多组缓冲区，所以缓冲区的动态分配和管理策略与数据链路层相比较要复杂得多\n网络层直接面临拥塞（和链路层、传输层只在数据两端感受拥塞的结果不同），该层的拥塞控制由慢（预防性）到快（反应性）可以采用以下策略：\n网络供给\n流量感知路由\n准入控制：不再建立新的虚电路（虚电路：一条端到端的连接）\n流量限制：\n负载脱落：直接丢包\n\n\n\n\nhttps://blog.csdn.net/gao1440156051/article/details/9122207\n为了避免数据的传输不出错，会：\n通过带序确认和超时重传保证数据传递有序、不丢失、不重复\n通过校验和保证数据不出错。\n\n在链路层、网络层、传输层中需要差错控制。\n链路层保证帧的可靠性，通过循环冗余检验 CRC 进行差错校验，如果出错就丢包\n网络层保证 IP 协议中头部的可靠性，通过头部校验和保证 IP 数据报无误（比特的准确性由链路层保证）\n传输层保证通过观察数据是否未收到，对底层进行确认和重传两个操作（只针对 TCP、UDP 不考虑重传）","单播#单播":"链路层上的单播发生在任意两个有物理连接的设备（假设为 A - B）之间，在设备 A 上封帧，帧头包含源地址（A 设备 MAC 地址）和目的地址（B 设备 MAC 地址），即可将帧发送到 B 设备。\n网络层上的单播发生在任意两个有逻辑连接的设备之间。假设连接为 A-B-C，从 A 发送 IP 数据包到 C，会依次经过\nDNS 解析（根据域名解析 C 的 IP 地址，如果已经得知，可以忽略）\n建立连接（TCP 协议要求，UDP 可略）\n发送 IP 数据报，数据报通过下层链路层，ARP 协议、路由算法，经过多跳发送到目标设备（C）上。","广播#广播":"链路层上的广播通过将目的 MAC 地址设置为全 1 实现。因为路由器不转发目的地址是广播地址的数据报，所以链路层广播只发生在本地网络（局域网）中。\n网络层上的广播通过将主机号对应的位设置全 1 实现。虽然是在网络层上广播，但是一般情况下广播只会发生在本地网络中，所以也称网络层上的广播为受限广播。\n\n? 虽然网络层上也可以设置广播，但广播的 IP 数据报一般也只是在局域网内传递，在网关处会被阻拦（除非路由器做了其他判断）。\n参考 https://www.zhihu.com/question/20643350/answer/112565403, https://www.zhihu.com/question/20643350/answer/112565403","组播igmp-协议#组播（IGMP 协议）":"组播（multicast）也叫多播。\nhttps://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE\nIGMP（Internet Group Management Protocol，互联网组管理协议），用于组播。客户端视角：\n域名 DNS 解析\n依次从浏览器缓存、本地 DNS 服务器缓存、DNS 服务器中取 IP\n\n\n建立 TCP 连接，从服务器接收数据\n发送/接收无连接的 UDP 数据报\n浏览器解析数据，渲染页面\n\n服务端视角：\n接受来自客户端的请求\n（可选）负载均衡\n请求资源判断是否有权限，返回相应条件下的结果（和在服务端进行各种处理）\n\n操作系统视角：\n接收来自浏览器的软中断，执行系统调用，建立 socket 返回给上层应用\n通过 socket 和目标机器（服务器）进行 IO\ninput: 当网卡产生硬中断时，从网卡接收数据\noutput: 从 socket 获取的数据写入到网卡中\n\n\n\n\n路由表建立了当前设备中目的 IP 地址到下一跳地址的映射，用于网络层在网络间的转发，需要配合 ARP 表的使用\nARP 表建立了 IP 地址到 MAC 地址的映射，用于网络层向下注入到链路层\nMac 表建立了 Mac 地址到端口的映射，用于链路层内局域网下的转发"}},"/tutorial/computer-network/12":{"title":"6.1常见的安全问题","data":{"":"本节介绍一些常见网络攻击手段和安全问题","arp-欺骗#ARP 欺骗":"","中间人攻击#中间人攻击":"","tcp-粘包#TCP 粘包":"","dos-攻击#Dos 攻击":"","syn-攻击#SYN 攻击":"SYN 洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。防范：\n通过防火墙、路由器等过滤网关防护。\n通过加固 TCP/IP 协议栈防范，如增加最大半连接数，缩短超时时间。\nSYN cookies 技术，略。","ddos-攻击#DDos 攻击":""}},"/tutorial/computer-network/13":{"title":"6.2.常用命令","data":{"":"","linux#Linux":"lsof -i:xxxx","chrome#Chrome":"chrome://net-internals/#dns","linux-1#Linux":"https://unix.stackexchange.com/questions/28553/how-to-read-the-local-dns-cache-contents","macos#MacOs":"https://stackoverflow.com/questions/38867905/how-to-view-dns-cache-in-osx\n\nlog stream --predicate 'process == \"mDNSResponder\"' --info","windows#Windows":"命令输出\nipconfig /displaydns\n查看 Host 文件\nC:\\Windows\\System32\\drivers\\etc\\host"}},"/tutorial/computer-network/14":{"title":"6.3.硬件设备","data":{"":"调制解调器：猫，链路层设备，用于在数字信号和模拟信号之间进行转换\n交换机：链路层设备，交换机内部的 CPU 会在每个端口成功连接时，通过将 MAC 地址和端口对应，形成一张 MAC 表。交换机只能连接两个网络。\n路由器：网络层设备，内部维护路由表和 ARP 表，可以连接多个网络，选择最优的转发路径。"}},"/tutorial/computer-network/15":{"title":"6.4.软件服务","data":{"":"httpd 可以返回静态资源，也可以支持 cgi 和 wsgi（wsgi 需要模块插件支持）cgi（Common Gateway Interface） 和 wsgi（Web Server Gateway Interface）都是用于 web 服务的底层入口。\ndef application(environ, start_response):\nstart_response('200 OK', [('Content-Type', 'text/html')])\nreturn [b'<h1>Hello, web!</h1>']\nDjango 和 Flask 最终的入口都是一个 WSGI 处理函数。HTTP 请求的所有输入信息都可以通过 environ 获得，HTTP 响应的输出都可以通过 start_response()加上函数返回值作为 Body。复杂的 Web 应用程序，光靠一个 WSGI 函数来处理还是太底层了，我们需要在 WSGI 之上再抽象出 Web 框架，进一步简化 Web 开发。\nwsgi：https://www.liaoxuefeng.com/wiki/1016959663602400/1017805733037760"}},"/tutorial/computer-network/16":{"title":"6.其他常识","data":{"":"当主机收到广播报文时，网卡会产生一次硬件中断 CPU，CPU 会暂停手头的工作来处理这个中断，处理完中断，CPU 继续工作。IP 协议栈取走数据Cookie 指服务端发送并存储在客户端的一部分数据。用于网站个性化、Session 存储等。Session 指一次服务端和客户端对话的过程，用于记录用户的某些操作，用户的登录状态等。Session 的时长由服务端开发者决定，可以在网页关闭后关闭会话（如一些银行网站），也可以长期保存（如 Github）。","分布式-session-管理#分布式 Session 管理":"服务端采用分布式服务时，Session 如果只保存在一台服务端设备上，当用户请求被分流到另一台设备时候该 Session 就会失效。常见的解决方法有：\n使用 Cookie 保存 Session 关键字段\nSession 复制：将每个 Session 同步到所有服务端设备上（不推荐）\n统一 Session 管理：利用 Redis 等数据库统一的管理 Session，保证每台设备的 Session 一致性。"}},"/tutorial/computer-network/17":{"title":"README","data":{"":"链路层\n路由协议\nTCP 拥塞避免和流量控制\n\n\n谢希仁《计算机网络》第七版\n《TCP/IP 协议及其应用》\n《Linux 内核之旅》第十二章 网络\nhttps://github.com/cosen1024/Java-Interview/\n其余参考了博客的部份在文稿中均附有相应链接"}},"/tutorial/computer-network/2":{"title":"2.1.IP协议","data":{"":"RFC-791 中描述了 IP 协议","地址表示#地址表示":"IP 协议用 4 个字节（32 个 bit 位）表示，所以 IP 协议可以表示是地址空间总共有 $2^32$ 个。在表示地址时每个字节转换为 10 进制数字，并用 . 分开：\n0.0.0.0\n192.168.1.1\n...\n255.255.255.255","特殊的-ip-地址#特殊的 IP 地址":"127.0.0.1： 是本地回环地址，所以网络号是 127 的地址不是网络地址。\n主机号全 0：表示该主机所在的网络地址\n主机号全 1：表示该网络上的所有主机（用于广播）\n10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/24：用于局域网内通信\n255.255.255.255：在本网络下进行广播（路由器不转发）\n网络号全 0，主机号全 1：本网络下的主机\n\n其他被占用的 IP 地址可以参考wiki-保留 IP 地址","ip-地址指派范围#IP 地址指派范围":"在排除了特殊 IP 地址后，IP 地址的指派范围如下：\n主机号数量都为相应的主机位 -2，因为要排除全 0 和全 1 的主机地址\n网络号要排除全零、全 1、127.0.0.0,128.0.0.0,192.0.0.0，所以 A 类地址的网络号少 2 个（全 0 和 127.0.0.0），B（缺 128.0.0.0） 和 C（缺 192.0.0.0） 的网络号少 1 个","子网掩码#子网掩码":"子网掩码一般保存在有路由功能的设备的路由表中。子网掩码的功能包括：\n判断两个 ip 是否处于同一网段\n在一个主干网络内部划分多个子网络（每个网络可以看成是单独的局域网）\n\n因为每个子网都避免了使用主机号全 0 和全 1 作为主机 ip，所以划分子网后能连接在网络上的主机总数要小于划分前的主机总数。","ip-编址#IP 编址":"IP 编址的目的是为了更方便的将 IP 地址批量分配给机构、企业","分类的-ip-地址#分类的 IP 地址":"分类的 IP 地址是最基本的编址方法，将 IP 地址表示为 <网络号>,<主机号>。在这种表示下，每一个网络号是唯一的，每个网络号下的主机号可以是不唯一的。因此在机构或者个人申请 IP 地址时，会分配一个互联网范围内唯一的网络号，再由机构/个人给下属的不同设备分配网络号内唯一的主机号。根据机构/个人对主机号需求的不同，将 IP 地址分为 ABC 三类地址，再加上用于多播和其他需求的地址，一共有 5 类地址。在上图中，网络号前 n 位被用于表示 IP 地址类型。其中 A-C 分别占 1/2/3 个比特位，D/E 占 4 个比特位。","无分类编址-cidr#无分类编址 CIDR":"无分类编址方法可以看成是分类编址方法的超集，该方法优化了子网掩码的表示方式，通过<全地址>/<网络前缀位数>来表示网络前缀的位数。如\n192.199.170.82/27\n通过 CIDR，可以将多个传统分类地址聚合成一个前缀位数更少的超网，从而大幅度减少路由表项的数量。CIDR 也可以通过在子路由器增加前缀位数来划分子网"}},"/tutorial/computer-network/3":{"title":"2.2.ICMP协议","data":{"":"ICMP（Internet Control Message Protocol，互联网控制消息协议）在 RFC-792 中提出。允许主机或路由器报告差错情况和提供有关异常的报告。即 ping 命令发送的数据包内容。关于报文的类型，可以参考wiki-互联网控制消息协议#报文类型ICMP 协议处于网络层中，但是该协议的报文实际装在 IP 数据报中，作为 IP 数据报的数据部份。ICMP 的报文有差错报告报文和询问报文两种。","差错报告报文#差错报告报文":"[ ]","询问报文#询问报文":"[ ]"}},"/tutorial/computer-network/4":{"title":"2.3.路由算法","data":{"":"","内部网关算法-rip#内部网关算法 RIP":"[ ]","内部网关算法-ospf#内部网关算法 OSPF":"[ ]","外部网关协议-bgp#外部网关协议 BGP":"[ ]"}},"/tutorial/computer-network/5":{"title":"2.网络层","data":{"":"网络层上看不到来自链路层的帧，所有网络层处理的数据形式都为网络层协议定义的数据形式。（链路层会将数据解帧后传递给网络层）。网络层和链路层的主要区别在：\n网络层定义了逻辑上的地址，链路层定义了物理上的地址。\n链路层解决了两个存在物理连接的设备之间的传输问题。网络层解决了两个存在逻辑链接（通过多个物理设备后有链接）的设备之间的传输问题。\n网络层发送的 IP 数据包的源地址和目的地址在传输到目标设备前不会变，而在数据包注入到下层链路层后，帧的 MAC 地址会一直随着两台物理设备进行更改。\n\n最后，ARP 和 RARP 协议建立从 IP 地址对应的 虚电路 到实际物理电路的映射关系，使得上述描述的信息传递过程能够最终实现。一个路由表中存储着一个数据集和，每一条记录主要包含 目的网络地址, 子网掩码, 下一跳地址 三个信息。\n此外还有其他元数据，如参考计数、使用情况、标志，用于拥塞控制等算法。\n路由器转发分组的算法如下：\n从 IP 数据报中提取目的地址 D；\n对路由器直接相连的网络进行子网掩码的判断。具体是将各个网络的子网掩码和 D 相与求出网络号，判断网络地址和 D 的网络号是否匹配。如果存在匹配的网络则直接交付给该网络；\n如果不匹配，但路由表中有目的地址为 D 的特定主机路由，则交付给该路由记录（目的地址，子网掩码，下一跳地址）中指明的下一跳路由器；\n如果不存在特定主机路由，则逐个对路由表中的每一项进行子网掩码匹配的过程，如果存在匹配的记录则交付给记录中指明的下一跳路由器；\n如果均不匹配，但路由表中有默认路由，则转发给默认路由；\n如果不存在默认路由，报告转发分组出错。\n\n路由表上的记录需要保证能将任意设备上的 IP 数据报转发给任意的目的主机（可以通过多次间接交付）。为了将路由器中路由表项的数量维持在一定规模内，网络层的各个协议都对此进行了优化，这包括：\n路由表指记录到目标网络的转发路径，而不记录到具体主机的转发路径\n对 IP 地址划分的优化（如 CIDR）\n尽可能理想的路由算法，见2.3 路由算法\n\nIP 协议是一种网络层协议，用于给每台设备定义一个逻辑上的唯一地址。在网络层的报文只能看到 IP 地址。详见 2.1 IP 协议ARP（Address Resolution Protocol，地址解析协议） 是一种网络层协议。该协议通过解析网络层地址来找寻数据链路层地址。由于网络层只能看到目标机器的 IP 地址，而无法得知目标机器的 Mac 地址，因此当数据包从网络层注入到链路层时，就需要知道数据应该向哪个路由传输。此时 ARP 协议会构建一个包含了目标机器 IP 地址的数据包广播出去，每个路由都会接收到。当通向目标机器的路由接收到这个广播包后，就会响应该 ARP 请求。ARP 的请求和相应中都会包括源机器的 IP 和 MAC 和目标机器的 IP 和 MAC 这四个字段，但在请求中，目标机器的 MAC 字段是全 0 ，表示留空。\nhttps://zhuanlan.zhihu.com/p/28771785 > https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE\n\n基于功能来考虑，ARP 是链路层协议（因为功能是获取 Mac 地址，用于链路层）；基于分层/包封装来考虑，ARP 是网络层协议。（此方法对于 ICMP 协议同样管用）\n见 2.2 ICMP 协议"}},"/tutorial/computer-network/6":{"title":"3.传输层","data":{"":"TCP 是一种面向连接的数据流协议，位于传输层。面向连接指的是 A 和 B 之间的数据传输是稳定不会出错的，数据流表示数据可以被细粒度的拆分和组装（见下文 TCP 实例）。","tcp-连接三次握手过程#TCP 连接三次握手过程":"TCP 建立连接的过程是让客户端和服务端都处于 Established（已建立）状态的过程，Established 表示该端确认了自身的接收和发送能力均正常（可以正常 IO）。建立连接的过程一共会产生三种报文，可以通过 SYN 位、ACK 位和 Seq 位（一个随机数）来区分。\n第一次握手，客户端发送 SYN=1，ACK=0，Seq=x，客户端发送后处于 SYN_SENT 状态，服务端接受后处于 SYN_RECV 状态，此时客户端无法确认 IO 能力，服务端无法完全确认自身的 IO 状态（只能知道服务端接收正常和客户端发送正常）。\n第二次握手：服务端返回 SYN=1，ACK=x+1，Seq=y，服务端回复第一次请求，发送后服务端状态不变，客户端接收后处于 Established 状态，此时客户端能确认自身的 IO 状态正常。\n第三次握手：客户端再发送 ACK=y+1，Seq=x+1，服务端接受后处于 Established 状态，此时服务端能确认自身的 IO 状态正常。\n\n真正的数据从第四个报文开始。\n其实也可以直接在第三次握手中发送数据，但一般的封装库并不提供这种方式（没必要这么着急），详见这篇文章\n连接建立后，如果上层协议一直不发送数据，服务端可以通过可选的 KeepAlive 机制（发一个空报文给对方确保对方在线）进行检查。","tcp-连接释放四次挥手过程#TCP 连接释放四次挥手过程":"在结束连接时，双方逐步释放自己的读写功能。\n第一次挥手：客户端发送 FIN=1，ACK=1，表明客户端无数据要发送\n第二次挥手：服务端发送 ACK=1\n第三次挥手：服务端二次发送 FIN=1，ACK=1，表明服务端无数据要发送，此时服务端确认双方都不需要读写，直接关闭连接。\n第四次挥手：客户端二次发送 ACK=1，确认双方都不需要读写。在等待 2*MSL（最长报文段寿命）后，关闭连接","第四次挥手等待-2msl-的原因#第四次挥手等待 2MSL 的原因":"为了保证服务端能收到第四次挥手报文。如果第四次挥手报文一开始没有送达，那服务端会超时重传第三次挥手报文，第三次挥手+第四次挥手两个报文的最大存活时间是 2*MSL，因此客户端发送第四次挥手后需要等待这么长的时间，保证服务端能收到第四次挥手报文。\n保证该连接的所有失效报文在网络中消失，避免后续连接造成影响。","第三次握手服务端没有收到的处理办法#第三次握手服务端没有收到的处理办法":"服务端超时重传自己的 SYN，直到收到客户端的 ACK 或者超过重试次数主动中断链接。客户端无法感知服务端没有收到（除非收到超时重传的 SYN+ACK），会直接发送数据，此时服务端会返回 RST 包告知客户端连接非法，请求重置。","握手只保留前两次可以吗#握手只保留前两次可以吗？":"只有一次握手：肯定不行，服务器不知道\n只有两次握手：不行。\n如果服务端不接收客户端的三次确认，而是对每一个连接请求直接建立连接，那么服务端就有可能对于一个长时间滞留已经失效连接请求建立无效连接。（来自谢希仁《第七版计算机网络》的解释）\nTCP 报文中的确认号为 N 表明到序号 N-1 为止的所有数据都已经正确收到。只有两次握手的话，只有客户端的起始序列号能被确认，服务端选择的序列号则得不到确认（此时从服务端获取数据的过程就会停滞）。\n\n四次及以上握手没有必要（可以通过 KeepAlive 机制检查存活）","keepalive-机制实现方案#KeepAlive 机制实现方案":"KeepAlive 机制具体由操作系统或者应用层实现。","arq-滑动窗口协议和流量控制#ARQ 滑动窗口协议和流量控制":"可靠传输的实现必须依赖确认（Acknowledge，ACK），Ack 为接受到的包的 Seq+1，表明收到了该数据包，否则要么由接收方主动报告给发送方这一数据缺失，要么通过超时由发送方被动得知这一数据缺失。传输层通过这一确认/重传机制，在不可靠的传输网络上实现了可靠的通信。这一协议称为自动重传请求（Automatic Repeat reQuest，ARQ）。为了保证信道利用率，允许发送方发送多个数据包，并延后接收 ACK 的时间，这就是连续 ARQ 协议（ARQ 滑动窗口协议）。其中滑动窗口用于限制发送方一次可以发送的字节数量。在滑动窗口中，接收方可以采用累积确认的方式确认发送方的数据。之前提到，TCP 报文中的确认号为 N 表明到序号 N-1 为止的所有数据都已经正确收到。累积确认即基于这一特点，只对按序到达的最后一个分组发送确认。在 TCP 协议报文的 header 上有一个 rwnd 字段，表明接收方设置发送方可发送数据报的字节数量（而不是报文段数量），用于连续 ARQ 协议的实现。","零窗口探测#零窗口探测":"rwnd = 0 时表示接收方禁止发送方发送数据，此时需要发送方设置一个持续计时器（persistence timer），在零窗口时候启动，定时确认此时接收方的窗口大小，从而避免互相等待产生死锁。","拥塞控制#拥塞控制":"RFC-5681 定义了慢开始（slow-start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）、快恢复（fast recover） 四种拥塞控制算法。\n慢开始（slow start）：从一个极低窗口值值开始增大窗口大小（此时窗口大小每次扩大一倍）\n拥塞避免（congestion avoidance）：当窗口值超过某个阈值（ssthresh）时，从加倍（指数）增长改为线性增长，并在超时时将窗口大小重设为 1，ssthresh 设置为原来的一半，重新回到慢开始状态。这一过程也称为加法增大（Additive Increase）。\n\n\n快重传&恢复（fast retransmit and recovery，FRR）：对于偶尔产生的丢包现象（而不是拥塞导致的丢包现象），客户端可以通过连续发送三个重复确认，此时 ssthresh 设置为原来的一半，并将窗口大小直接设置为当前的 ssthresh 大小。这一过程也称为乘法减小（Multiplicative Decrease）。\n\n加法增大（AI）和乘法减小（MD）合起来称为 AIMD 算法。","总结-tcp-的可靠性来源#总结 TCP 的可靠性来源":"连接：通过三次握手和四次握手来确保连接的建立和释放\n数据：通过带序确认和超时重传保证数据传递有序、不丢失、不重复，通过校验和保证不出错。","一个简单的-tcp-的传输示例#一个简单的 TCP 的传输示例":"https://www.liaoxuefeng.com/wiki/1016959663602400/1017788916649408\n服务端（分监听端口bind+listen、接收并建立连接accept以及之后的数据流 IO 过程）客户端（包括 connect和数据流的 IO 过程）UDP（User Datagram Protocol，用户数据报协议）是一种传输层协议。UDP 为网络层以上和应用层以下提供了一个简单的接口。UDP 只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以 UDP 有时候也被认为是不可靠的数据包协议）。UDP 在 IP 数据包的头部仅仅加入了复用和数据校验字段。","一个简单的-udp-的传输示例#一个简单的 UDP 的传输示例":"https://www.liaoxuefeng.com/wiki/1016959663602400/1017790181885952\n服务端监听端口（不需要 connect、listen）\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n# 绑定端口:\ns.bind(('127.0.0.1', 9999))\n\nprint('Bind UDP on 9999...')\nwhile True:\n# 接收数据:\ndata, addr = s.recvfrom(1024)\nprint('Received from %s:%s.' % addr)\ns.sendto(b'Hello, %s!' % data, addr)\n客户端发送数据，接受返回值（不需要 connect）\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nfor data in [b'Michael', b'Tracy', b'Sarah']:\n# 发送数据:\ns.sendto(data, ('127.0.0.1', 9999))\n# 接收数据:\nprint(s.recv(1024).decode('utf-8'))\ns.close()\n\n│Bind UDP on 9999...                                     │\n│Received from 127.0.0.1:63823...                        │\n│Received from 127.0.0.1:63823...                        │\n│Received from 127.0.0.1:63823...\n\n│Hello, Michael!                                         │\n│Hello, Tracy!                                           │\n│Hello, Sarah!                                           │\n如果将服务端的data, addr = s.recvfrom(1024)接收的字节数从 1024 改为 2，那么最后客户端的输出会变成\n│Hello, Mi!                                           │\n│Hello, Tr!                                           │\n│Hello, Sa!                                           │\n这是 UDP 作为面向无连接的数据报协议的表现。每一个报文是一个整体，没有办法拆分到下一次接收。TCP 提供面向连接的可靠传输，UDP 提供面向无连接的不可靠传输TCP 是流模式，发送的数据不需要一次性读完，UDP 是数据报模式，服务端 write 和客户端 read 的次数必须相同。"}},"/tutorial/computer-network/8":{"title":"4.2.DHCP协议","data":{"":"https://zhuanlan.zhihu.com/p/265293856\nDHCP 用于客户端向服务端申请一个可用的 IP 地址。DHCP 使网络管理员能从中心结点监控和分配 IP 地址。在申请过程中，客户端会会广播一次 DHCP Discover 报文，用于发现可用的 DHCP 服务器，当（多个） DHCP 服务器用单播回应后，客户端会从中选择一个可用的服务器，并将选择结果再次广播出去（用于通知所有 DHCP 服务器）。\n关于报文是广播还是单播的解释(rfc2131), https://blog.csdn.net/leo000111/article/details/6127857\nhttps://cloud.tencent.com/developer/news/270493","dhcp-报文类型#DHCP 报文类型":"https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE\n\nDiscover\nOffer\nRequest\nAcknowledge，ACK\nRelease\nNAK"}},"/tutorial/computer-network/9":{"title":"4.3.HTTP协议","data":{"":"HTTP 是一种应用层协议。约定了一种服务器和客户端之间交换数据的方式，这包括两种消息类型，均由采用 ASCII 编码的多行文本构成︰\n请求（requests）：客户端发送用来触发一个服务器上的动作\n响应（responses）：来自服务器的应答。","消息结构#消息结构":"HTTP 请求默认使用 80 端口。请求和相应内容分为 header 和 body 两个部分，header 是必须的，body 是可选的（一般见于 put、post 请求中）。header 描述元信息，body 存放具体数据。HTTP 请求和响应具有相似的结构，由以下部分组成︰\n起始行：一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。\nheaders：一个可选的 HTTP 头集合指明请求或描述消息正文。\nempty line：一个空行指示所有关于请求的元数据已经发送完毕。\nbody：一个可选的包含请求相关数据的正文 (比如 HTML 表单内容), 或者响应相关的文档。正文的大小有起始行的 HTTP 头来指定。","request#request":"起始行：由方法（共八种）、目标、版本三部分组成，如：\nPOST / HTTP/1.1\nGET www.baidu.com HTTP/1.1\n...\n\n\nheaders：不区分大小写的字符串，紧跟着的冒号 (':') 和一个结构取决于 header 的值。整个 header（包括值）由一行组成，这一行可以相当长，如\nHost: localhost:8080\nConnection: keep-alive\n...\n\n\nbody（optional）\nSingle-resource bodies，由一个单文件组成。该类型 body 由两个 header 定义： Content-Type 和 Content-Length.\nMultiple-resource bodies，由多部分 body 组成，每一部分包含不同的信息位。通常是和 HTML Forms 连系在一起。\nHTTP 协议（HyperText Transfer Protocol, 超文本传输协议）中定义了八种动作/方法，Get 和 Post 是其中的两种。","response#response":"起始行（状态行，status line）：由版本，状态码，状态文本组成，如：\nHTTP/1.1 404 Not Found\n\n\nHeaders\nGeneral headers，例如 Via，适用于整个报文。\nResponse headers，例如 Vary 和 Accept-Ranges，提供其它不符合状态行的关于服务器的信息。\nEntity headers，例如 Content-Length，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。\n\n\nBody\nSingle-resource bodies，由已知长度的单个文件组成。该类型 body 由两个 header 定义：Content-Type 和 Content-Length。\nSingle-resource bodies，由未知长度的单个文件组成，通过将 Transfer-Encoding 设置为 chunked 来使用 chunks 编码。\nMultiple-resource bodies，由多部分 body 组成，每部分包含不同的信息段。但这是比较少见的。","http-传输方向单双公#HTTP 传输方向（单双公）":"https://www.jianshu.com/p/3ca180af7dca\n\n单工： 数据传输只允许在一个方向上的传输，只能一方来发送数据，另一方来接收数据并发送。例如：对讲机\n半双工：数据传输允许两个方向上的传输，但是同一时间内，只可以有一方发送或接受消息。例如：打电话\n全双工：同时可进行双向传输。例如：websocket\nhttp1.0：单工。因为是短连接，客户端发起请求之后，服务端处理完请求并收到客户端的响应后即断开连接。\nhttp1.1：半双工。默认开启长连接 keep-alive，开启一个连接可发送多个请求。\nhttp2.0：全双工，允许服务端主动向客户端发送数据。","http-不同版本的主要区别#HTTP 不同版本的主要区别":"HTTP/0.9：只接受 GET 一种请求方法，不支持请求头\nHTTP/1.0：\nHTTP/1.1：默认采用持续链接，和 1.0 的主要区别在于：\n缓存处理\n缓存处理\n带宽优化及网络连接的使用\n错误通知的管理\n消息在网络中的发送\n互联网地址的维护\n安全性及完整性","http-相应状态码#HTTP 相应状态码":"信息响应 (100–199)：消息——请求已被服务器接收，继续处理\n成功响应 (200–299)：成功——请求已成功被服务器接收、理解、并接受\n重定向消息 (300–399)：重定向——需要后续操作才能完成这一请求\n客户端错误响应 (400–499)：请求错误——请求含有词法错误或者无法被执行\n服务端错误响应 (500–599)：服务器错误——服务器在处理某个正确请求时发生错误，如 500","3xx-状态码#3xx 状态码":"301 Move Permanently，是永久重定向，表示资源被永久的改变了位置。这建议请求方应该缓存该响应。\n\n一个 301 响应内容的示例：\nHTTP / 1.1  301  Moved Permanently\nLocation :  http://www.example.org/index.asp\nCache-control :  private; max-age=600\n\n302 Found/Moved Temporarily，是临时重定向。\n\n\n返回 301 状态码是将网站位址由 HTTP 迁移到 HTTPS 的最佳方法。\n\n303 See Other。建议用于 Post 请求后对用户当前页面的跳转。\n307 Temporary Redirect，基于 302 的改变，建议用户用同样的请求类型请求重定向网址。","4xx-状态码#4xx 状态码":"400 ：客户端请求有语法错误，不能被服务器所理解。\n403 ：服务器收到请求，但是拒绝提供服务。\n404 Not Found。服务器找不到请求的网页。","get-和-post-的异同#Get 和 Post 的异同":"从语义上，Get 一般用于请求数据，Post 用于新增或修改数据\n从形式上，Get 参数显式，内容可以被浏览器缓存，Post 参数隐式，不可被缓存。\n从数据上，Get 参数只能是 url，Post 可以支持各种格式的数据。\n\nHTTP/1.x 报文有一些性能上的缺点：\nHeader 不像 body，它不会被压缩。\n两个报文之间的 header 通常非常相似，但它们仍然在连接中重复传输。\n无法复用。当在同一个服务器打开几个连接时：TCP 热连接比冷连接更加有效。\n\nHTTP/2 引入了一个额外的步骤：它将 HTTP/1.x 消息分成帧并嵌入到流 (stream) 中。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，这是一个被称为 多路复用 (multiplexing) 的过程，它允许更有效的底层 TCP 连接。HTTP/2 是一个在 HTTP/1.1 和底层传输协议之间附加的步骤。Web 开发人员不需要在其使用的 API 中做任何更改来利用 HTTP 帧；当浏览器和服务器都可用时，HTTP/2 将被打开并使用。超文本传输安全协议，HyperText Transfer Protocol Secure。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。用于提供对网站服务器的身份认真，保护交换资料的隐私与完整性。HTTPS 请求默认使用 443 端口。","技术实现#技术实现":"HTTPS 请求会基于 SSL/TLS 安全协议加密 HTTP 请求。具体的，安全协议作为 HTTP 进程和运输层的中间层，向上（HTTP 进程）提供 socket 或解密后的报文，向下注入运输层加密报文或从运输层获取加密报文并解密。\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP"}},"/tutorial/computer-network":{"title":"Index","data":{"":""}},"/tutorial/cpp/0":{"title":"0.1.指针","data":{"":"int *p/int (*p)/(int *)p：三者一样，p 是 int 指针类型，*p 是 int 类型\nint **p/int *(*p)/(int *)*p：三者一样，p 是二维 int 指针类型，*p 是 int 指针 类型，**p 是 int 类型\n\n带数组后缀的解读方法：\nint *p[10]: 可以看成 (int *)(p[10])，即 p 是 10 长度数组变量，数组类型是 int *\nint **p[10]: 可以看成 (int **)(p[10])，即 p 是 10 长度数组变量，数组类型是 int **\nint (*p)[10]：可以看成 (int) ((*p)[10])，即 *p 是 10 长度数组变量，p 是指向 10 长度数组变量类型的指针，数组元素类型是 int\nint (**p)[10]: 可以看成 (int) ((**p)[10])，即 **p 是 10 长度数组变量，数组元素类型是 int\nint *(*p)[10: 可以看成 (int *)((*p)[10])，即 *p 是 10 长度数组变量，数组元素类型是 int *\n\n带函数后缀的解读方法：\nint *p(int): 可以看成 (int *) (p(int))，即 p 是函数类型，函数体是 (int)，返回类型是 int *\nint (*p)(int)：可以看成 (int) ((*p)(int))，即 *p 是函数，p 是指向该函数类型的指针，函数体是 (int)，返回类型是 int\nint (*(*p)(int,int))(int)：将 (*p)(int,int)看成一个整体 pF，此时写作 int *pF(int)，pF 是一个函数指针，指向的函数体是 int，返回值是 int。因为 (*p)(int,int) 中的 p 是一个函数指针，所以 (*p)(int,int) 的返回值是 pF 类型的函数指针。即对 p 指针所指向的函数的调用会返回另一个函数指针。\n\n带函数后缀和数组后缀的解读方法：\nint (*maths[2])()","总结#总结":"对带数组后缀和指针前缀的类型，根据优先级加括号将类型声明分成两部分，那么第一部分是数组元素的类型，第二部分是变量名（或带指针的变量名）的类型。\n对待函数体后缀和指针前缀的类型，根据优先级加括号将类型声明分成两部分，第一部分是函数的返回值\n\n野指针指指针指向了一段非法的内存地址而不是 NULL 时的情况。常见的出现场景包括：\n未初始化指针\nfree 内存未将指针置 0\n指针计算越界时会出现野指针\n\n\nchar *p1;\n\nchar *p2 = (char *)malloc(100);\nfree(p2);\n此外，指针操作超过了变量的作用范围。\nvoid foo(A *p){\nA a;\np = &a;\n}\n\nvoid main(){\nA *p;\nf(p);\np->Func(); // cout << p->value;\n}"}},"/tutorial/cpp/1":{"title":"0.数据类型","data":{"":"数据是通过观测得到的数字性的特征或信息。存储不同类型的数据需要不同类型的结构，或者说，数据类型描述了数据的表示法、解释和结构。C++ 中的数据类型包括：\n基础数据类型\n数组\nstruct\nunion\nenum\n指针类型\n引用类型","基础数据类型#基础数据类型":"整数类型\n// 1 bit\nbool b = true; // b = false;\n\n// 1 byte = 8 bit\nchar c = 1;\n\n// 4 byte = 32 bit\nint i = 1;\n\n// 2 byte = 16 bit\nshort s = 1;\nshort int si = 1;\nshort short int ssi = 1; // = short int\n\n// 8 byte = 64 bit\nlong l = 1;\nlong int li = 1;\nlong long int lli = 1;\n浮点数\n// 4 byte\nfloat f = .0; // 所以有时也称 float32，单精度浮点数\n// 8 byte\ndouble d = 0.; // 有时也称 float64, 双精度浮点数\n\nlong double ld = 1.2e-4;\n有无符号数描述\nunsigned int ui = 1;\n// 除 char 外，默认均为有符号数 signed\nsigned int sii = 1;\n其他初始化内容\nint i2 = {0};\nint i3{0};\nint i4(0);","数组#数组":"一维数组\n// 默认初始化（为 0 ）\ndouble a[5];\n// 完全初始化\ndouble b[3] = {1,2,3};\n// 自动推导数组长度\ndouble c[] = {1000.0, 2.0, 3.4, 7.0, 50.0};\n// 不完全初始化（其余值为 0）\ndouble d[5] = {1000.0, 2.0, 3.4};\ndouble e[5] = {};\n// C++11\nint f[5]{};\n\n多维数组\nint a2[5][10];\nint b2[3][4] = {\n{0, 1, 2, 3} ,   /*  初始化a[0] */\n{4, 5, 6, 7} ,   /*  初始化a[1] */\n{8, 9, 10, 11}   /*  初始化a[2] */\n};\n\n// 不完全初始化\nint c2[3][4] = {\n{0, 1, 2, 3} ,   /*  初始化a[0] */\n};\nint d2[3][4] = {};\nint e2[3][4]{};","struct#struct":"结构体可以看成没有函数的类\nstruct <类型名> {\n<变量声明1>;\n<变量声明2>;\n...\n} [<变量名1>,<变量名2>,...];\n// [] 内可选\n常见的使用方式\nstruct A\n{\nint id;\n};\n\ntypedef struct {\nint id;\n} B; // 通过 typedef 定义匿名 struct 的别名\n\ntypedef struct C{ //\nint id;\n} C; // 通过 typedef 定义有名 struct 的别名（可以重名）\n\nstruct D\n{\nint id;\n} d1, d2;\n\n// 以下初始化方式均合法\nstruct A a;\nB b; // struct B b; 非法\n\nC c;\nstruct C c;\n\n// 赋值初始化\ntypedef struct {\nint id;\ndouble arr[3];\n} B;\nB b = {2,3,4,5} // 分别赋值 id, arr[0], arr[1], arr[2]\nB c = {2,3,4} // 分别赋值 id, arr[0], arr[1]\n\nauto","union#union":"[ ]https://www.cnblogs.com/jeakeven/p/5113508.html","enum#enum":"enum <类型名> {<枚举常量表>} [<变量名1>,<变量名2>,...];\n// [] 内可选\n常见的使用方式：\nenum color_set1 {RED, BLUE, WHITE, BLACK}; // 定义枚举类型color_set1\n\n//枚举常量的赋值与默认值: 从 0 开始，可被覆盖\nenum fruit_set {apple=7, orange, banana=1, peach, grape}\n//枚举常量apple=7,orange=1, banana=1,peach=2,grape=3。\n\n// 枚举类型名可以直接省略\nenum {Sun,Mon,Tue,Wed,Thu,Fri,Sat} weekday1, weekday2;\n\nenum color_set2 { GREEN, RED, YELLOW, WHITE} color3, color4;\n\n// 以下所有声明均合法\ncolor4=color_set1::RED;\ncolor4=RED;\ncolor4=::RED;\ncolor4=color3;        //相同类型的枚举变量赋值，color4的值为RED\nint  i=color3;\n\n// 枚举变量之间可以比较\nif (color3==color4 || color1 < color2){}\n\n非法操作：不能重复定义同样的枚举名\nenum A {\na1, b2, c3\n} ww;\n\n// 编译器不通过，a1 重复\nenum B {\na1, b1, c1\n};","指针类型#指针类型":"所有的指针类型的值都是一个内存地址，该内存地址是存储相应数据类型值的地址。\nint a = 2;\nint *pa = &a;","字符串类型#字符串类型":"字符串的初始化C-style 字符串：\nchar a[] = {'a','b','\\0'}\nchar b[10] = \"Hello world\"\nchar c[] = \"Hello world\"\nconst char *d = \"Hello world!\";\n// char *e = \"Hello world!\"; // ISO C++11 does not allow conversion from string literal to 'char *'\nC++ 标准库 <string> 中定义了字符串类型。","引用类型#引用类型":"引用就是别名，引用变量值的更改会影响到原变量。引用的变量可以是有名变量（左值引用），也可以是匿名变量（右值引用）。\nint main() {\nint a = 4;\nint &ra = a;\nra++;\ncout << a << endl; // 输出 5\n}\n引用类似于一个 const 指针，在创建时候就需要做好初始化。从这一层想，数组的引用就是指针：\nint a[] = {1,2,3};\nint *ra = a;\nra[0]++;\na[0]++;\ncout << a[0] << endl; // 输出 3","自动类型#自动类型":"","auto#auto":"自动推导类型：\nint a = 3;\nauto b = a;\n可以用来简化复杂的类型表达式：\n// auto = wrap_iter<int *>\nfor (auto it = a.begin(); it != a.end(); it++) {\ncout << *it << endl;\n}","decltype#decltype":"decltype = declare type，用于补充 auto 无法覆盖的自动推导类型的场景。decltype 的用法为：\ndecltype(exp) varname;\nexp 是表达式，decltype 推导表达式类型作为变量类型。因此，和 auto 不同，不需要变量初始化。decltype 可以用于统一常量和非常量值的使用\nhttp://c.biancheng.net/view/7151.html","函数类型#函数类型":"见函数一节","空类型#空类型":"// 定义返回值类型\nvoid foo(){}\n\n// 定义指针类型\nvoid *p = 0;","sizeof#sizeof":""}},"/tutorial/cpp/10":{"title":"多态","data":{"":"多态指的是调用同名函数时根据参数类型的不同执行不同的函数的行为。多态分为静态多态和动态多态，静态多态指在编译阶段函数调用的行为就已经确定，动态多态指函数的调用在运行时确定。","静态多态#静态多态":"同名函数、模板多态发生在同名函数、模板和存在继承的类成员函数中，其中同名函数是静态多态，在编译阶段函数调用的行为就已经确定；继承的类成员函数是动态多态，函数的行为通过虚函数表在运行时确定。","为什么不能根据返回类型区分重载#为什么不能根据返回类型区分重载？":"从实现上来讲，重载时是根据函数签名来唯一确定一个函数的，而 C++ 中返回值的类型并不包含在函数签名中。从理论上来讲，重载的过程，就是根据调用函数的语句来判断调用的具体函数的过程。而在函数调用的过程中，参数的输入是一个必选项，返回值的接收是一个可选项，可以通过int i = f();，也可以 f();。用不确定的返回值约束来判定重载函数是一个不优雅的行为。从技术上来讲，根据返回类型来区分重载完全可行，定义一套标准/协议/规范外加编译器实现即可。","动态多态#动态多态":""}},"/tutorial/cpp/11":{"title":"字符串","data":{"":""}},"/tutorial/cpp/12":{"title":"异常","data":{"":""}},"/tutorial/cpp/13":{"title":"总结与辨析","data":{"":"函数指针，指针函数\n\n函数指针首先是个指针，其次是函数类型；指针函数首先是个函数，返回值是指针类型\nint (*f()); // 函数指针\nint* f(); // 指针函数\n\n常量指针，指针常量\n\n常量指针首先是个指针，这个指针指向了一个常量（指针地址可以改，内存值是常量不能改）；指针常量首先是个常量，其次这个常量类型是个指针（指针地址是常量，初始化不为空，指针指向的内存值可以改）\n// 常量指针\nconst int *pa;\nint const *pb;\n\n// 指针常量\nint * const p = pa;\n\n// 指向常量的常量指针\nconst int * const pc = pa;\n\n数组指针，指针数组\n\n数组指针首先是个指针，这个指针指向的类型是数组；指针数组首先是个数组，数组的类型是指针类型\nint arr[5][5];\n// 数组指针，注意运算优先级\nint (*pa)[5][5] = &arr;\n\n// 指针数组\nint * pb[5]; // == (int*) pb[5];\n\n\n常量引用，引用常量\n\n常量引用首先是个引用，引用的值是个常量（变量不能更改），可以在函数参数显示声明入参的不可更改属性；引用常量不存在；\nint i = 42;\n// r 作为常量不能更改\nconst int &r = 42;\nint const &r = i;\n\n// 编译错误\nint &const r;"}},"/tutorial/cpp/14":{"title":"模板","data":{"":"","模板相关概念#模板相关概念":"模板实例化：\n显式实例化：显示的在编写过程中声明实例化类型\n隐式实例化：在调用 过程中根据实际情况分析并实例化模板\n\n\n模板匹配\n模板特化：为特殊类型构造特殊的实现\n全特化：对确定后的全部模板参数的特殊实现\n偏特化：对部分模板参数的特殊实现\n\n\n\n\n在模板定义语法中关键字 class 与 typename 的作用完全一样。typename 是后引入的，目的是为了避免 class 的意图混淆\ntypename 还用于显式的声明类型\ntemplate <typename T1, typename T2,...> 返回类型 函数名(parameter list)\n{\n// 函数的主体\n}\n如\ntemplate<typename E>\nint foo(E e) { return 0; }\n\n// 显示实例化，以下均合法\ntemplate int foo(float);\ntemplate int foo<>(float);\ntemplate int foo<float>(float);\n\ntemplate <class type> class class-name {\n\n}\n如\ntemplate<typename T>\nclass A {\nT t;\n};\n\n// 显示实例化\ntemplate\nclass A<int>;\n和函数模板类似\nclass B {\ntemplate<typename T>\nT boo() {}\n};\n\n// 显示实例化\ntemplate int B::boo();\n\nhttps://blog.csdn.net/K346K346/article/details/82179205\n\n\nhttps://blog.csdn.net/u012814856/article/details/84645963"}},"/tutorial/cpp/15":{"title":"类","data":{"":"","类的默认函数#类的默认函数":"默认构造函数\n默认拷贝构造函数\n默认析构函数\n默认重载赋值运算符函数\n默认重载取址运算符函数\n默认重载取址运算符 const 函数\n默认移动构造函数（C++11）\n默认重载移动赋值操作符函数（C++11）\n\n\nclass A\n{\npublic:\n\n// 默认构造函数;\nA();\n\n// 默认拷贝构造函数\nA(const A&);\n\n// 默认析构函数\n~A();\n\n// 默认重载赋值运算符函数\nA& operator = (const A&);\n\n// 默认重载取址运算符函数\nA* operator & ();\n\n// 默认重载取址运算符const函数\nconst A* operator & () const;\n\n// 默认移动构造函数\nA(A&&);\n\n// 默认重载移动赋值操作符\nA& operator = (const A&&);\n\n};","构造函数#构造函数":"各种构造函数及其调用时机为：\n普通构造函数：用非该类对象作为参数进行初始化时\n默认构造函数（当类没有定义任何普通构造函数时，创建类时会执行默认构造函数）\n\n\n赋值构造函数：对象作为右值进行非初始化下的赋值时\n拷贝构造函数：发生在静态对象作为返回值、以右值进行初始化赋值时\n转换构造函数：用于类型转换\n移动构造函数（C++11）：针对原本触发拷贝构造函数时，对象内包含指针对象时的优化，","限制类只能在堆或栈上建立#限制类只能在堆或栈上建立":"核心知识点：\nnew 操作分配的空间在堆上，静态方式分配的空间在栈上\nnew 操作符包括分配空间（由 operator 完成）和执行构造函数两个操作\n栈上的类由编译器管理类的构造和析构，堆上的类由开发者手动管理类的构造和析构\nnew 和 delete 操作符可以由类重载\n\n动态建立在 new 阶段只看构造函数，而静态建立在编译器阶段就要判断析构函数是否合法，因此通过限制析构函数的可见性，可以限制类只能用动态方法建立。\nclass  A\n{\npublic :\nA(){}\nvoid  destory(){ delete   this ;}\nprotected : // 保证子类可以继承，否则可以设置为 private\n~A(){}\n};\n因为 new 和 delete 操作符可以重载，因此通过限制类上这两个操作符的可见性，可以限制类只能用静态方法建立。\nclass  A\n{\nprivate :\nvoid * operator  new ( size_t  t){}      // 注意函数的第一个参数和返回值都是固定的\nvoid  operator  delete ( void * ptr){}  // 重载了new就需要重载delete\npublic :\nA(){}\n~A(){}\n};","委托构造c11#委托构造（C++11）":"某一个构造函数依赖其他构造函数进行构造\n#include <iostream>\nclass Base {\npublic:\nint value1;\nint value2;\nBase() {\nvalue1 = 1;\n}\nBase(int value) : Base() { // 委托 Base() 构造函数\nvalue2 = value;\n}\n};\nint main() {\nBase b(2);\nstd::cout << b.value1 << std::endl;\nstd::cout << b.value2 << std::endl;\n}","继承构造c11#继承构造（C++11）":"使用关键字 using 允许子类沿用父类的构造函数\n#include <iostream>\nclass Base {\npublic:\nint value1;\nint value2;\nBase() {\nvalue1 = 1;\n}\nBase(int value) : Base() { // 委托 Base() 构造函数\nvalue2 = value;\n}\n};\nclass Subclass : public Base {\npublic:\nusing Base::Base; // 继承构造\n};\nint main() {\nSubclass s(3);\nstd::cout << s.value1 << std::endl;\nstd::cout << s.value2 << std::endl;\n}","override-显式声明子类重载c11#override 显式声明子类重载（C++11）":"通过可选的 override 关键字在子类实现父类虚函数时候，显式的声明这是一个 override 行为，添加主动的编译器检查，从而避免父类后期删除该虚函数或实现参数不正确时导致程序的行为错误（预期的多态行为没有出现）。\nclass A {\npublic:\nvirtual void foo(int i) {\n\n};\n};\n\nclass B : A {\nvoid foo(int i) override; // override 对如何实现虚函数的过程不做限制\n};","final-显式声明禁止重载c11#final 显式声明禁止重载（C++11）":"通过可选的 final 添加主动的编译器检查，避免子类重载该函数。","虚函数#虚函数":"虚函数用于类实例的多态。底层实现是类的虚函数表。以指针方式创建类对象时，对象的虚表指针会指向自己所属类的虚表，而虚表中每个指针则指向距离该类最近的一个类（包括自身）的虚函数。\n非虚函数的调用不用经过虚表\n编译器会在编译阶段在构造函数中增加为 vptr 赋值的代码，因此在构造函数执行后实例才会虚函数表（有指向虚函数表的指针），因此构造函数不能是虚函数。相反，基类的析构函数一般要声明为虚函数，用于动态实例销毁时调用正确的析构函数。","友元#友元":"友元是 C++的一种额外的权限控制手段，用于提供给其他类访问类内私有变量的权限。","公有继承私有继承保护继承#公有继承、私有继承、保护继承":"C++ protected 继承和 private 继承是不是没用的废物？ - IceBear 的回答 - 知乎"}},"/tutorial/cpp/16":{"title":"编译器","data":{"":"预处理：条件编译，头文件包含，宏替换的处理。\n对全部的 #define 进行宏展开、处理 #ifdef、递归处理 #include\n删除注释\n添加行号和文件标识\n保留 #progma\n\n\n编译： 预处理后的文件通过词法分析，语法分析，语义分析及优化后转换为汇编语言。\n汇编：将汇编语言转化为机器指令，生成目标（target）文件。\n链接：链接目标文件，解决符号依赖，库依赖关系，生成可执行程序。"}},"/tutorial/cpp/17":{"title":"进程与线程","data":{"":""}},"/tutorial/cpp/18":{"title":"预处理","data":{"":"存储空间\n\n\n成员访问权限\n继承\n虚函数 & 纯虚函数\n虚函数表\n\n\n构造函数 & 析构函数\n多态"}},"/tutorial/cpp/2":{"title":"1.数据的操作","data":{"":"在 C++中，为实现不同类型间的转换，C++定义了四个类型转换操作符 static_cast, const_cast, dynamic_cast, 和 reinterpret_cast。","static_cast#static_cast":"静态类型转换。编译器在编译期处理；用于基本数据类型之间的转换。\nint a, b;\ndouble result = static_cast<double>(a)/b;","const_cast#const_cast":"常量类型转换。编译器在编译期处理。用来改变表达式中的常量性(constness)或易变性(volatileness)。如：\nint num;\nconst int *cpNum = &num;\nint *pNum = cpNum;            //error:cannot convert from 'const int *' to 'int *'\nint *pNum = (int *)cpNum;                 //旧式C\nint *pNum = const_cast<int *>(cpNum);     //新式C++ const_cast移除常量性","dynamic_cast#dynamic_cast":"动态类型转换，运行期间确定类型。用于安全地沿着类的继承关系向下进行类型转换。这就是说，你能用 dynamic_cast 把指向基类的指针或引用转换成指向其派生类或其兄弟类的指针或引用，而且你能知道转换是否成功。失败的转换将返回空指针（当对指针进行类型转换时）或者抛出异常（当对引用进行类型转换时）\nWidget *pw;\n...\nupdate(dynamic_cast<SpecialWidget*>(pw));\n// 正确，传递给 update 函数一个指针\n// 是指向变量类型为 SpecialWidget 的 pw 的指针\n// 如果 pw 确实指向一个对象,\n// 否则传递过去的将使空指针。\nvoid updateViaRef(SpecialWidget& rsw);\nupdateViaRef(dynamic_cast<SpecialWidget&>(*pw));\n//正确。 传递给 updateViaRef 函数\n// SpecialWidget pw 指针，如果 pw\n// 确实指向了某个对象\n// 否则将抛出异常","reinterpret_cast#reinterpret_cast":"重新解释类型转换。编译器在编译期处理，主要用于函数指针的转换。\ntypedef void (*FuncPtr)();  // FuncPtr 是一个指向函数的指针，该函数没有参数\n// 返回值类型为 void\nFuncPtr funcPtrArray[10];   // funcPtrArray 是一个能容纳\n// 10 个 FuncPtrs 指针的数组\n\nint doSomething();\n\nfuncPtrArray[0] = &doSomething; // 错误！类型不匹配\n// reinterpret_cast 可以让你迫使编译器以你的方法去看待它们：\nfuncPtrArray[0] = reinterpret_cast<FuncPtr>(&doSomething);","const#const":"常量","static#static":"在 C 中：\n定义全局静态变量和静态函数（仅能在定义的文件内使用）\ninline 函数默认为 static 类型\n\n\n定义局部静态变量（局部变量全局化）\n\n在 C++ 中：\n定义类的静态数据成员\n定义类的静态函数成员\n\n类的静态数据成员需要在类外初始化后才能被使用（否则会报错）：\nclass A{\nstatic int m;\n}\nint A::m = 0;\n类的静态函数成员可以同时被类和类实例调用：\nclass A{\nstatic int m;\nstatic void setM(){\ncout << m++ << endl;\n}\n}\nint A::m = 0;\nvoid main(){\nA a;\na.setM();\nA::setM();\n}","extern#extern":"用于变量的存在声明，防止重复定义错误，保证编译阶段不报错（并在链接阶段从目标代码中寻找声明的函数/变量绑定）。\n在 C++ 中还用于引入 C 语言\n\n\nextern \"C\" {\n#include \"CAdd.h\"\n}","volatile#volatile":"volatile 关键词在 ? 版本后已被弃用，编译不会报错，但已经失去了其原有的作用\n\nint i = 2;\nwhile(i==2){\n// do something;\n}\n上述代码在编译时，因为编译器无法感知到 i 在程序内的变化，因此可能会优化 i==2 逻辑为 true，程序陷入死循环。但 i 可能在该进程的其他线程被改变。此时可以使用 volatile 关键字来声明 i 变量在内存中是不稳定的，可能通过不在程序内明确指定的方式改变，从而避免编译器优化：\nint volatile i = 2;\nvolatile 常用于：\n并行设备硬件寄存器\n中断程序自服务会访问到的非自动变量\n多线程间的共享变量\n\nvolatile 可以和 const 关键字连用，因为 const 只能保证变量在程序内只读，而不保证其在内存中的值不被其他程序改变。"}},"/tutorial/cpp/3":{"title":"2.1.类的构造析构","data":{"":"构造函数用于类实例的初始化，一共有五种\n普通构造函数：用非该类对象作为参数进行初始化时\n默认构造函数（当类没有定义任何普通构造函数时，创建类时会执行默认构造函数）\n\n\n赋值构造函数：对象作为右值进行非初始化下的赋值时\n拷贝构造函数：发生在静态对象作为返回值、以右值进行初始化赋值时\n转换构造函数：用于类型转换\n移动构造函数（C++11）：针对原本触发拷贝构造函数时，对象内包含指针对象时的优化，"}},"/tutorial/cpp/4":{"title":"2.数据的构造和析构","data":{"":"构造过程是数据的初始化过程，即在创造变量时的赋值过程。这个过程伴随着内存的申请/分配，分配在栈内存中的变量叫自动变量，生命周期由编译器控制，也叫静态构造过程（指需要的内存空间在编译过程确定，和 static 关键词的静态不是一个含义）；分配在堆内存中的变量叫非自动变量，生命周期由开发者控制，也叫动态构造过程（指空间在运行时确定）。","静态构造#静态构造":"基础数据类型、结构体、枚举、联合体的构造过程在 0.数据类型.md 中有过介绍。类通过类的各种构造函数完成初始化过程，见后。","动态构造#动态构造":"动态构造有两种方式：C 中的 malloc/free 系和 C++ 中的 new/delete 系。","mallocfree#malloc/free":"malloc/free 在 C 中定义在 <stdlib.h>，在 C++ 中定义在 <cstdlib>。\n#include <cstdlib>\n\nint main(void)\n{\nint *p1 = malloc(4*sizeof(int));  // allocates enough for an array of 4 int\nint *p2 = malloc(sizeof(int[4])); // same, naming the type directly\nint *p3 = malloc(4* sizeof *p3);   // same, without repeating the type name\n\nif(p1) {\nfor(int n=0; n<4; ++n) // populate the array\np1[n] = n*n;\nfor(int n=0; n<4; ++n) // print it back out\nprintf(\"p1[%d] == %d\\n\", n, p1[n]);\n}\n\nfree(p1);\nfree(p2);\nfree(p3);\n}","newdelete#new/delete":"加 new 后","一阶指针#一阶指针":"int a = 3;\nint *pa = &a;\nint *pb = new int(5);\nint *pc = 0; // 空指针\nint *pd = new int(*pb);","二高阶指针#二（高）阶指针":"","类#类":""}},"/tutorial/cpp/5":{"title":"C++新特性","data":{"":"int array[10] = { 54, 23, 78, 9, 15, 18, 63, 33, 87, 66 };\n\nfor (auto &iter: array) { // 引用类型可以修改值\ncout << iter++ << endl;\n}\n\nfor (auto iter: array) { // 非引用类型修改不好用\ncout << iter << endl;\n}\nC++11 的标准库中迭代器相关函数中添加了 cbegin()/cend()，用来生成不能修改值的迭代器\nvector<int> s({1, 2, 3});\n\n// 编译不通过\n//    for (auto it = s.cbegin(); it != s.cend(); it++) {\n//        cout << (*(it))++ << endl;\n//    }\n\n// 以下两种迭代方式等价：\nfor (auto it = s.begin(); it != s.end(); it++) {\ncout << (*(it))++ << endl;\n}\n\nfor (int & it : s) {\ncout << it++ << endl;\n}\n\n// c++ 17 之前\nconst std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 2);\n\nif (itr != vec.end()) {\n*itr = 3;\n}\n// for 有初始化区域\nfor (std::vector<int>::iterator element = vec.begin(); element != vec.end(); ++element){\n// ...\n}\n// c++ 17 之后\n\nif (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end())\n{\n*itr = 4;\n}"}},"/tutorial/cpp/6":{"title":"README","data":{"":"假设已经熟练掌握至少一门语言，同时系统的了解面向对象、操作系统。\n所有特性：https://en.cppreference.com/w/cpp/language\n\n\n数据类型\n基础数据类型\n数组\n结构体\nunion\n特殊数据类型\n字符串类型\n指针类型\n函数指针\n空指针、野指针、nullptr、nullptr_t\n数组和指针\n\n\n引用类型\n\n\n自动类型推导：auto、decltype\n初始化\n类型转换\n\n\n元编程\n模板 template\n模板类\n模板函数\n偏特化、全特化\n\n\n常量元编程 constexp\n\n\n数据的操作\n一元操作符\n&，*,...\n\n\n二元操作符\n+-*/\n\n\n变量描述符\nconst、static、extern、volatile\n\n\n\n\n分支、循环逻辑\n基础语法\nif/switch 语法增强（C++11）\n有范围的 for 循环语法增强（C++11）\n联合 auto\n\n\n\n\n函数\n函数类型\n函数参数\n将各种类型（数组、指针、引用）作为入参的注意事项\n\n\n变长函数\n函数多态\n\n\n追踪返回类型\n匿名函数 lambda\n\n\n面向对象\n多态\n类\n默认函数\ndefault,delete 语义\n\n\n构造函数\n委派构造函数\n\n\n操作符重载\n返回值？\n\n\n构造函数\n深拷贝浅拷贝：当类中有指针变量、动态内存分配等，需要显示重载赋值/拷贝运算符。\n\n\n继承\nfinal、override、virtual 语义\n内存模型（虚函数表）\n多重继承\n\n\n友元（friend 语义）\n权限（public、protected、private）\n继承权限\n\n\n\n\n\n\n异常\nnoexcept\n\n\n断言\n静态断言\n\n\n编译器\n预处理\n编译\n汇编\n链接\n\n\n内存模型\n段模型\n堆内存管理\nnew、delete\nmalloc、...\n智能指针\n垃圾回收\n\n\n生命周期：move 和 forward 语义\n虚函数表\n构造、析构\n创建、销毁\nPOD\n\n\n模块\nimport/include\nusing/namespace\ninline\n\n\n\n\n进程与线程\n多线程单例模式\n局部线程变量\n原子化操作（C++11）\n\n\nC++ 标准库\n<iostream>\ntuple\nvector\nstring\nbitset\nauto_ptr -> shared_ptr/unique_ptr/weak_ptr\n\n\n总结\nC++11/14...新特性"}},"/tutorial/cpp/7":{"title":"保留字","data":{"":"作者：采苓人\n链接：https://acm.nowcoder.com/discuss/718341?channel=-1&source_id=discuss_terminal_discuss_sim_nctrack&ncTraceId=0edd0bb634c849fdac475aa0d871a13e.312.16341867863208726\n来源：牛客网\n\nC++\n\n3.右值引用 4.锁\n6.move forward\n7.编译的过程 动态库和静态库的区别\n3. new 和 malloc 的区别， new 的底层实现\n4. 拷贝构造函数是传值还是引用，为什么要传引用。\n11 智能指针，shared_ptr 是不是线程安全的\n12.vector 的扩容机制？为什么要 2 倍扩容\n5. C++内存模型\n14.指针和引用的区别\n15 为什么构造函数不能是虚函数，为什么析构函数是虚函数\n16 线程间共享内存，什么时候用到条件变量，什么时候用到锁 ，有什么区别\n17 死锁条件，如何避免，lock_gard unquie_lock 区别\n18 C++怎么调用 c 语言封装的函数\n\n高性能相关\n\n1. opencl 的运行流程\n2. GPU 架构\n3. GPU 全局内存和局部内存区别， 怎么更好利用局部内存。\n4. Cache 原理\n5. 如何提高 cache 命中率\n6. 通常优化的思路\n7. 写 opencl 为什么要减少分支， 掩码\n8. opencl 写 kernel 的主要参数有哪些\n9. 计算密集型和访存密集型的区别 10.可分离卷积在 GPU 上为什么慢，为什么是访存密集型\n11 算子融合 conv+BN 融合的公式，为什么可以融合\n12 推理框架中卷积的实现有哪些\n13 时间局部性和空间局部性\n14 产生 bank confict 的原因和解决方法\n15 TVM"}},"/tutorial/cpp/8":{"title":"内存模型","data":{"":"仅堆由程序员管理，其余均由程序自身管理。\n栈：函数调用时（包括 main）所有局部变量、函数参数、返回数据、返回地址均由栈空间分配。\n全局区：存放全局变量、静态数据、常量。\n文字常量区：特殊的，常量字符串存放在文字常量区。\n程序代码区：存放函数体的二进制代码\n堆：malloc 等创建的内存空间。由程序员管理。分配方式类似于栈（上一块内存地址指向下一块内存地址，地址之间非连续）\n\n自动的意思就是在一定的作用域内会自动消亡，普通的局部变量都是自动变量。非自动就是不会自己释放内存，每次访问改变值后，值会一直保存在那里。非自动变量有两种，一种是全局变量（在非函数内定义的），一种是静态变量（在函数内加了 static 关键字的）","左值--右值#左值 & 右值":"在 C++ 中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。左值一定在内存中，右值有可能在内存中也有可能在寄存器中。左值（lvalue）是有名字的变量，以下变量形式均为不同形式的左值\nint a;\nint &b;\nconst int c;\nconst int &d;\n右值包括将亡值（xvalue，eXpiring value）和纯右值（rvalue）：\n将亡值\n纯右值","左值引用--右值引用#左值引用 & 右值引用":"引用是一种别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。\nint getdata(int &&num)\n{\ncout << num;\nnum += 10;\nreturn num;\n}\n\nvoid main()\n{\nint a = 5;\ncout << getdata(a + 1) << endl;\n}"}},"/tutorial/cpp/9":{"title":"函数","data":{"":"调用的实体，包含返回值、函数名、函数参数、执行逻辑四部分。在 Python 等语言中，匿名函数十分常见，如 python 中的 lambda 表达式\na = 1\nlambda x: a + x\nC++11 引入了 lambda 表达式，用于定义和创建匿名函数。lambda 表达式的通式为：\n[capture list] (params list) mutable exception-> return type { function body }\n作为一个匿名函数，除了函数名外，需要声明的内容包括：\n函数参数：由 [capture list] 或 (params list) 描述\n[capture list] 语法糖，用于直接引入已定义变量（而不用传递给函数参数）\n(params list)：定义一般意义下的匿名函数参数\n\n\n函数返回类型：由 -> return type 描述\n函数体：由 { function body } 描述\n异常类型：由 exception 描述","参数传递#参数传递":"","参数传递-1#参数传递":"通过 (params list)\nint main()\n{\n...\nauto cmp = [](int a, int b) -> bool { return a < b; };\nsort(arr.begin(), arr.end(), cmp);\n}","值捕获传递#值捕获传递":"通过 [capture list]\nint main()\n{\nint a = 123;\n// 通过捕获传递\nauto f = [a] { cout << a << endl; };\nf(); // 输出：123\n\n//通过参数传递\nauto x = [](int a){cout << a << endl;};\nx(a);\n}\n\n使用值捕获传递时，参数传递 (params list) 部份可以省略，但使用参数传递时， [capture list] 不能省略。\n值捕获传递的参数传递方式可以是值传递或引用传递\nint main() {\nint a = 123;\nauto f = [&a]() { cout << ++a; }; // 引用传递\ncout << a << endl; // 输出：123\nf(); // 输出：124\ncout << a << endl; // 输出：124\n}\n使用值传递时，传递的变量无法被修改：\nauto f = [a]() { cout << a; }; // 不会报错\nauto g = [a]() { cout << ++a; }; // 会报错，因为修改了 a\n其他值捕获的参数还包括：\n[this] 以值的形式捕获 this 指针\n[=] 以值的形式捕获所有外部变量\n[&] 以引用形式捕获所有外部变量\n[=, &x] 变量 x 以引用形式捕获，其余变量以传值形式捕获\n[&, x] 变量 x 以值的形式捕获，其余变量以引用形式捕获","mutable-修饰#mutable 修饰":"int main()\n{\nint a = 123;\nauto f = [a]()mutable { cout << ++a; }; // 不会报错\ncout << a << endl; // 输出：123\nf(); // 输出：124\ncout << a << endl; // 输出：123\n}\n匿名函数不支持多态，不支持模板，但在 C++14 后可以通过 auto 来实现泛型。\nauto add = [](auto x, auto y) { return x+y;};\n\nadd(1, 2);\nadd(1.1, 2.2);"}},"/tutorial/cpp/cpp-std/1":{"title":"bitset","data":{"":"#include <iostream>       // cout\n#include <string>         // string\n#include <bitset>         // bitset\n\nusing namespace std;\n\nint main() {\nbitset<16> foo;\nbitset<16> bar(0xfa2);\nbitset<16> baz(string(\"0101111001\"));\n\ncout << \"foo: \" << foo << '\\n';\ncout << \"bar: \" << bar << '\\n';\ncout << \"baz: \" << baz << '\\n';\n\nreturn 0;\n}\n\n// bitset operators\n#include <iostream>       // std::cout\n#include <string>         // std::string\n#include <bitset>         // std::bitset\n\nint main ()\n{\nstd::bitset<4> foo (std::string(\"1001\"));\nstd::bitset<4> bar (std::string(\"0011\"));\n\nstd::cout << (foo^=bar) << '\\n';       // 1010 (XOR,assign)\nstd::cout << (foo&=bar) << '\\n';       // 0010 (AND,assign)\nstd::cout << (foo|=bar) << '\\n';       // 0011 (OR,assign)\n\nstd::cout << (foo<<=2) << '\\n';        // 1100 (SHL,assign)\nstd::cout << (foo>>=1) << '\\n';        // 0110 (SHR,assign)\n\nstd::cout << (~bar) << '\\n';           // 1100 (NOT)\nstd::cout << (bar<<1) << '\\n';         // 0110 (SHL)\nstd::cout << (bar>>1) << '\\n';         // 0001 (SHR)\n\nstd::cout << (foo==bar) << '\\n';       // false (0110==0011)\nstd::cout << (foo!=bar) << '\\n';       // true  (0110!=0011)\n\nstd::cout << (foo&bar) << '\\n';        // 0010\nstd::cout << (foo|bar) << '\\n';        // 0111\nstd::cout << (foo^bar) << '\\n';        // 0101\n\nreturn 0;\n}\nfoo.size() 返回大小（位数）\nfoo.count() 返回 1 的个数\nfoo.any() 返回是否有 1\nfoo.none() 返回是否没有 1\nfoo.set() 全都变成 1\nfoo.set(p) 将第 p + 1 位变成 1\nfoo.set(p, x) 将第 p + 1 位变成 x\nfoo.reset() 全都变成 0\nfoo.reset(p) 将第 p + 1 位变成 0\nfoo.flip() 全都取反\nfoo.flip(p) 将第 p + 1 位取反\nfoo.to_ulong() 返回它转换为 unsigned long 的结果，如果超出范围则报错\nfoo.to_ullong() 返回它转换为 unsigned long long 的结果，如果超出范围则报错\nfoo.to_string() 返回它转换为 string 的结果\nhttps://www.cnblogs.com/rabbithu/p/bitset.html"}},"/tutorial/cpp/cpp-std/2":{"title":"limits","data":{"":"#include <limits>\n\nint main()\n{\nstd::cout\n<< \"type\\t│ lowest()\\t│ min()\\t\\t│ max()\\n\"\n<< \"bool\\t│ \"\n<< std::numeric_limits<bool>::lowest() << \"\\t\\t│ \"\n<< std::numeric_limits<bool>::min() << \"\\t\\t│ \"\n<< std::numeric_limits<bool>::max() << '\\n'\n<< \"uchar\\t│ \"\n<< +std::numeric_limits<unsigned char>::lowest() << \"\\t\\t│ \"\n<< +std::numeric_limits<unsigned char>::min() << \"\\t\\t│ \"\n<< +std::numeric_limits<unsigned char>::max() << '\\n'\n<< \"int\\t│ \"\n<< std::numeric_limits<int>::lowest() << \"\\t│ \"\n<< std::numeric_limits<int>::min() << \"\\t│ \"\n<< std::numeric_limits<int>::max() << '\\n'\n<< \"float\\t│ \"\n<< std::numeric_limits<float>::lowest() << \"\\t│ \"\n<< std::numeric_limits<float>::min() << \"\\t│ \"\n<< std::numeric_limits<float>::max() << '\\n'\n<< \"double\\t│ \"\n<< std::numeric_limits<double>::lowest() << \"\\t│ \"\n<< std::numeric_limits<double>::min() << \"\\t│ \"\n<< std::numeric_limits<double>::max() << '\\n';\n}\n\n// type\t    │ lowest()\t    │ min()\t\t    │ max()\n// bool\t    │ 0\t\t        │ 0\t\t        │ 1\n// uchar\t│ 0\t\t        │ 0\t\t        │ 255\n// int\t    │ -2147483648\t│ -2147483648\t│ 2147483647\n// float\t│ -3.40282e+38\t│ 1.17549e-38\t│ 3.40282e+38\n// double\t│ -1.79769e+308\t│ 2.22507e-308\t│ 1.79769e+308\n\nhttps://en.cppreference.com/w/cpp/types/numeric_limits"}},"/tutorial/cpp/cpp-std/3":{"title":"priority_queue","data":{"":"template <class _Tp, class _Container = vector<_Tp>,\nclass _Compare = less<typename _Container::value_type> >\nclass _LIBCPP_TEMPLATE_VIS priority_queue\n默认是大根堆，使用的是 less<>（Python 中则默认是小根堆），小根堆需要填充额外的两个模板参数，并在第三个使用 greater<>\n#include <iostream>\n#include<vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\nint shortestSubarray(vector<int> &nums, int k) {\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> c;\nc.push({0, -1});\nint ans = 0;\nint minL = 1e6;\nfor (int i = 0; i < nums.size(); i++) {\nans += nums[i];\nint tgt = ans - k;\nwhile (!c.empty() && tgt - c.top().first >= 0) {\nminL = min(minL, i - c.top().second);\ncout << \"pop\" << c.top().first << ',' << c.top().second << endl;\nc.pop();\n}\ncout << ans << ',' << i << ',' << c.top().first << ',' << c.top().second << ',' << endl;\nc.push({ans, i});\n}\nif (minL == 1e6) {\nreturn -1;\n}\nreturn minL;\n}\n};\n\nint main() {\nauto c = vector({2, -1, 2});\ncout << Solution().shortestSubarray(c, 3);\nreturn 0;\n}"}},"/tutorial/cpp/cpp-std/4":{"title":"string","data":{"":"可以以字符串类型或字符类型为初始化参数。\n#include <string>         // string\n\nusing namespace std;\n\nint main() {\nchar ini = 'c';\nchar tmp[] = \"Hello World\";\n\nstring s1;\nstring s2(5, ini); // 以 char 为参数，第一个数值表示重复次数\n\n// 以字符串类型为初始化参数\nstring s3(tmp);\nstring s5(s2);\n\n// 截短\nstring s3(tmp, 3); // == s3(tmp, 0, 3);\nstring s5(s2, 3); // == s5(s2, 0, 3);\n\n// 左值和长度\nstring s4(tmp, 3, 6);\nstring s5(s2, 3, 6);\n}\n\n// 判定\ns.empty(); //判空\ns.size();   //返回字符串中字符的个数\ns1 == s2; // 对比, 还包括 !=,<,<=,>,>=\n// 遍历\nchar ch = s[n];    // char\nfor (auto ch: s2) { // 也支持 begin\ncout << ch;\n}\n\n// 修改\ns1+s2   // 拼接\ns1=s2   // 赋值"}},"/tutorial/cpp/cpp-std/5":{"title":"tuple","data":{"":"https://en.cppreference.com/w/cpp/utility/tuple\n\n#include <tuple>","创建#创建":"std::tuple<int, int> foo_tuple()\n{\nreturn {1, -1};  // Error until N4387\nreturn std::tuple<int, int>{1, -1}; // Always works\nreturn std::make_tuple(1, -1); // Always works\n}","取元素#取元素":"单个取某个位置\ntuple<int,int> r = {1,1};\nint res = get<0>(r);\n同时取多个元素\nint a,b;\nstd::tie(a,b) = r;","比较#比较":"https://en.cppreference.com/w/cpp/utility/tuple/operator_cmp\n逐个元素比较，类似\nif (std::get<0>(lhs) < std::get<0>(rhs)) return true;\nif (std::get<0>(rhs) < std::get<0>(lhs)) return false;\nif (std::get<1>(lhs) < std::get<1>(rhs)) return true;\nif (std::get<1>(rhs) < std::get<1>(lhs)) return false;\n...\nreturn std::get<N - 1>(lhs) < std::get<N - 1>(rhs);"}},"/tutorial/cpp/cpp-std/6":{"title":"vector","data":{"":""}},"/tutorial/cpp/cpp-std":{"title":"Index","data":{"":""}},"/tutorial/cpp":{"title":"Index","data":{"":""}},"/tutorial/cpp/src":{"title":"Index","data":{"":""}},"/tutorial":{"title":"Index","data":{"":""}},"/tutorial/operating-system/0":{"title":"0.计算机组成原理","data":{"":"现代以存储器为中心的计算机结构：\n原始数据和处理程序通过输入设备输入计算机并存放于存储器中，控制器执行程序指挥运算器从内存中取出数据，进行处理后将结果放入存储器中，然后通过输出设备把存储器中的结果输出。\n以运算器为中心，所有的数据都要通过运算器中转，因此运算器的中转效率就成为了程序运行的一大瓶颈。\n以存储器为中心，多个存储器各司其职，从而缓解了运算器的压力，使 IO 密集型和 CPU 密集型的操作可以同时进行，更大程度的利用了计算机系统。\n\n定点和浮点表示二进制中小数点的位置是否固定","定点数整数#定点数（整数）":"定点数可以表示小数，但表示时需要有一个定点小数的规范。假设机器字长 8 bits，规定从左至右，第一位为符号位，接着后 5 位表示定点小数的整数部分，后两位表示定点小数的小数部分。由于对定点小数并无统一的规范，且数值表示的范围和精度有限，所以普通计算机对于小数的表示采用浮点数形式，C/C++ 中也没有定点小数类型，一般使用单精度浮点数 float 和双精度浮点数 double 来表示小数。","浮点数#浮点数":"特殊值\n\nIEEE754 标准","浮点数比较大小的方法#浮点数比较大小的方法":"const double EPS = 0.0000001;\nabs(a - b) < EPS\n\nif (!(a > b || a < b))","寄存器#寄存器":"段寄存器：存放段选择符（Segment Selector）\ncs：代码段寄存器，指向包含程序指令的段\nss：栈段寄存器，指向包含当前程序栈的段\nds：数据段寄存器，指向包含静态数据或全局数据的段\nes、fs、gs：通用段寄存器，可以指向任意的数据段\n\n\n\n\n定点数\nhttps://blog.csdn.net/K346K346/article/details/80704141\n\n\n浮点数\nhttps://polarisxu.studygolang.com/posts/basic/diagram-float-point/\nhttp://kaito-kidd.com/2018/08/08/computer-system-float-point/"}},"/tutorial/operating-system/1":{"title":"1.存储器与IO设备","data":{"":"随机存储器（random access memory, RAM）\n动态随机存储器（DRAM，断电后数据不可保存，如寄存器、缓存、内存）\n静态随机存储器（SRAM，断电后数据可保存，如硬盘，U 盘）\n\n\n只读存储器（read only memory, ROM）\n串行访问存储器：只能按照物理位置先后寻找地址，如磁带\n\n存储器的主要指标包括：速度、容量、每位价格\n缓存\n寄存器\nMDR（memory data register，主存数据寄存器），用于保存要写入或读取出来的某地址单元的数据\nMAR（memory address register，主存地址寄存器），用来保存要读或写数据的存储地址\n\n\n多级 Cache\n\n\n主存（内存）\n辅存\n\n按照功能的划分，存储器之间、存储器和 CPU 之间的线路连接分为数据总线、地址总线和控制总线。\n数据总线可以在各个存储器之间双向的传递数据\n控制总线用来发出控制信号，单条控制总线的信息传递是单向的，如从 CPU 向设备发出的命令，但整体来看是双向的，因为设备也可以向 CPU 发出信号（如中断信号）\n地址总线专门用于 CPU 向其他设备输出数据的源地址或目的地址，所以是单向的\n\n? CPU 读地址的指令可以简化为 1->R，即将地址存储到 MAR，这一步指令走的是地址总线；而 MAR->MDR 这一步走的是数据总线。\n地址数量表明了有多少个存储单元，可以由地址总线的条数表示\n存储字长表明了单个地址可以存储的字节数\n机器字长表明了机器单次运算的指令长度"}},"/tutorial/operating-system/10":{"title":"5.1.内存分配","data":{"":"内存分配的核心操作有两个：\n分配 x 大小的内存\n释放 x 大小的内存\n\n不同的内存分配算法包括\n资源图分配算法\n2 的幂次方空闲链表\nMcKusick-Karels 分配算法\n伙伴（Buddy）系统\nMach 区域（Zone）分配算法\nDynix 分配算法\nSolaris 的 Slab 分配算法\n\n\nLinux 采用伙伴系统 + Slab 分配算法"}},"/tutorial/operating-system/11":{"title":"5.内存管理","data":{"":"地址的数量表明了有多少个存储单元，可以由地址总线的条数表示。地址的表示受限于寄存器的位数，如果寄存器的位数大于等于地址总线的位数，那么就可以直接表示存储单元的地址，否则就需要寻找其他的方法。早期 CPU 有 20 位地址线，但寄存器只有 16 位，因此采用了 [段基址:段偏移量] 的方式来表示。第一个寄存器高四位和第二个寄存器一起组成 20 位的内存地址。由于两个寄存器表示的内存地址是真实的物理地址，因此这种寻址方式也叫做实模式。随着计算机的发展， CPU 的地址线的个数和寄存器的位数相同了，但因为兼容性等原因，仍然采用 [段基址:段偏移量] 的表示方式。与此同时，为了更安全、更灵活访问内存空间，引入了保护模式。在保护模式下，每一个进程都会有段基址、界限地址等描述进程分配的内存大小与内存位置的信息，这一信息存储在全局描述表（GDT，Global Description Table）中（表示为一块内核内存空间），可以有不同的硬件实现。全局描述表只可以由操作系统（在内核态）修改。\n存储全局描述表的硬件叫做基地址寄存器、重定位寄存器，或统称为内存管理单元（Memory-management unit，MMU）\n用户视角下得到的内存地址实际上是段偏移量，是逻辑地址。在不涉及 IO 操作时，用户对逻辑地址的任何操作都不涉及到物理地址。在涉及 IO 操作时，逻辑地址会通过 MMU 转换为物理地址，并执行实际的操作，但用户程序在保护模式下绝对无法得到真实的物理地址。","连续内存分配#连续内存分配":"采用连续内存分配方式时，如果用户申请一块 2M 的内存空间，那么物理内存上就会开辟一块 2M 的内存空间，这 2M 的内存空间地址将是连续的（如从 0-2048）。当新的进程需要一块连续内存空间，物理内存中存在空闲的足够的空间，但是因为不连续导致无法分配时候，就会产生外部碎片问题（external fragmentation）。解决这一问题的方法是允许物理地址空间非连续，如分页/分段/段页式分配。采用连续内存分配时，物理地址仍然可以沿用 段基址, 段偏移 的方式来表示，而逻辑地址则可以直接用 段偏移 表示","外部碎片整理算法伙伴系统算法#外部碎片整理算法（伙伴系统算法）":"http://kerneltravel.net/blog/2020/lp_901/","分页#分页":"分页将整个内存空间划分分成细粒度的块，以块为单位分配给进程。分页的过程需要保证物理内存和逻辑内存的块大小一致（物理内存的块叫帧，逻辑内存的叫页），用于建立逻辑块和物理块的映射关系。分页系统中逻辑地址和物理地址之间的映射通过页表来实现，页表存储了每个页号到帧号的映射关系，此时单个逻辑内存地址用 页号, 页偏移 来唯一表示，在转换时通过页表转换为物理内存地址 帧号, 帧偏移。分页避免了外部碎片问题，保证所有的块都能被分配，但会产生内部碎片问题，但这可以通过调整块大小来缓解。分页功能可以由不同的硬件支持，如转换表缓冲区（translation look-aside buffer, TLB），可以看成是一种存储页号到帧号映射关系的缓存。页表不仅仅是一个线性表，为了支撑更多的页分配，会有更复杂的页表数据结构实现，如多层页表。","分段#分段":"分段是一种用户视角的内存管理方案，反映了程序申请内存的逻辑结构。分段系统将进程的逻辑内存空间区分为代码段、数据段、堆栈等，可以帮助用户更好的操作、共享和保护每一段的内存空间。分段系统中逻辑地址和物理地址的映射通过段表实现，段表保存了每个段的基地址和界限地址，并用 段号, 段偏移 的方式来表示和获取物理内存地址。","段页式#段页式":"段页式将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用。段页式系统中，内存地址由 段号, 页号, 页偏移量 组成。在进行地址转换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。逻辑地址的设定，不仅提供了安全性，也允许逻辑空间大于实际的物理空间。当物理空间不够用又需要分配时，可以将一块不经常使用的内存备份到硬盘的空间上，从而空出这一块空间用于分配，这一操作叫做交换（swap）。理论上所有的硬盘空间都可以用于交换，但实际中需要定义用于交换的内存空间大小。此时，逻辑内存空间=物理内存空间+交换空间","页置换#页置换":"分页系统也允许交换操作，称为页置换（page replacement），此时交换操作以页为粒度进行。页置换的步骤为：\n用户需要使用一个不在内存上的页，产生一个页错误陷阱（page-fault trap）\n检查该进程的内部页表来确认该引用是否合法，如果非法则终止进程，否则继续执行页置换过程\n\n\n在磁盘上查找待置换到内存中的页\n在内存上查找一个空闲帧（没有被分配的帧），如果没有则通过页置换算法选择一个牺牲帧（victim frame）写到磁盘上（并更新页表、帧表）并将该帧的位置作为空闲帧。\n将页置换到空闲帧位置上（并更新页表、帧表）\n中断返回，此时该页存在，用户进程无感使用该页（外部仅表现为少许延迟）\n\n页置换过程中，最重要的是页置换算法，该算法的目的是寻找一个最优解（一个被占用帧），该帧被置换在之后一段时间内造成页错误的数量最少，因为未来无法预测，所以所有算法只能通过过去一段时间的页使用信息来预测并选择。在这种情况下，常用的算法有：\nFIFO（先进先出）\nLRU（least-recently-used，最近最少使用）算法\n...\n\n虚拟内存是对内存交换特性的利用。虚拟内存的虚拟强调进程在执行过程中可能需要的内存不一定真实存在在物理内存中。比如一个程序中存在一个很少被调用的逻辑，该部份逻辑对应的内存可能在程序启动时不会被分配具体的内存空间，而是等到进程真正调用该部份逻辑时，通过缺页中断来动态的加载该部分内存，该操作被称为按需调页。按需调页在缺少物理内存时，可能会反复的置换需要的页，使进程在换页上用的时间多于执行时间，导致 CPU 利用率下降，这一过程称为颠簸（thrashing）。\n实际上这种特性在编程语言中也有体现，即懒加载（lazy load）\n因此，虚拟内存使得程序的初始启动速度加快，也减少了单个进程的物理内存使用量。同时程序不再受物理内存空间的限制。","写时复制#写时复制":"写时复制可以看成是另一种懒操作，当进程 fork 自身时，操作系统可以直接共享原进程的所有内存页，仅在这些页发生了写操作时，创建写操作对应页的副本。\n降低 TLB miss 的概率：拿普通的 4KB 页面和 2MB 的大页相比，都是使用一条页表项，能 cover 的内存大小却差了 511 倍，所以更多的使用大页能大大减少系统中页表项的数量，再加上 TLB cache 大小固定且有限，再再加上程序访问的地址的局部性原理，TLB miss 的概率就下来了。\n降低 walk page table 的长度：由于大页的页表级数(PGD PUD PMD)比普通页面级数(PGD PUD PMD PTE)小 1，所以在走表时会高效一些。(以普通页面是四级页表为例)\n\nTLB（translation lookaside buffer）快表，直译为转换检测缓冲区，也称页表缓冲，是一个内存管理单元，用于改进虚拟地址到物理地址转换速度的缓存。TLB 和 Cache 没有本质的区别，TLB 缓存页表数据，Cache 缓存内存数据。"}},"/tutorial/operating-system/12":{"title":"6.1.IO","data":{"":"理解 IO 的类型首先要区分阻塞/非阻塞和同步/异步的概念，这两个是不同层面的分类标准：\n阻塞式 IO：对 socket 的 IO 请求会一直等待，直到套接字返回数据或错误\n非阻塞式 IO：socket 无论是否有数据还是错误都会直接返回\n信号驱动式 IO：socket 在有数据/变化时会通过内核发送一个信号（更改内存中某个变量的值）\n同步：进程在 IO 过程时一直等待 IO 的完成，如果是阻塞式 IO，那就等待 IO 返回（数据或错误），如果是非阻塞式 IO，那就轮询该 socket，直到 socket 返回的不是空而是数据或错误。\n异步：进程在 IO 过程时还可以做其他的事，而不是等待 IO，直到 IO 过程结束后返回一个信号，此时可以直接用 aio_read 获取\n\n\n小乐爱喝茶，废话不说，煮开水。\n出场人物：小乐，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。\n1 小乐把水壶放到火上，立等水开。（同步阻塞）\n——   小乐觉得自己有点傻\n2 小乐把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）\n——  小乐还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出呜呜~~~~的噪音。\n3 小乐把响水壶放到火上，立等水开。（异步阻塞）\n——  小乐觉得这样傻等意义不大\n4 小乐把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）\n——  小乐觉得自己聪明了。","io-多路复用#IO 多路复用":"IO 多路复用（IO Multiplexing）是在 socket 之上进行了一层封装，将多个 socket 统一由一个函数（select、poll、epoll）进行管理。多路复用的生命周期包括：\n创建复用 fd 和 socket 列表\n建立复用 fd 和 socket 列表中每个 fd 的联系\n阻塞式或者轮询等待复用 fd 返回信息，根据返回的信息决定要处理 socket 队列中的哪些 fd（或向 socket 列表中添加新的 fd）\n\n如果说原来的 socket 的伪代码是：\nint fd;\n// create ...\nread(fd, buf);\n那么用了复用函数后的伪代码就变成了：\nstruct multiplex_data fd[N]; // 用于多路复用的 socket 数据存储区域，除了 socket 的 fd，还保存有状态等信息\nint listenfd = create();// 创建一个多路复用 socket\nchar buf[M];\nwhile(1){\nn = wait(listenfd, fd); // 返回需要处理的 fd 个数，该函数可以阻塞，也可以是非阻塞的\nif(n > 0){\nfor(int i = 0;i < n;i++>){\n// 处理 fd[i], 如 accept、read、write、close 等\n}\n}else if(n < 0){\n// ...\n}\n}\n\n多路复用的操作步骤要比直接对 socket 进行 IO 操作增加了额外的许多步骤。所以少量的 socket 连接场景有时用多线程可能会更快一些。当 socket 连接的个数成千上万上百万时，线程的开销会很大，此时使用多路复用，用一个线程就可以实现对所有 socket 的管理，从而显著的减少了服务器的开销。目前发展处了 select/poll/epoll 三种多路复用的方式。他们主要的区别是：\nselect 函数是阻塞式的，poll 是非阻塞式的，epoll 同时支持阻塞和非阻塞两种方式（仅 LT 模式下支持 block socket）\nselect/poll 是轮询所有 socket 的，epoll 是基于事件驱动的（所以 epoll 能够撑起更大数量的 socket 连接）\nselect/poll 管理的文件描述符会在用户和内核两个内存空间中反复拷贝，epoll 通过 mmap 在用户和内核空间共享一块内存\nepoll 是 Linux 独有\nselect/poll 只提供了一个函数（等待 socket），epoll 提供了三个函数（创建句柄、注册回调事件、等待事件）","epoll-的性能不一定更高#epoll 的性能不一定更高":"当 socket 队列中所有 socket 都活跃时，select/poll （基于轮询的方式）可能比 epoll 的性能更好（因为回调函数调用更麻烦）","epoll-的回调方式#epoll 的回调方式":"水平触发（level triggered）和边沿触发（edge triggered）是模拟信号中的一种概念，以高电平为 1，低电平为 0，水平触发是只要输出为高电平那就一直保持在触发状态；边沿触发是指有在信号有变动时（高电平转低电平或低电平转高电平）才触发。泛化到多路复用中的含义是：\n水平触发：只要 socket 有信息，在没被处理时，会一直为有消息未处理的状态（默认是该模式）\n边沿触发：只对外通知一次，如果不处理或没处理完下次也不会通知（可以看成是专家模式，需要编写更严格的处理逻辑）\n\n水平触发：\n对于读操作只要缓冲内容不为空，LT 模式返回读就绪。\n对于写操作只要缓冲区还不满，LT 模式会返回写就绪。\n\n边缘触发：\n对于读操作\n当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。\n当有新数据到达时，即缓冲区中的待读数据变多的时候。\n当缓冲区有数据可读，且应用进程对相应的描述符进行 EPOLL_CTL_MOD 修改 EPOLLIN 事件时。\n\n\n对于写操作\n当缓冲区由不可写变为可写时。\n当有旧数据被发送走，即缓冲区中的内容变少的时候。\n当缓冲区有空间可写，且应用进程对相应的描述符进行 EPOLL_CTL_MOD 修改 EPOLLOUT 事件时。","异步-io#异步 IO":"[ ]\n\n\nhttps://zhuanlan.zhihu.com/p/115912936\nhttps://zhuanlan.zhihu.com/p/272891398\nhttps://www.zhihu.com/question/26943558（异步IO）\nhttps://blog.csdn.net/liuruiqun/article/details/51162651\nhttps://blog.csdn.net/lailaiquququ11/article/details/83066593\nhttps://blog.csdn.net/leyangjun/article/details/62236241\nhttps://blog.csdn.net/lihao21/article/details/67631516（水平触发和边缘触发）\nhttps://blog.csdn.net/weixin_49199646/article/details/112298712（水平触发和边缘触发）\nhttps://cloud.tencent.com/developer/article/1992988\nhttps://www.cnblogs.com/xcywt/p/8146094.html\nhttps://www.51cto.com/article/665184.html"}},"/tutorial/operating-system/13":{"title":"6.2.驱动","data":{"":"设备文件通过设备号绑定了设备驱动，fops 绑定了应用层的 write 和驱动层的 write。当应用层写一个设备文件的时候，系统找到对应的设备驱动，再通过 fops 找到对应的驱动 write 函数。\nhttps://www.cnblogs.com/alantu2018/p/8460365.html"}},"/tutorial/operating-system/14":{"title":"6.存储管理","data":{"":"一个完整的文件数据包含元数据和数据体，其中元数据保存在目录结构中（目录结构保存在外存上）。其中，文件的元数据保存了文件的位置和大小，用来获取数据的起始位置和文件占据的空间长度（从而获得该文件在内存中的边界）。此外，元数据还描述了类型、标识符、名称、保护（权限控制）、时间等信息。文件的元数据在操作系统中也被叫做文件控制块(FCB, file control block)，它一般包括以下信息：\n和 PCB 只驻留在内存中不同，FCB 和文件数据一同存储在外存中。但在对文件进行操作时，操作系统会把相应的目录信息读入内存（并更新），最后写回磁盘（如有更新）。\n\n文件指针\n文件打开计数器\n文件磁盘位置\n访问权限\n...","文件需要支持的接口#文件需要支持的接口":"文件属于抽象数据类型。\n创建(touch)\nIO(read/write)\n重定位(seek)\n删除(rm)","目录结构需要支持的接口#目录结构需要支持的接口":"需要支持对目录和文件的：\n搜索\n创建\n删除\n遍历\n重命名\n状态跟踪（当文件产生变化时）","硬链接不能链接目录的原因#硬链接不能链接目录的原因":"硬链接为目录时，有可能出现环型结构，目录树中会产生带环的图结构。带环的图结构无论是在搜索时，还是在删除时，都需要额外的处理，否则就容易导致无限循环或者无法删除。因此简单的做法是直接不允许建立目录上的硬链接。\n硬链接到文件只会构建出一个无环图","虚拟文件系统vfs#虚拟文件系统（VFS）":"[ ]\n\n\n[ ]\n\n\n[ ]\n\n\nhttp://c.biancheng.net/view/3066.html"}},"/tutorial/operating-system/15":{"title":"7.保护与安全","data":{"":""}},"/tutorial/operating-system/16":{"title":"8.总结与辨析","data":{"":""}},"/tutorial/operating-system/17":{"title":"README","data":{"":"在复习完两遍操作系统后，我认为理解操作系统，可以抓住两条线，一条是 CPU 指令执行，这包括指令周期过程涉及到的硬件是如何交互的（PC、译码器、寄存器），也包括中断是如何完成的。另一条是内存管理，了解计算机是如何寻址、编址的。有了这两条线提供的知识储备后，我们就可以继续了解一些较为独立的知识，比如锁、IO、进程调度等相对偏软件方面的内容。\n内存管理\n硬件层面\n编址与寻址\nMMU\n虚拟地址<->物理地址\n多级页表支持\n\n\n\n\n页操作\n页高速缓存\n页回写\n\n\n\n\n操作系统层面\n分页、分段\n页表、多级页表、TLB\n\n\n内存分配\nBuddy 分配器\nSlab、Slub 分配器\n常用分配和回收内存接口：malloc、kmalloc,...\n\n\n内核空间、用户空间\n高端地址\n\n\nmm_struct\n\n\n\n\n进程管理\ntask_struct/thread_info\n\n\n\n理解中断，阅读 list：\nhttps://mp.weixin.qq.com/s/axLZBYJr3vqRwt5ITht2uw\n\n\n《Linux 内核之旅》http://kerneltravel.net/book/\n《操作系统概念第七版》\n中断\nhttps://web.xidian.edu.cn/mhdong/files/5fc6160c5f7c8.pdf\nhttps://blog.csdn.net/farmwang/article/details/52337690\nhttps://www.cnblogs.com/Courage129/p/14310441.html\nhttps://sites.google.com/site/xylinuxkernel/Home\n\n\nhttps://cloud.tencent.com/developer/article/1815965"}},"/tutorial/operating-system/18":{"title":"上下文切换","data":{"":"上下文切换类型上下文还分为了三种类型，分别是：\n进程上下文切换\n线程上下文切换\n中断上下文切换\n\n进程上下文切换进程上下文切换指的是不同进程之间发生切换。一般来说，进程被调度有如下几个时机：\n某个进程时间片耗尽，会被系统挂起，切换到其他等待 CPU 的进程。\n进程所需系统资源不足，需要等到资源满足时才可运行，此时会被挂起，其他进程会被调度。\n进程通过 sleep 方法主动挂起，其他进程就有机会被调度。\n有更高优先级的进程，当前进程会被挂起，高优先级进程会被调度。\n硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。\n\n当发生如上几种情况的时候，就会发生进程调度，进而发生进程上下文切换。进程是资源分配的基本单位，线程是调度的基本单位，进程只是给线程提供了虚拟内存等资源。线程上下文切换，就可以分为两种情况：\n进程调度前后的两个线程，属于同一进程：此时因为资源共享，所以在切换的时候虚拟内存等这些资源就不需要变化，只需要切换线程的私有数据、寄存器等不共享的数据。\n进程调度前后的两个线程，不属于同一进程：这时候因为资源部共享，所以切换过程和进程上下文切换是一样的。\n\n因此同进程内的线程切换，要比多进程间的切换消耗更少的资源，这其实就是多线程比起多进程的一个优势。为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其它进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以即便中断过程打断了一个正在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。对同一个 CPU 来说，中断处理比进程拥有更高的优先级，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，当发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。\nhttps://www.zhihu.com/question/23199395\n\nLinux 内核调度的单位是 task_struct 用来标识一个调度单位（线程）。同一个进程的多个线程内的 tgid 相同，虚拟内存地址相同。创建进程和线程时，都是系统调用相同的内核函数 do_fork，该函数的主要工作是创建 task_strcut 结构体，只是传入的参数不同，从而影响了最终资源的分配策略。\nhttps://blog.csdn.net/qq_28351465/article/details/88950311\nhttps://www.cnblogs.com/cangqinglang/p/12455444.html"}},"/tutorial/operating-system/2":{"title":"2.1.中断","data":{"":"CPU 通过指令计数器（PC）存储当前要执行的指令的内存地址，并通过译码器、寄存器等硬件实现指令的执行，这是一个串行的过程。中断的设计允许 CPU 在一个指令周期结束后，可以转去执行其他的程序（中断服务程序），在执行完后再返回原来被中断的程序。中断的支持让 CPU 可以灵活的执行指令，从而能进一步的实现多道程序的运行（并发）、故障处理等功能。\n如果没有中断，不谈故障处理、多道程序等逻辑的实现，仅检查一个设备是否完成指令这一功能，就只能通过忙等待（Busy waiting），轮询设备来得到设备返回的结果，从而造成大量的 CPU 时间被浪费。","中断的类型#中断的类型":"根据中断的来源（中断源），可以分：\n外部中断源（硬中断）：由外部硬件产生的信号，如键盘、打印机的中断信号\n软中断（softirq）：对于一些处理时间较长的硬件中断，为了保证 CPU 关中断的时间很短，所以将中断分为上半部分和下半部分，下半部分也被称为软中断。\n\n\n内部中断源（软件中断）：由程序错误等产生的中断，如溢出、除 0 等。\n\n根据中断的产生时期，可以分为同步(synchronous)中断和异步(asynchronous)中断：\n同步中断是当指令执行时由 CPU 控制单元产生，比如系统调用，发生时，CPU 在执行下一条指令前一定会进入中断服务程序。\n异步中断是指由其他硬件设备产生的中断，产生的时刻不确定，且与 CPU 的执行无关，也称外部中断。\n\n根据中断源，可以将中断分为中断（Interrupt，来自 IO 设备）和异常（Exception，来自程序或 CPU 指令）。其中，异常可以进一步分为陷阱（trap，有意的异常，如系统调用）、故障（fault，潜在可恢复的错误）、终止（abort，不可恢复的错误）三种。根据中断是否可以被屏蔽，分为可屏蔽中断和不可屏蔽中断。异常都是不可屏蔽中断，而硬中断中有一部分是可屏蔽中断。\n根据 Intel 官方资料，同步中断称为异常(exception)，异步中断被称为中断(interrupt)。\nhttps://zhuanlan.zhihu.com/p/436901855","中断需要的硬件支持#中断需要的硬件支持":"中断的实现需要相应的硬件支持，这包括：\n可编程中断控制器（Programmable Interrupt Controller，PIC，常见的有 8259A/APIC）：用于管理中断请求。其他 IO 设备向该控制器发出中断请求，再由中断控制器向 CPU 发送 INT（中断请求信号）。在这过程中包含了中断判优、中断嵌套、中断屏蔽相关的逻辑。\n状态寄存器 IF（Interrupt Flag） 位：用于控制 CPU 是否可以响应外部的可屏蔽中断请求，为 1 为可以响应。使用 sti 指令可将 IF 位置 1；使用 cli 指令置 0。IF 在一些地方也叫允许中断触发器（EINT）?。\nINTR 引脚：位于 CPU ，接受来自中断控制器发送的 INT 中断请求信号。\nINTA 引脚：Interrupt Acknowledgement，中断响应信号，位于中断控制器，用于 CPU 在指令周期结束后回应中断控制器。\nNMI 引脚：用于不可屏蔽中断，无论状态寄存器中 IF 位的状态如何,CPU 收到有效的 NMI 必须进行响应。NMI 是上升沿有效; 中断类型号固定为 2; 它在被响应时无中断响应周期.不可屏蔽中断通常用于故障处理(如:协处理器运算出错,存储器校验出错,I/O 通道校验出错等).\n中断向量表寄存器：用于存储中断向量的入口地址（用于保护模式中）\n\n\n中断可以被看成是操作系统级别的一种“回调函数”，不要因为中断本身可能带有的负面含义认为中断是某种不好的事件。","中断服务程序的流程#中断服务程序的流程":"保护现场，包括\n保存程序的断点：通过中断隐指令完成，即由机器自行完成\n保存通用寄存器和状态寄存器的内容：通过中断服务程序完成，即在中断服务程序的起始部份安排若干条存数指令，将寄存器的内容存到存储器中或堆栈中。\n\n\n中断服务：因不同的中断请求源而异\n恢复现场：中断服务程序的结尾部份，将原程序中断时的现场恢复到原来的寄存器中。\n中断返回：返回到中断前原程序的断点处，以便在下一个指令周期继续执行原程序","中断服务程序的入口地址中断向量表#中断服务程序的入口地址（中断向量表）":"中断服务程序的执行首先需要该程序的入口地址，叫做中断向量，也称为中断指针。Intel x86 系列微机共支持 256 种向量中断，所有的中断类型都可以由一个 8 位（一个字节）的无符号整数表示，每个中断向量的长度是四个字节。在全部 256 个中断中，前 32 个（0—31）为硬件系统所预留。后 224 个可由用户设定。需要有一个内存空间来存储所有的中断向量，这样的内存空间叫做中断向量表，也称为中断描述符表 IDT（Interrupt Descriptor Table）。在实地址模式中，CPU 把内存中从 0 开始的 1K 字节作为中断向量表的地址空间，存储这 256 个中断向量（4B*256 = 1K）。在保护模式中，中断向量表的基地址和大小通过中断向量表寄存器 IDTR 存储。IDTR 是 48 位的寄存器，其低 16 位保存中断描述符表的大小，高 32 位保存 IDT 的基址。","中断应用#中断应用*":"中断可以出现任何对及时处理某个事件或现象的需求中。\n时钟：用于定时发出一个用于上下文切换的中断\n人为设置的中断\n程序性事故（如浮点溢出、操作码不能识别等）\n硬件故障（电源掉电、接触不良等）\nIO 设备（用于通知设备状态的变化，如准备就绪）\n外部事件（如键盘的 CTRL+C）","中断周期#中断周期":"中断周期中 CPU 需要完成的操作包括：中断隐指令的执行：\n保护程序断点：将当前 PC 内容存到存储器特定单元（如 0 地址）或堆栈中。\n寻找中断服务程序的入口地址（通过硬件向量法或中断识别程序等方法获得），从而转去执行该设备的中断服务程序\n关中断：禁止 CPU 再次响应新的中断请求\n\n\n中断隐指令：在机器指令系统中没有的指令，是 CPU 在中短周期内由硬件自动完成的一条指令。\n？中断周期是否只是中断服务程序执行前的一个前处理过程？中断服务程序是否还会消耗若干个指令周期才结束？\n中断服务程序的最后一条指令是中断返回指令，即中断返回至原程序的断点处。","中断响应的时间#中断响应的时间":"CPU 在执行周期结束时刻统一向所有中断源发送中断查询信号。在指令执行周期结束后，如果有中断，则 CPU 进入中断周期，否则进入下一条指令的取值周期。\n在一些情况下，指令执行时间较长，此时可以在执行过程中设置若干个查询断点，在断点时刻发送中断查询信号并响应。","硬中断-软中断的逻辑#硬中断->软中断的逻辑":"?","系统调用的逻辑#系统调用的逻辑":"open/write/read 都是系统调用函数，这些函数的调用大多发生的用户态，但是实际执行是在内核态。系统调用的完整过程为用户态调用->内核态执行->用户态获得结果，这样一个用户态/内核态切换的过程也叫做陷阱（trap）。Linux 中，以 open 为例，系统调用一般的过程为：\n用户态的程序调用 open 函数\n系统调用代号存入 eax 寄存器，调用 syscall 指令进入内核态\n根据系统调用号在 sys_call_table 表中查找 open 对应的内核函数 sys_open\nsys_open 调用 SyS_open(其实只是 alias 而已)\nSyS_open 调用 SYSC_open\nSYSC_open 为实际函数实现，执行实际操作\n返回值存放到 rax 寄存器，调用 retq 指令返回用户态\n\n\n处理器间中断（interprocessor interrupt）。一种特殊的硬件中断。由处理器发出，被其它处理器接收。仅见于多处理器系统，以便于处理器间通信或同步。\n伪中断（spurious interrupt）。一类不希望被产生的硬件中断。发生的原因有很多种，如中断线路上电气信号异常，或是中断请求设备本身有问题。"}},"/tutorial/operating-system/3":{"title":"2.CPU","data":{"":"取指令\n间址\n\n\n分析指令\n执行指令\n\nCPU 完成一条指令的时间称为指令周期，指令周期可以进一步细分为四个阶段：\n在大多数情况下，CPu 就是按 取址->执行->取址->执行 的顺序自动完成工作的。\n不同的指令的执行周期长度不同，如 JUMP 指令没有执行周期，如乘法指令的执行周期比加法指令长：一个完整的指令周期可以用如下的流程图表示，其中间址周期和中断周期不一定发生，因此可以用菱形框判断：","指令周期的数据流#指令周期的数据流":"一个指令周期包含多个计算机的原子操作过程。如：\n取值周期：从程序计数器取地址（PC->MAR）、读地址数据（1->R）、MAR->MDR、MDR->IR、译码 OP(IR)->CU、PC+1\n间址周期（Optional）：取指令的地址码部份送至 MAR（Ad(IR)->MAR）、读地址数据（1->R）、MAR->MDR、MDR->Ad(IR)\n执行周期：非访存指令、访存指令、转移类指令等\n\n由于不同的周期会导致设备的空闲，因此通过流水线来加速指令的执行。一个理想情况下的二级流水可以减少一半的执行时间：\n实际执行过程中，因为执行周期大于取址周期，条件转移命令的不可判别等原因，不可能实现减少一半执行时间这种情况。\n\nhttps://blog.csdn.net/weixin_43455581/article/details/106249040\n\n内核需要做的时间管理：1）提供系统调度所使用的 tick 中断2）维护系统时间3）维护软件定时器，高速 tcp 和多媒体应用要使 timer 高效精准为了更好的支持音视频等需求，提出了 hrtimer 这个高精度时钟子系统，为了节约能源，采用了 tickless 子系统。内核中有两种时间：定时出发滴答的时钟中断，时钟中断用来维护系统时间，保持设备上的时间的正确性。时钟中断用来控制进程的调度，在每个时钟中断的处理函数中，都会处理一遍进程调度队列，将满足调度的进程放入就绪队列中。时钟中断可以用来实现用户的定时器设置，但是这种方式实现的定时器精度低且代价昂贵。另一种可编程的控制器，能够设定时钟时间并返回中断内核使用一系列的子系统兼容旧的机制，支持新的需求，比如 tickless 方案，hrtimer，时间轮算法等。\nhttps://blog.csdn.net/weixin_43455581/article/details/106249040\nhttps://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"}},"/tutorial/operating-system/4":{"title":"3.操作系统","data":{"":"操作系统是管理计算机硬件的软件，是作为计算机硬件和计算机用户之间的中介的程序，用于提供给用户方便且有效执行程序的环境。操作系统一般被分块构造，每一块都是系统中明确定义的一部分，具有严格定义的输入、输出和功能。\n用户视角下，操作系统帮助用户调度计算机资源（），确保资源被充分且合理（权限控制）的利用。操作系统可以被看做是一个资源分配器。操作系统管理 CPU（CPU 时间）和 IO（内存空间、文件存储空间、其他 IO 设备等），避免冲突，保证资源公平有效的分配。\n这里还很乱没梳理\n\n\nIO 引擎 https://zhuanlan.zhihu.com/p/334658432\n用户程序运行在用户态,操作系统内核运行在内核态。\n内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。\n用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。","用户态到内核态的切换#用户态到内核态的切换":"https://zhuanlan.zhihu.com/p/373966882\n处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。\n系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。\n异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。\n外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。\n\n\n程序是被动实体，是存储在磁盘上包含一系列指令（而不占用资源）的文件内容（即可执行文件）。\n进程是活动实体，存储在内存中，除了指令外，还包括一个程序计数器（表示该进程下一个要执行的命令地址）和相关资源集合（占用的内存和设备资源）。\n\n一个程序可以被多次启动，成为多个进程，这些进程之间可能代码段相同，但数据段、堆栈却互不不同（占用不同的内存空间）。","进程的生命周期#进程的生命周期":"","进程控制快#进程控制快":"每个进程在操作系统内通过进程控制块（PCB，process control block）来表示：\n进程控制块存储在内核空间中，参见 https://stackoverflow.com/a/29393046/11185460\nPCB 中的程序计数器记录了该进程中下一个应该访问的指令，打开文件列表记录了该进程占用的文件资源...。可以说 PCB 存储了部份数据和全部进程占用资源的索引，PCB + 占用资源（内存、文件、设备）完整的描述了一个进程。"}},"/tutorial/operating-system/5":{"title":"4.1.锁与死锁","data":{"":"锁可以看成是一种对资源的占用声明，表明对其他进程在该资源上读操作或者写操作的 Lock（锁定）。当一个进程对一份资源有读的需求时，就需要声明一个读锁（共享锁），表明该资源对其他所有进程来说只能读；当一个进程对一份资源有写的需求时，就需要声明一个写锁（排它锁），表明该资源不可被其他任何进程占有。根据具体场景对读/写操作的侧重，就衍生出了各种对锁的叫法。锁可以在硬件（通过专用于锁的寄存器）或软件层面实现。? 申请锁->操作->释放锁的过程，称为临界区。","一些理所当然的锁概念#一些理所当然的锁概念":"可重入锁：当一个线程的一个方法获得对一个资源的锁时，另一个方法操作该资源可以不被阻塞（即锁是线程级别的，而不是方法级别的）。\n分段锁：细化锁的粒度提高性能。\n公平锁/非公平锁：表示锁的获取顺序是公平的（所有的线程入先出）的还是非公平的（不同线程有优先级）。\n读优先锁/写优先锁/公平读写锁：是申请读锁优先还是写锁优先还是先入先出。读优先或写优先都会导致【饥饿】现象，即另外一种操作无法申请到锁。\n\n一种启发式的分配锁的方式。\nhttps://www.jianshu.com/p/338db6d64c1e\n\n偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。\n轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。\n重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。\n\n\n自旋锁是让线程在申请锁的过程中不断检查该锁是否可以获取。线程在这一过程中处于无限循环（忙等待）状态。自旋锁避免了进程上下文的切换开销，适用于多核、短时间阻塞的场景。\n互斥锁则会在申请锁失败时放弃获取（并休眠），等待在锁空闲时被唤醒。","排号自旋锁#排号自旋锁":"排号自旋锁类似于饭店排号，每个申请自旋锁的线程按序号分配锁的编号 i，当一个线程释放锁时，锁编号自动加 1，让下一个线程在检查时直接获得锁。（申请锁的开销由 $O(N)$ 降为 $O(1)$ ）这里的乐观和悲观表示的是对资源是否会被更新、更新是否频繁的态度。\n乐观并发控制（Optimistic Concurrency Control），也叫乐观锁。该锁假设并发访问中数据不会更新（或不会被频繁更新）。因此采用先修改再确认的激进策略修改数据。\n悲观并发控制(Pessimistic Concurrency Control)，也被翻译为悲观锁。该锁假设并发访问中数据会被频繁更新，因此采用先取锁再访问的保守策略","cas-算法#CAS 算法":"CAS(Compare and Swap) 是一种无锁算法，一般用于乐观并发控制场景中。CAS 操作涉及 3 个操作数，内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B。CAS 假设共享数据不会被其他进程修改。因此当只有一个进程有写需求时，CAS 算法能够比较高效的更新内存值。当有两个及以上的进程并发更新时，没有检查通过的进程会不断循环回滚事务。","aba-问题#ABA 问题":"一个线程将内存值从 A 改为 B，另一个线程又从 B 改回到 A。该问题可以通过在变量前面添加版本号的方式来解决。一次仅允许一个进程使用的资源称为临界资源。临界区问题（critical-section problem）是设计一个用于多进程协作的协议，保证临界资源能够被有效利用。有效利用的具体要求：\n互斥：同一时间只有一个进程在临界区（保证原子性，即数据更新不会出错）\n前进：所有进程不能阻塞（保证系统整体不会阻塞）\n有限等待：每个进程不能存在饥饿（保证公平）\n\n原子操作指的是最小的不可并行化的对共享资源的操作。当说一个操作（比如一段代码）是原子化的，意味着同一时间只能有一个线程执行该操作（代码）。","原子操作-test-and-set#原子操作: test-and-set":"[ ]\n\n所有线程都在等待其他线程已经申请的资源的释放。死锁出现的必要条件：\n互斥\n占有并等待\n循环等待\n\n\n非抢占\n\n应对死锁的方法：\n预防\n死锁预防：保证死锁条件至少一个不出现\n死锁避免：要求事先获得进程对所有资源的要求，通过资源分配图算法或银行家算法避免会导致死锁的资源分配。\n\n\n检测并恢复\n死锁检测：有各种检测算法\n死锁恢复：终止进程 & 抢占资源\n\n\n忽视（目前主流方法）"}},"/tutorial/operating-system/6":{"title":"4.2.1.进程通信","data":{"":"信号本质上是在操作系统层次上对中断机制的一种模拟。Linux 下信号有 62 种，可以通过 kill -l 命令列出。\n1) SIGHUP\t 2) SIGINT\t 3) SIGQUIT\t 4) SIGILL\t 5) SIGTRAP\n6) SIGABRT\t 7) SIGBUS\t 8) SIGFPE\t 9) SIGKILL\t10) SIGUSR1\n11) SIGSEGV\t12) SIGUSR2\t13) SIGPIPE\t14) SIGALRM\t15) SIGTERM\n16) SIGSTKFLT\t17) SIGCHLD\t18) SIGCONT\t19) SIGSTOP\t20) SIGTSTP\n21) SIGTTIN\t22) SIGTTOU\t23) SIGURG\t24) SIGXCPU\t25) SIGXFSZ\n26) SIGVTALRM\t27) SIGPROF\t28) SIGWINCH\t29) SIGIO\t30) SIGPWR\n31) SIGSYS\t34) SIGRTMIN\t35) SIGRTMIN+1\t36) SIGRTMIN+2\t37) SIGRTMIN+3\n38) SIGRTMIN+4\t39) SIGRTMIN+5\t40) SIGRTMIN+6\t41) SIGRTMIN+7\t42) SIGRTMIN+8\n43) SIGRTMIN+9\t44) SIGRTMIN+10\t45) SIGRTMIN+11\t46) SIGRTMIN+12\t47) SIGRTMIN+13\n48) SIGRTMIN+14\t49) SIGRTMIN+15\t50) SIGRTMAX-14\t51) SIGRTMAX-13\t52) SIGRTMAX-12\n53) SIGRTMAX-11\t54) SIGRTMAX-10\t55) SIGRTMAX-9\t56) SIGRTMAX-8\t57) SIGRTMAX-7\n58) SIGRTMAX-6\t59) SIGRTMAX-5\t60) SIGRTMAX-4\t61) SIGRTMAX-3\t62) SIGRTMAX-2\n63) SIGRTMAX-1\t64) SIGRTMAX\n其中前 31 种（1-31）为早期实现，存在一些问题，为了兼容性一直保留，称为不可靠信号，后 31 种为改进信号机制后新添加的实现，称为可靠信号。不可靠信号的问题：\n进程设置的信号处理函数是一次性的，会在调用后被设置为默认信号处理函数，除非用户在信号处理函数的结尾重新注册。\n信号可能因为短时间内出现多次而丢失（因为缺少排队机制）","信号的生命周期#信号的生命周期":"信号的整个生命周期包括发送、接收和处理，除了发送初始和信号处理函数执行的过程外，信号的其余生命周期均在内核态中，由操作系统控制。产生信号的几种基本方式：\n信号发送\nshell 下通过键盘发送信号给前台进程。如 Ctrl+C 产生 SIGINT 信号，Ctrl+\\ 产生 SIGQUIT 信号，Ctrl+Z 产生 SIGTSTP 信号\n硬件异常，通过中断服务程序发送给进程。如除零异常会被内核解释为 SIGFPE 信号发送给进程；⾮法访问内存异常会被内核解释为 SIGSEGV 信号发送给进程\n由进程发送给另⼀个进程。如通过 kill 命令发送 SIGTERM 信号\n软件条件产生。如进程时钟事件定期产⽣ SIGALRM 信号；向读端已关闭的管道写数据时产⽣ SIGPIPE 信号。\n\n\n信号接收：操作系统在接收到来自发送方发送的信号并检查合法后，将信号在信号图中进行标记（早期不可靠信号）或添加到进程的信号队列（可靠信号）中。\n信号处理：Linux 会在进程从内核态重新返回用户态时（如多道程序切换上下文被唤醒时）检查该进程的信号队列，如果该进程信号队列有信号，那就优先依次调用该进程的信号处理函数。","信号处理函数#信号处理函数":"除了特殊信号（SIGKILL 等）外，大多数信号支持进程自行注册信号处理函数加以处理。信号处理函数由用户进程注册，因此位于用户态。当操作系统调用信号处理函数时会切换到用户态执行该信号处理函数，再调用完后会再次回到内核态恢复到原进程执行。在这一过程中，信号处理函数可以看作该进程的一个特殊子线程。\n线程的定义是程序的最小执行单元，信号处理函数的执行过程完全符合这一定义","信号忽略#信号忽略":"可以通过设置信号处理函数为 SIG_IGN 或者注册空信号处理函数来忽略可忽略的信号。管道的本质是处于内核空间的一块内存，由操作系统封装为文件描述符的形式，提供给进程用于 IO。因此，管道的 IO 都需要通过系统调用来实现。\n信号\nhttps://zhuanlan.zhihu.com/p/79062142\nhttps://blog.csdn.net/wangquan1992/article/details/108511628\nhttps://zhuanlan.zhihu.com/p/77598393\nhttps://zhuanlan.zhihu.com/p/79062142\nhttps://zhuanlan.zhihu.com/p/77627175\nhttps://blog.csdn.net/sofia_m/article/details/79834179"}},"/tutorial/operating-system/7":{"title":"4.2.进程、线程、协程","data":{"":"Linux 进程的不可中断休眠与可中断休眠状态\nhttps://blog.csdn.net/wen6955/article/details/124585759\n\ntop 命令的 S 列（State）标记了进程的状态。其中：\nR 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。\nD 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。\nS 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。\nZ 是 Zombie 的缩写，它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。\nI 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。\nT 或者 t，是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。\nX，是 Dead 的缩写，表示进程已经消亡，top 或者 ps 命令中不会看到它。\n\n可以通过 man ps 查看进程状态\nhttps://learnku.com/articles/39851"}},"/tutorial/operating-system/8":{"title":"4.3.进程资源","data":{"":"进程在 Linux 内核中的进程描述符以 task_struct 的数据结构表示，这包括：\n\n程序计数器（PC）和栈指针（SP）寄存器\n通用寄存器\n浮点寄存器\n包含 CPU 状态信息的处理器控制寄存器（处理器状态字，Processor Status Word）\n跟踪进程对 RAM 访问的内存管理寄存器\n虚拟内存（task_struct -> mm_struct mm），包括\n可执行代码\n初始化和未初始化数据\n初始程序栈\n共享库的可执行代码和数据\n堆\n\n\n\n这些内存因为现代 Unix 采用按需调页的内存分配策略，因此在初始时只有页表，并在访问时通过 MMU 产生的缺页中断来进行按需调页。这一过程在进程复制时还伴随着写时复制等技术。\nhttps://blog.csdn.net/LF_2016/article/details/54346121"}},"/tutorial/operating-system/9":{"title":"4.进程管理","data":{"":"进程是操作系统分配资源的最小单位。静态的程序可以看做是一段机器指令（一串二进制序列），当程序通过操作系统加载进内存后，除了指令外，还会有该程序的状态（如页表）、申请的资源（内存、设备、文件）等。线程是进程中的实际运行单位。进程内的每个线程共享该进程的内存（堆内存）、全局变量、文件描述符等资源，每个线程各自有各自的状态（如程序计数器）和空间（如栈空间）。硬件对中断的支持，允许操作系统通过实现程序并发的执行（多道程序）。通过硬件内置的时钟计时器发出的定时中断，操作系统可以在某个 CPU 周期结束后，通过中断服务程序选择另外一个线程执行，这个过程叫做上下文切换。因为每个线程有各自的程序计数器，因此说线程是操作系统调度的最小单位。在线程上下文切换时，如果两个线程所属的进程不相同，那么就会将进程的全部状态暂存，否则只需要将该线程所属的状态暂存。因此，单进程的多线程的上下文切换开销要小于多进程（自然也是多线程）的上下文切换开销。","内核线程#内核线程":"上下文切换时，涉及到对当前线程状态的暂存，因此存在一些操作状态寄存器、程序计数器等位于内核内存空间数据的步骤，这些操作是由内核线程完成的。? 线程的属性是状态和资源，这部分存在内存空间和寄存器上，所以切换寄存器就等于切换了一个线程，而某些状态寄存器标识了线程的权限，决定了该线程是内核线程还是用户线程，访问的是内核空间还是用户空间。","抢占式调度--非抢占式调度#抢占式调度 & 非抢占式调度":"抢占式调度：进程在当前的指令周期结束结束后可能会因为各种原因被其他进程抢占。\n非抢占式调度：如何分配当前要执行的进程不重要，但是分配的进程在结束之前不能被其他进程抢占很重要。","调度指标#调度指标*":"CPU 使用率\n吞吐量\n周转时间\n等待时间\n响应时间\n\n\n先到先服务\n最短作业优先调度\n优先级调度\n轮询\n多级队列调度\n...\n多处理器调度\n...\n\n进程的用户地址空间各自独立。因此在进程间交换数据必须要通过内核。这一过程叫做进程间通信 IPC (InterProcess Communication)目前进程间通信的方式主要有：\n管道：半双工（单向流动），通过一块内核缓冲区实现\n匿名管道（pipe）：一般用于父进程和子进程之间单向消息传递\n高级管道（Popen）\n命名管道（FIFO）：可以用于非亲缘关系之间通话。名字存放在\n\n\n信号（Signal）：异步方式发送，如 kill 等，属于软中断。程序中可以注册信号处理函数（否则使用默认的信号处理函数），即中断服务程序。信号处理函数执行时，会有进程的上下文切换（将原进程切换到中断服务程序）。\n消息队列（message queue）：和管道类似，比管道在一些场景下更适合\n共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式。一般配合信号量等机制使用。不同的进程拥有不同的虚拟内存地址，但都映射到相同的物理内存地址。\n内存映射（mmap）\n\n\n信号量（semaphore）：存储在内核中的一个变量，通常用于进程间同步或锁机制的实现。\n套接字（网络通信）：一般用于网络通信。通过本地回环（127.0.0.1）也可以进行本地通信，但因为仍然需要封装抱头等网络协议的数据结构，所以本地的极限效率相对消息队列等要慢\n\n\n经云评测，在 socket 时长连接的情况下，消息队列大概比 socket 方式快 10% 左右","进程同步#进程同步":"进程同步是进程间通信的一个常见场景。当进程和进程之间需要交换数据或者共同使用一块数据时，需要确保更改过程是原子化的，也就是任一进程操作时其他进程不能操作。操作的这一段过程被称作临界区，临界区问题是需要设计算法保证进程能够原子化的在临界区协作。进入区一般伴随着写锁的申请。\n线程安全的单例模式 https://www.cnblogs.com/xiaolincoding/p/11437231.html\n\n\nhttps://cloud.tencent.com/developer/article/1897179\nhttps://www.cnblogs.com/alantu2018/p/8526916.html"}},"/tutorial/operating-system":{"title":"Index","data":{"":""}},"/tutorial/operating-system/linux-kernel/0":{"title":"1.0.寻址","data":{"":"寻址并不是寻找地址本身，而是寻找给定内存地址对应的内存数据，为了直观一些可以改叫访存。访存的基本原理是将要访问的地址通过地址总线输入存储器，在触发后，数据随着数据总线进出存储器。CPU 的所有指令操作可以被分为访存和非访存两种，非访存操作只涉及到 CPU 内部的运算单元和寄存器操作，访存操作则涉及到 CPU 内寄存器到物理内存的读写。\n访存操作整体上包括控制单元对指令地址的读操作、数据单元对数据地址的读写操作\n现代计算机体系结构下的访存操作，大多都离不开分页技术，因此先介绍分页。","页表#页表":"访存有实模式和保护模式两种。实模式下，CPU 访存请求中的地址是真实的物理地址（PA，Physical Address），可以直接通过地址总线输入到存储器；而在保护模式下，该地址被称为虚拟地址（VA，Virtual Adress），需要进一步转换为真实的物理地址。保护模式相比于实模式，可以看成是加了一个中间函数 f(VA, flag) = PA（或字典 dic[VA,flag] = PA），这一函数建立了一个从虚拟地址到物理地址的多对一映射。虚拟地址的优点包括：\n每个用户进程的地址都可以从 0 开始\n虚拟地址空间可以远远大于物理地址（通过按需调页（demand paging）这种懒加载思想和交换（swap）技术）\n在硬件层面上支持对用户访存是否合法的检查\n...\n\n这一转换过程在大多数情况下需要去存储 VA->PA 这样一个映射关系，为了减少映射关系的存储开销，大多数有虚拟地址支持的系统都采用了分页（paging）技术。假设存储一个 VA->PA 的映射关系需要 4B=32bit，4GB 内存为例，如果以 4KB 为单位将内存分块，那么一共能分成 $4GB/4KB = 2^{20}$ 个块。即使用 $2^{20} * 4B = 4MB$大小的内存就可以存储所有的映射关系。在这过程中，分块即是分页（paging），VA->PA 这样的映射关系被称为页表项，而存储页表项数组的数据结构或内存空间被称为页表。每个进程都会有一个页表，此外内核也会分配页表【高端内存和非高端内存是否都有页表？】。页表会随机存放在内核空间中，通过页基址来定位。此外，页表必须包含全部的虚拟地址空间。","va-pa#VA->PA":"分页技术通过页基址、页号、页偏移三个参数来定位真实物理地址：\n页基址：用于定位一个页表的初始地址\n页号：用来定位页表中的某个页表项，页表项中存储了物理内存的块号。页号和块号的最大数量等同\n页偏移：用来定位一个页内的具体的某个地址单元\n\n分页过程中，虚拟地址到物理地址的转换过程，实质是将一个地址的前 n 位重映射的一个过程。一个物理内存块会分配一个页表项，因此两者的最大数量是相同的，在 4G 内存 4KB 页大小下都是 $2^20$ 个，需要 20bit 长度的二进制序列来表示，而页内（也是块内）则有 4KB，即 $4*1024 byte = 2^12B$，因此需要 12bit 来表示。因此，32 位的虚拟地址在这种条件下被拆分成 20 位的页号和 12 位的页偏移两部分，其中页号可以通过页表项来映射到物理块号（页帧号，page frame number）。每个进程存放页表的地址并不固定（一定程度上增加了安全系数），该地址由页基址来表示，每个进程唯一确定一个页基址，在切换一个用户进程时，该进程的页基址会由操作系统写入到页基址寄存器中。在该进程访存时，MMU 接受 CPU 发出的虚拟地址，通过页基址寄存器找到该进程的页表，通过虚拟地址的页号部份找到页表项，得到物理块号，最终得到物理地址，实现最后的访存操作。\n存储页基址的寄存器：X86 体系架构下是控制寄存器 CR3(Control Register 3)；ARM-v7 体系架构下是协处理器 CP15 寄存器 TTBR(Tranlation Table Base Register)；ARM-v8 体系架构下系统寄存器 TTBR(Tranlation Table Base Register)。\n在 Linux 内核中，分页后每个物理内存块通过 struct page 描述，所有的page 会放到一个全局数组（mem_map）中，物理块号、页帧号等可以看成是该数组的下标，这两者可以通过内核函数 pfn_to_page/page_to_pfn 互相进行转换。","进程描述符#进程描述符":"Linux 内核中，每一个进程的进程描述符（PCB）用 struct task_struct 结构体表示，其中的 task_struct -> mm_struct 是该进程的内存描述符，描述了该进程的内存使用情况，这包括进程内分段后的各部分（数据段、代码短、堆栈）的地址区间，虚拟内存的使用情况等。其中，mm_struct 中的变量 mmap/mm_rb/mmap_cache 冗余的通过 struct vm_area_struct 结构体记录了每一个和进程相关的内存区域。每个进程拥有多个 struct vm_area_struct 数据，每个数据用来表示一段不同的连续虚拟内存区域，这包括：\n数据段（地址区间为 mm_struct->start_data,mm_struct->end_data）\n栈空间（起始地址为 mm_struct->start_stack，结束地址动态分配）\n代码段（地址区间为 mm_struct->start_code,mm_struct->end_code）\n堆空间（地址区间为 mm_struct->start_brk, mm_struct->brk，brk 可以通过系统调用 brk 来动态扩展）\n共享空间\n...\n\n上述的每一个区域，都由一个或多个 vm_area_struct 来描述，描述的内容包括地址、权限等，比如：\n// https://zhuanlan.zhihu.com/p/539591726\n// <mm_types.h>\nstruct vm_area_struct {\nstruct mm_struct * vm_mm; /* 所属地址空间。 */\nunsigned long vm_start; /* vm_mm内的起始地址。 */\nunsigned long vm_end; /* 在vm_mm内结束地址之后的第一个字节的地址。 */\n/* 各进程的虚拟内存区域链表，按地址排序 */\nstruct vm_area_struct *vm_next;\npgprot_t vm_page_prot; /* 该虚拟内存区域的访问权限。 */\nunsigned long vm_flags; /* 标志位 */\nstruct rb_node vm_rb;\n// 省略了部份\n// ...\n\n/* 用于处理该结构的各个函数指针。 */\nstruct vm_operations_struct * vm_ops;\n/* 后备存储器的有关信息： */\nunsigned long vm_pgoff; /* （vm_file内）的偏移量，单位是PAGE_SIZE，不是PAGE_CACHE_SIZE */\nstruct file * vm_file; /* 映射到的文件（可能是NULL）。 */\nvoid * vm_private_data; /* vm_pte（即共享内存） */\n};\nvm_area_struct->vm_ops 指向了针对该 vm_area_struct 结构特有的操作，包括：\n// <mm.h>\n// 不同版本可能不同\nstruct vm_operations_struct {\n// 指定内存区域加入到一个内存空间中\nvoid (*open)(struct vm_area_struct * area);\n// 指定区域从内存空间中删除\nvoid (*close)(struct vm_area_struct * area);\n// 物理页缺页时被（缺页中断服务程序）调用\nint (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);\n// 页面只读时被（缺页中断服务程序）调用\nint (*page_mkwrite)(struct vm_area_struct * area, struct vm_fault *vmf);\n// ... 省略其他\n};\n同时，Linux 内核提供了多个内核函数来查找指定地址是否位于某个进程的 vm_area_struct，判定虚拟地址是否有效：\n// 返回第一个大于 addr 的 vm_area_struct 结构，如果不存在返回 0\n// mm/mmap.c\nstruct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr)\n\n// 返回第一个小于 addr 的 vm_area_struct 结构，如果不存在返回 0\n// linux/mm.h -> mm/mmap.c\nstruct vm_area_struct * find_vma_prev(struct mm_struct *mm, unsigned long addr, struct vm_area_struct **pprev)\n\n// 内联函数，返回第一个和start_addr/end_addr  区间相交的 vm_area_struct 结构\n// #include<linux/mm.h>\nstatic inline struct vm_area_struct * find_vma_intersection(struct mm_struct* mm, unsigned long start_addr, unsigned long end_addr)\n一个进程有多个 vm_area_struct 和一个页表结构，需要区分这两者的作用：\n页表是描述了进程理论上可以获得的完整虚拟地址空间，如果进程理论上可以用的地址有 $2^20$ 个，那么页表项也有 $2^20$ 个（暂时不考虑多级页表）。\nvm_area_struct 描述了进程实际上正在使用的虚拟地址，并没有覆盖全部的虚拟地址。\n修改了 vm_area_struct 不一定会同时修改页表项，修改了页表项也不一定会同时修改 vm_area_struct\nMMU 通过一个进程的虚拟地址通过页基址和页号一定可以在内存中找到对应的页表项，但该页表项可能并没有分配相应的物理块号，或者操作不合法（只读页表项执行了写操作），此时，MMU 会发出缺页中断。\n此时内核会在中断服务程序中通过 find_vma 函数查找虚拟地址对应的 vm_area_struct ，如果查找到了有效的 vm_area_struct，则通过 vm_area_struct 中的 falut 等特殊调用为该页表项或多个页表项分配或重新分配相应的物理块号；如果没有查找到有效的 vm_area_struct，则该虚拟地址无效，报 stack overflow 错误。\n【确认下和 alloc_page 函数的关系】\n\n\n有效的 vm_area_struct 包括：地址空间位于某个 vm_area_struct 内或和某 vm_area_struct 的边界地址差值不超过 K，后者一般用于栈空间","懒加载#懒加载":"在进程对应的虚拟地址有效时，对应的页表项可能并没有分配物理块或没有分配合法的物理块。从节省内存的角度分析，可能是因为以下原因：\n按需调页：在加载进程时，不将全部的进程加载进内存，而是根据进程的执行在需要时分配内存动态加载。\n写时复制：进程 fork 时，子进程共享父进程的内存，仅在子进程对相应的内存有写操作时，才申请新的内存供子进程写。\n\n这些是典型的懒加载策略。这两个策略中，物理内存的动态分配体现在进程的页表项上，当按需调页或写时复制发生时，MMU 对相应的页表项的类型检查会失败，从而发出缺页中断，并在中断服务程序（do_page_fault）中修改页表项。","反向寻址反向映射#反向寻址（反向映射）":"反向寻址主要用于交换，需要在物理页换出（swap out）时将映射到该物理页的页表项逐一修改。可以参考这篇文章。"}},"/tutorial/operating-system/linux-kernel/1":{"title":"1.1.内存模型","data":{"":"不做额外支持（如 Physical Address Extension，即 PAE）的情况下，32 位系统的地址总线的寻址范围是 $2^32bit = 4GB$。在虚拟地址的支持下，此时每一个进程都会拥有 4G 的虚拟地址空间 0x00000000-0xffffffff。Linux 内核将其中 0-3G（0x00000000-0xc0000000） 划分为用户空间，3-4G（0xc0000000-0xffffffff）划分为内核空间（通过 #define PAGE_OFFSET 宏）。这种划分是人为设计的，还有诸多细节（如用户空间堆栈的初始位置、增长方向，内核空间 kernel image、vmalloc 内存区间等），称为虚拟内存模型（Virtual Memory Model）。\n一旦开启了保护模式，CPU 发出的访存操作必须经过 MMU。所以内核和进程的访存操作都必须使用虚拟地址。此时不重叠的用户空间和内核空间使进程陷入内核态时不需要切换内核页表和进程页表重新建立映射关系。\n其中，用户空间设定包括（具体的实例地址通过进程描述符 task_struct 表示）：\n用户栈\n堆\n代码段、数据段\n...\n\n内核空间设定包括：\nkernel image：内核代码段\nvmalloc，#define VMALLOC_START：虚拟内存中连续、但物理内存中不连续的内存区，可以在 vmalloc 区域通过 vmalloc 分配。\nswapper_pg_dir，#define KERNEL_RAM_VADDR，用于内核初始化时的页表项【？需要确认】\n#define FIXADDR_START\n#define CONFIG_VECTORS_BASE\n#define PKMAP_BASE/\n#define MODULES_VADDR\n一些空洞\n...","安全性分析#安全性分析":"在设定上，用户态禁止访问内核空间，内核态不建议直接访问用户空间。用户态禁止访问内核空间是为了避免用户执行不安全操作；内核态不建议直接访问用户空间是因为用户空间提供的指针可能是不安全或者无效的，需要通过copy_from_user/get_user 等函数将用户空间的数据拷贝到内核空间，再操作完后再通过 copy_to_user/put_user 将修改后的数据拷贝回用户空间。\n关于内核操作用户空间的 API，可以参考 这篇文章。","高端内存#高端内存":"32 位系统下，当物理内存小于 1G 时，内核态使用 1G 的虚拟内存空间，可以通过直接映射方式访问到全部的物理内存空间。但当物理内存大于 1G 时，1G 的虚拟内存空间会不够用。Linux 内核因此设计了高端内存这一概念，将内核的虚拟内存地址 3-4G 的空间中的前 896MB 定义为低端内存（low memory），其余的 128 MB 定义为高端内存（high memory）。低端地址采用直接映射的方式，减去 3G 的 OFFSET 直接访问 0-896MB 的物理地址；高端地址采用非直接映射的方式，通过永久映射和临时映射等方式，访问剩余的全部物理地址空间。此外，在物理内存空间中，0-896MB 定义为低端内存，该部分内存地址可以由内核态直接映射访问，896MB 后的剩余空间定义为物理地址空间下的高端内存，必须由内核态通过非直接映射的方式建立连接后访问。物理地址通过 struct zone_struct 划分为不同的管理区域，每一个 zone_struct 可以看成是一个 struct page 的集合，在 32 位系统下，这包括：\nZONE_DMA(0-16MB)，ISA 总线的直接内存存取（DMA）处理器有一个严格的限制：它们只能对内存的前 16MB 地址进行寻址。此外，DMA 使用需要连续的物理地址直接访问内存，不经过 MMU，因此 ZONE_DMA 为专门划分出的连续的物理区域用于 DMA。类似的区域在 64 位系统下还包括 ZONE_DMA32。\nZONE_NORMAL(16-896MB)，该区域的物理页面是内核能够直接使用的，通过虚拟地址直接减 3G 使用。即 物理地址 = 逻辑地址 – 0xC0000000 。0xC0000000 即 3G 的偏移大小。\nZONE_HIGHMEM(890-END)，内核不能直接使用，需要由内核申请虚拟内存建立页表项。（用于高端内存）\n\n定义高端内存的目的是让内核的虚拟内存空间有能力访问到全部的物理内存空间，因此，当实际物理内存地址小于内核虚拟内存地址时，高端内存就不再需要了。这体现在物理内存小于 1G 的 32 位系统上和 64 位系统上。而高端内存内部会进一步的划分为多个部份，用于不同的非直接映射方式，这包括：\n内核动态映射空间（noncontiguous memory allocation）：通过 vmalloc 分配可能不连续的物理地址到虚拟地址上连续的内存地址。\n持久内存映射（persistent kernel mappings）：在 KMAP_BASE-FIXADDR_START 之间，使用 alloc_page(GFP_HIGHMEM) 分配高端内存页或者使用 kmap/kunmap 函数将分配到的高端内存会映射到该区域。通常情况下，这个空间是 4M 大小，相应页表叫 pkmap_page_table，该页表的页基址是 swapper_pg_dir。【？swapper_pg_dir 是这样吗？】\n临时映射（temporary kernel mapping）：kmap/kunmap 可能会因为内存不够而睡眠，因此不能用于中断处理程序。对中断服务程序中的内核内存分配，可以使用 kmap_atomic/kunmap_atomic 在临时映射区来完成。该区域位于 FIXADDR_START-FIXADDR_TOP 之间，每个 CPU 占用其中一块空间，这部分空间又会根据不同用途进一步细化，这定义在 kmap_types.h -> km_type 中。注意，kmap_atomic 操作是原子性的，因为在中断服务程序中的任意时间，每个 CPU 在临时映射区都有各自可用的一块内存地址空间，所以该操作不会阻塞。\n固定映射（fixmaps）：在编译时会直接根据各种用途分配物理地址，区域位于 FIXADDR_START-FIXADDR_END 。"}},"/tutorial/operating-system/linux-kernel/10":{"title":"缓存","data":{"":"flush_dcache_page\nhttps://blog.csdn.net/zrlean/article/details/8644388\n\n\nicache/dcache\nhttps://zhuanlan.zhihu.com/p/112704770"}},"/tutorial/operating-system/linux-kernel/11":{"title":"进程管理","data":{"":"Linux 通过 slab 分配器分配 task_struct 结构，用来达到对象复用和缓存着色（cache coloring）的目的。各个进程的 task_struct 存放在内核栈的尾端。每个任务的 thread_info 结构在每个进程都有一个 thread_info 和一个 task_struct，其中 task_struct 是通俗意义上的进程描述符或 PCB（进程控制块），而 thread_info 则\n内核栈：用户进程执行系统调用时，系统调用函数在内核态运行时需要的栈空间，每个进程分配一个，位于内核空间\n用户栈：用户进程执行用户态函数时的栈空间，每个进程分配一个\n\n\n老的 UNIX 和 Linux 是每个 CPU 只有一个内核栈，因此不允许用户态程序抢占正在执行系统调用的另一个用户态程序。现在最新的 Linux 系统是每个进程一个内核栈了，从而允许系统调用的抢占。\n\n用户内存空间，每个用户进程都有各自独立的内存空间，保持彼此独立透明，互不干扰。\n内核内存空间，内核线程间无需切换页表，共享内存空间。\n\n\n带 MMU 的CPU处理的数据地址，全都是虚拟地址；经过 MMU 处理后的地址，到达北桥，为PA地址（linux称为PA，或者物理地址，但其实还不是真正的物理地址）；经过北桥，到其他IP核或外设，一般还会做地址映射，这才是真正访问内存硬件或其他外设的地址，称为dma地址（真正的物理地址）；\n\n作者：长平\n链接：https://www.zhihu.com/question/43699081/answer/123960191\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\nWhen changing protection levels from user to kernel mode, the kernel shouldn't use the stack of the user process, because it may not be valid. The user process may be malicious or contain an error that causes the user %esp to contain an address that is not part of the process's user memory.\n\n作者：一块五毛二\n链接：https://www.zhihu.com/question/43699081/answer/1060669706\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\nLinux-PC 可以通过 kdump 建立调试环境\nhttps://www.cnblogs.com/yanghaizhou/p/7704421.html\n\nhttps://www.zhihu.com/question/57013926\nthread_info\nhttps://blog.csdn.net/gatieme/article/details/51577479\nhttps://www.cnblogs.com/yungyu16/p/13023982.html\nhttps://www.cnblogs.com/Tattoo-Welkin/p/10335269.html\nhttps://www.cnblogs.com/sky-heaven/p/15991962.html\nhttps://blog.csdn.net/u014426028/article/details/108037971\n\n\ntask_struct\nhttps://blog.csdn.net/gatieme/article/details/51383272#t6"}},"/tutorial/operating-system/linux-kernel/2":{"title":"1.2.性能优化","data":{"":"与直接访问物理地址相比，虚拟地址转换的过程无疑额外的增加了时间和空间开销。本节介绍针对这些开销的优化方案。","多级页表#多级页表":"上述介绍的分页操作，页表项最多有 $2^20$ 个，这一数量可以通过多级页表进行优化。将虚拟地址除页偏移外的地址分为 n 部份，第 i 部份为第 i 级页表的页号，第 i 级页号得到 i+1 级页表的页基址，以此类推，直到最后一级页表得到物理块号。以二级页表为例，前 20 位地址可以分为 12+8，这样每个一级页表页表项数量是 $2^12 = 4096$，二级页表页表项是 $2^8 = 256$。如果只是拆分，那么表示全部的虚拟地址所需要的页表项的数量并没有变少。多级页表和单级页表的不同，在于二级之后的页表不需要在进程创建时全部创建，只需要根据进程的实际需要动态加载，从而减少的大量的空白页表项的开销。\n此时，一级页表仍然实现了描述全部虚拟地址空间的作用。\n\n关于各种体系下页表的细节，可以阅读 这篇文章。","页缓存#页缓存":"对多级页表转换地址过程中多次访存带来的时间开销，可以通过缓存技术进行优化。和页表相关的缓存包括三部分：\nTLB（Translation Lookside Buffer）：也称快表，一般看做是 MMU 内部针对页表的专用缓存\npaging structure caches：针对多级页表的每一级的缓存\nL1/L2 Cache：通用缓存，MMU\n\n\n有多个描述来形容这一过程：面多了加水/水多了加面，空间换时间和时间换空间，trade-off","大页#大页":"针对多级页表的时间开销，还可以通过 hugepage 来进行优化，中文叫做大页、巨型页等，指的就是大小远超 4KB 的页。大页可以显著减少页表数量、减少缓存 miss 率。\nDPDK 使用了 1GB 的大页内存，这样 DPDK 进程的页表映射只占用一个 TLB 表项，在进程执行过程中杜绝了 TLB miss 情况的发生，保障了性能。"}},"/tutorial/operating-system/linux-kernel/3":{"title":"1.3.内存分配","data":{"":"在 NUMA 架构下，物理页面按照 node -> zones -> pages 的树形结构进行管理。","内核内存分配#内核内存分配":"","buddy#buddy":"Linux 内核中有多种分配内存的方式，其中最基本的是 buddy 内存分配器，该分配器以页为单位，通过 alloc_pages 对外提供可用的物理页。\nstruct page * alloc_pages(unsigned int gfp_mask, unsigned int order)\n将空闲页面按照 order 的大小分配挂到不同的 order 链表中。buddy 分配器内部维护一个链表数组，空闲页面（free pages）按照 order 大小分配到不同的链表中。其中 order 表示 2 的阶数，一个大小为 order 的链表内部以 $2^order$ 为单位存储空闲页面块。当内核通过 alloc_pages 申请 order=n 的页面时，buddy 分配器会判断 order=n 的链表内是否有空闲页面，如果有则直接分配，如果没有，则从 order=n+1 的链表中取出一个空闲页面拆分成两个 order=n 的空闲页面挂载到 order=n 的链表下，并返回其中一个。当释放某个页面时，将释放的页面挂载到相同 order 的链表下，如果发现连续地址，则按照类似的方式反向向上合并。每个 zone 内部会维护一个水位线数组，包括WMARK_HIHG/WMARK_LOW/WMARK_MIN，分别表示内存足够，内存较少和内存见底，内存余量小于 WMARK_LOW 时，某些内存申请可能会失败；内存余量小于 WMARK_MIN 时，会触发内存回收、交换等机制避免 OOM。","slab#Slab":"buddy 内存分配是最底层的分配机制，从 buddy 分配器申请的物理内存的最小单位是一页，对于更小的内核结构体的内存需求，Linux 内核通过 Slab 分配器进行管理。Slab 分配器以字节为单位分配内存，在分配过程中，上游是从 Buddy 分配器申请得到的以页为单位的内存，下游则向操作系统和应用提供 kmalloc 和 kfree 接口。为了减少内存碎片，针对不同的专用或通用需求，一个操作系统可以存在多个 Slab，如对 vm_area_struct、mm_struct 等结构的分配是通过专用 Slab 分配器完成的。一个 buddy 分配器会分配多个 Slab 分配器，用来处理不同的内存申请大小，每个 Slab 分配器维护一个 kmem_cache 结构，来描述从 buddy 申请到的物理内存。","vmalloc#vmalloc":"Slab 提供的 kmalloc 保证函数只从低端内存（lowmem）申请内存，根据低端内存的映射规则，其申请到的内存在物理上也是连续的。但在 Linux 启动一段时间后，可能无法满足较大的连续物理内存的申请。对于这部分特殊需要，Linux 内核提供了 vmalloc/vfree 接口。vmalloc 仍然基于 buddy，和 slab 不同的是，vmalloc 可以同时从高端和低端内存申请物理内存。因此 vmalloc 申请到的连续的虚拟内存背后对应的物理内存地址可能不连续。根据这里的介绍，Slab 方式提供的 kmalloc 和 kfree 接口能够处理大多数情况内核对内存的需求，且 vmalloc 对页表的依赖导致其申请到的内存的性能远低于 kmalloc，因此，除非需要获取一段超大区域的内存，否则没有必要使用 vmalloc","进程内存分配#进程内存分配":"用户态的 malloc 是通过 brk/mmap 系统调用每次向内核申请一页，然后在标准库里再做进一步管理供用户程序使用。","内存回收#内存回收":"buddy 分配器内部会维护一个 watermark可以被回收的内存，大致可以分为以下两类：\n文件映射的页，包括 page cache、slab 中的 dcache、icache、用户进程的可执行程序的代码段，文件映射页面。\n匿名页，括进程使用各种 api（malloc,mmap,brk/sbrk）申请到的物理内存(这些 api 通常只是申请虚拟地址，真实的页分配发生在 page fault 中)，包括堆、栈，进程间通信中的共享内存，pipe，bss 段，数据段，tmpfs 的页。这部分没有办法直接回写，为他们创建 swap 区域，这些页也转化成了文件映射的页，可以回写到磁盘。\n\n对于内核并不是所有的物理内存都可以参与回收，比如内核的代码段，如果被内核回收了，系统就无法正常运行了，所以一般内核代码段、数据段、内核申请的内存、内核线程占用的内存等都是不可以回收的，除此之外的内存都可以是我们要回收的目标。\n哪些情况下需要回收？\n回收的是哪些内存？","内存迁移#内存迁移":"","交换空间#交换空间":"交换空间（swap space）是位于磁盘上的一块存储区域，可以用于断电休眠、释放物理内存防止 OOM。在内存空间不足时，根据某种调度策略，将已经分配给某个进程的页块存储到物理硬盘上，腾出该页的内存分配给当前需要的进程。交换的过程：\n根据策略（如 LRU）选择一个物理块\n找到使用该物理块的虚拟地址（反向映射），删除相应的页表项\n将该物理块写入到硬盘中\n【检查】"}},"/tutorial/operating-system/linux-kernel/4":{"title":"1.内存管理","data":{"":"软硬件支持\nUMA/NUMA\nCPU 访存\n\n\n寻址\n页表（单级页表）\n进程的内存空间（mm_struct）\n缺页中断（按需调页、写时复制）\n反向寻址（反向映射）\n\n\n内存模型\n安全性分析\n高端地址\n\n\n性能优化\n多级页表\n缓存（TLB、普通缓存、paging structure caches）\n大页（hugepage）\n\n\n内存分配\n进程内存分配\n内核内存分配\n反碎片技术\n内存回收\n交换\n\n\n\n\n待定\n内存布局\n/dev/mem\n内核对用户数据的处理（copy_from_user）\n文件缓存（有名映射和匿名映射）\n缓存","cpu-内存架构#CPU-内存架构":"如果每个处理器核心共享相同的内存地址空间，这样的架构就称为UMA(Uniform Memory Access)。对非一致性内存访问（NUMA，Non-Uniform Memory Access）不同的内存器件和 CPU 核心从属不同的 Node，每个 Node 都有自己的集成内存控制器（IMC，Integrated Memory Controller）。在 NUMA 架构下，CPU 访问不同的物理内存的速度会存在十分明显的差别。这是 Linux 内核内存管理的硬件基础。","mmu#MMU":"现代的内存管理方案是硬件和软件（操作系统）共同协同后得到的。在硬件上提供的与内存有关的支持包括三方面：\n**页表支持：**提供虚拟地址到物理地址转换的硬件支持，包括存储页表基地址的寄存器（如 TTBRx_ELx、CR[0-3] 寄存器）、页表访存单元（table work unit，用于访问在物理内存中的页表的操作）等\n缓存： 在寻址时能够更快的实现虚拟地址到物理地址的转换，这包括 TLB、paging structure caches、高速缓存等\n缺页中断：在无法正确将虚拟地址转换为物理地址时，向处理器发出缺页硬件中断\n\n这些功能主要是由 MMU 提供的。一些 CPU（如 i386）中还额外提供了段式存储管理，即程序中所使用的地址一律先进行段式映射（段基址:段偏移），再进行页式映射，这一操作在硬件层面上无法绕过，但是 Linux 在软件层面上将全局段描述符表 GDT 中用到的段描述项均设置为基地址为 0 的 4GB 大小的虚拟空间，仅在内核态和用户态标识上存在区分。因此可以理解为 Linux 内核并不是所谓的段页式内存管理，而是在 hack 式的绕过了硬件的段式映射要求后，使用的页式内存管理。在硬件的约束下，Linux 内核设计了不同的数据结构和接口，这包括：\n数据结构\nstruct page：每个 page 数据结构代表着一个物理页面，包含全部物理页面的 page 数组由一个全局指针变量 mem_map 定位。\nstruct mm_struct：内存描述符，每个进程分配一个 mm_struct，此外内核有一个单独设置的 mm_struct。mm_struct 表明了对虚存空间的需求\nstruct vm_area_struct：每个 vm_area_struct 代表虚拟内存空间中一段连续的、具有相同访问权限的区域，每个进程有多个 vm_area_struct，用链表或平衡树（AVL 树/红黑树）来组织。\nstruct vm_struct：和 vm_area_struct 类似，不过 vm_area_struct 是给用户进程用的，而 vm_struct 是给内核使用的\nlinux/mmzone.h -> struct zone：描述物理页面的 page 数组被划分为 ZONE_DMA、ZONE_NORMAL、ZONE_HIGHMEM（ZONE_HIGHMEM 为高端内存，可能有）三个管理区，用于不同的内存需求（如 ZONE_DMA 用于专供 DMA 的 IO 操作）。\nlinux/mmzone.h -> struct pglist_data：即 pg_data_t，每个 pg_data_t 管理多个 zone\nstruct pglist_data *node_data[MAX_NUMNODES]：用于 NUMA 结构，每个 CPU node 分配一个 pglist_data。\n...\n\n\n操作模块\nbuddy 分配器：以页为单位分配内存，每个 zone 会分配一个 buddy 内存分配。\nslab 分配器（kmalloc、kfree）：用于内核态细粒度空间分配\nmalloc、free：用于用户态堆内存细粒度分配\nbrk、sbrk：扩展堆边界【？存疑】\nmmap、munmap：建立虚拟内存和文件之间的映射，这里的文件，可以是硬盘上的具体的某个文件，也可以是物理内存上的一段空间（匿名文件/匿名映射）。vm_area_struct 实际是在 mmap 执行过程中创建的。\n缺页中断服务程序 do_page_fault：页错误处理，会根据不同的缺页类型调用不同的缺页函数，包括抛出异常、分配物理页面、将硬盘换入物理内存（ext2_readpage()）等\n对内存回收的相关接口\n...\n\n\n\nLinux 系统下查看内存管理区可以通过 cat /proc/buddyinfo 来完成：\ncat /proc/buddyinfo\n> Node 0, zone      DMA      1 ...\n> Node 0, zone    DMA32    975 ...\n> Node 0, zone   Normal     71 ...\n寻址长度可以在 cat /proc/cpuinfo 中找到\ncat /proc/cpuinfo | grep address\naddress sizes\t: 48 bits physical, 48 bits virtual\n\n页表有几个？由谁持有？\n页表存在哪？\n为什么需要高端内存？\n\n\n中断服务程序\n进程上下文切换\n\n\nhttps://cloud.tencent.com/developer/article/1950803\n《Linux 内核源代码情景分析》\nhttps://www.cnblogs.com/LoyenWang/p/11406693.html\nhttps://juejin.cn/post/7088209331035848711 一些图画的很好\nslab\nhttps://zhuanlan.zhihu.com/p/358891862\nhttps://www.dingmos.com/index.php/archives/23/#cl-9\nhttps://blog.csdn.net/hzj_001/article/details/99705452\nkmem_cache\nhttps://blog.csdn.net/a7980718/article/details/77739573\nhttps://blog.csdn.net/YuZhiHui_No1/article/details/47305361\n\n\nhttps://www.cnblogs.com/LoyenWang/p/11922887.html\nhttps://blog.51cto.com/leejia/1431756\nhttps://blog.csdn.net/zhoutaopower/article/details/89389254\nhttps://zhuanlan.zhihu.com/p/491500340\n\n\n段描述符\nhttps://blog.51cto.com/u_14207158/2575739\nhttps://www.cnblogs.com/zpchcbd/p/15862009.html\nhttps://www.cnblogs.com/wingsummer/p/15312627.html\n\n\nmalloc\nhttps://www.cnblogs.com/luoleqi/p/12731875.html\nhttps://blog.csdn.net/Apollon_krj/article/details/54565768\n\n\n高端内存\nhttps://www.zhihu.com/question/280526042\nhttps://cloud.tencent.com/developer/article/1374639\nhttps://www.cnblogs.com/xingmuxin/p/10967716.html\nhttps://unix.stackexchange.com/questions/4929/what-are-high-memory-and-low-memory-on-linux\nhttps://stackoverflow.com/questions/68091247/confusion-about-different-meanings-of-highmem-in-linux-kernel\nhttps://biscuitos.github.io/blog/MMU-Linux4x-FIXUP/\n\n\nMMU\nhttps://zhuanlan.zhihu.com/p/402806252\nhttps://zhuanlan.zhihu.com/p/399726541\n\n\nCR3\nhttps://blog.csdn.net/SweeNeil/article/details/106171361\n\n\nvm_area_struct\nhttps://zhuanlan.zhihu.com/p/431713219\n[ ]\n\n\n地址总线、数据总线\nhttps://blog.51cto.com/u_13800449/3067938\n\n\n分页大小 Linux 内核\nhttps://zhuanlan.zhihu.com/p/458935522\n\n\n多级页表\nhttps://www.zhihu.com/question/63375062/answer/1403291487\n\n\nmm_struct\nhttps://blog.csdn.net/LF_2016/article/details/54346121\n\n\n内存回收\nhttps://blog.csdn.net/u012489236/article/details/120587124\n交换\nhttps://zorrozou.github.io/docs/books/linuxde_nei_cun_hui_shou_he_jiao_huan.html\nhttps://segmentfault.com/a/1190000008125116\n\n\n\n\nstruct page\nhttps://www.cnblogs.com/emperor_zark/archive/2013/03/15/linux_page_1.html\n\n\n反碎片技术\nhttps://blog.csdn.net/WANGYONGZIXUE/article/details/126005158\nhttps://zhuanlan.zhihu.com/p/565464633\nhttps://cn.pingcap.com/blog/linux-kernel-vs-memory-fragmentation-1\nhttps://article.itxueyuan.com/WPG1m\n\n\n文件缓存\nhttps://www.cnblogs.com/luozhiyun/p/13061199.html\n\n\n虚拟内存模型\nhttps://stackoverflow.com/questions/50655241/virtual-memory-usage\n高端内存\nhttps://blog.csdn.net/liuzheng1/article/details/78282760\n\n\n\n\n永久映射、临时映射\nhttps://blog.csdn.net/faxiang1230/article/details/105995416\n\n\nfixmap addr\nhttp://www.wowotech.net/memory_management/440.html\nhttps://biscuitos.github.io/blog/MMU-Linux4x-FIXUP/\n\n\ncopy_from_user\nhttps://blog.51cto.com/xiaojielinux/1874080\n\n\nNUMA\nhttps://qumulo.com/blog/non-uniform-memory-access-numa/\nhttps://zhuanlan.zhihu.com/p/67558970\nhttps://zhuanlan.zhihu.com/p/527516996\n\n\n内存分配\nhttps://blog.csdn.net/longwang155069/article/details/105529591\nhttps://zhuanlan.zhihu.com/p/363923438\nhttp://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch11lev1sec5.html#:~:text=The%20vmalloc()%20function%20only,of%20the%20logical%20address%20space.\nhttps://jishuin.proginn.com/p/763bfbd5733b\n\n\n可执行文件的内存布局\nhttps://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4\n\n\n各种物理数据结构的转换和索引（PA<->VA, page<->zone。。。）\nhttps://www.cnblogs.com/arnoldlu/p/8335568.html\n\n\nmmap 系统调用\nhttps://zhuanlan.zhihu.com/p/527532465\n\n\nvm_area_struct\n优先树 https://zhuanlan.zhihu.com/p/539591726\n\n\n微架构\n玄铁C910 https://zhuanlan.zhihu.com/p/512960206\n\n\n页面回收\nhttps://www.cnblogs.com/sky-heaven/p/5657824.html"}},"/tutorial/operating-system/linux-kernel/5":{"title":"2.进程管理","data":{"":"进程是资源分配的基本单位，在 Linux 内核中的进程描述符是 task_struct。线程是 CPU 执行的基本单位，在 Linux 内核中线程的创建过程和进程基本等同，同样会分配一个 task_struct。每个 CPU 维护一个就绪队列，由 struct rq 表示\n进程状态\n进程的内存空间（内核栈）\ntask_struct\n\n\n进程间通信\n调度\n调度器\n进程优先级\nSMP/NUMA 组织\n\n\n\n\n调度器\nhttps://www.cnblogs.com/ck1020/p/6089970.html\nThreadInfo 结构和内核栈的两种关系 https://blog.csdn.net/longwang155069/article/details/104346778"}},"/tutorial/operating-system/linux-kernel/6":{"title":"README","data":{"":"1：内存管理内存原理：SMP/NUMA 模型组织、页表/页表缓存、CPU 缓存、内存映射虚拟内存：伙伴分配器、块分配器、巨型页、页回收、页错误异常处理与反碎片技术、连续内存分配器技术原理、不连续页分配器原理与实现内存系统调用：kmalloc/vmalloc、内存池原理与实现、内存优化与实现2：文件系统虚拟文件系统 VFS：通用文件模型、数据结构、文件系统调用、挂载文件系统、无存储文件系统磁盘文件系统：Ext2/Ext3/Ext4 文件系统、日志 JBD2用户空间系统:FUSE 原理机制/接口与实现3：进程管理进程基础：进程原理及状态、生命周期及系统调用、task_struct 数据结构进程调度：调度策略、进程优先级、调度类分析、SMP 调度4：网络协议栈网络基础架构:：SKB/net_device、网络层分析、Linux 邻近子系统、netlink 套接字、iptables 套接字、netfilter 框架、内核 NIC 接口分析、mac80211 无线子系统网络协议栈：internet 控制消息协议（ICMP）、用户数据报协议（UDP）、传输控制协议（TCP）、流控制传输协议（SCTP）、数据报拥塞控制协议（DCCP）、IPv4 路由选择子系统、组播/策略/多路径路由选择、接收/发送（IPv4/IPv6）数据报、infiniBand 栈的架构系统 API 调用：POSIX 网络 API 调用、epoll 内核原理与实现、网络系统参数配置5：设备驱动设备子系统：I/O 机制原理、设备模型、字符设备子系统、网络接口卡驱动Linux 设备模型：LDM、设备模型和 sysfs字符设备驱动：主设备与次设备、设备文件操作、分配与注册字符设备、写文件操作实现网卡设备驱动：数据结构、设备方法、驱动程序块设备驱动：资源管理、I/O 调度、BIO 结构原理、PCI 总线原理蓝牙子系统：HCI 层/连接、L2CAP、BNEP、蓝牙数据包接收架构\nhttp://books.gigatux.nl/mirror/kerneldevelopment/0672327201/toc.html"}},"/tutorial/operating-system/linux-kernel/7":{"title":"内存管理","data":{"":"每个物理页在 Linux 中都会分配一个 <mmtypes.h> struct page 结构进行管理。\nstruct page {\n\n}\n页表实际上是硬件和软件合作的产物，虚拟内存和物理内存都是由操作系统管理的，虚拟地址到物理地址的映射也是软件进行设置，这是软件层面。而硬件层面，MMU 规定了软件需要将存储页表的物理基地址提交给特定的寄存器中，且保证每一级页表的内容需要占用连续的物理地址，这样 MMU 才能通过地址偏移找到对应的物理地址。","slab-分配器#Slab 分配器":"SMP 对称多处理器支持\n\n在对称多处理系统上，在操作系统的支持下，无论行程是处于用户空间，或是核心空间，都可以分配到任何一个处理器上运行。因此，行程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。\n高端内存是非常容易混淆的点，这主要包括以下几个问题：\n什么是高端内存\n为什么需要高端内存\n\n对虚拟内存，高端内存指内核空间的 128 MB。\n对物理内存，高端内存指的是页表是软件实现的，但是页表的查找是 MMU 完成的，所以硬件定义了页表的实现规则，软件可以做的只有选择页表的级数，是否使用 huge page 以及填充对应的权限标志位。如果处理器没有 MMU，或者有 MMU 但没有启用，CPU 执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为 PA（Physical Address，以下简称 PA），如下图所示。如果处理器启用了 MMU，CPU 执行单元发出的所有内存地址将被 MMU 截获，从 CPU 到 MMU 的地址称为虚拟地址（Virtual Address，以下简称 VA），而 MMU 将这个地址翻译成另一个地址发到 CPU 芯片的外部地址引脚上，也就是将 VA 映射成 PA，如下图所示。\nTTBR0 寄存器\nTTBCR 寄存器\nMMU 使能寄存器：控制 MMU 是否开启。在开启 MMU 之前，页表就必须准备好，但是并不要求该页表是完整的，实际上在初始化过程中，可以只建立需要访问的虚拟地址对应的临时映射页表即可，页表的配置实际上是存在一定的灵活性的。\nPGD、PTE 页表：一级页表和二级页表\nPGD（页全局目录），pgd_t，指向 PMD\nPMD（中间页目录）， pmd_t，指向 PTE\nPTE（页表），pte_t，指向物理页面","页表缓存#页表缓存":"虚拟内存-> 物理内存转换时查询物理地址的顺序： TLB -> paging structure caches -> 普通 cache 中的页表 -> 内存中的页表large page 的使用可以减少页表的级数，也就减少了查找页表的内存访问次数，而且对于同样 entries 数目的 TLB，可以扩大 TLB 对内存地址的覆盖范围，减小 TLB miss 的概率。此外，因为页表本身也要占用内存空间，减少页表的大小也可以节约那么一丢丢的内存。当然，使用 large page 也会带来一些问题，比如：由于各种内存操作基本都要求按照 page 对齐，比如一个可执行文件映射到进程地址空间，根据文件大小的不同，平均算下来会浪费掉半个 page size 的物理内存，使用 large page 的话这个消耗就显得比较大了。\n系统运行一段时间后，会很难再也大块的连续物理内存，这时分配 large page 将会变的很困难，所以通常需要在系统初始化的时候就划分出一段物理内存给 large page 用（类似于 DMA 的内存分配），这样就减少了一些灵活性。\n动态 large page（THP）在换出到外部的 flash/disk 和从 flash/disk 换入物理内存的过程会比 normal size 的 page 带来更大的开销（可参考这篇文章）。在内核看来，用户态提供的虚拟地址是不可信的，所以在一旦在内核态访问用户态内存发生缺页中断，处理起来是非常棘手的。Linux 内核的做法是提供了一张 异常处理表 ，使用专有的函数来访问用户态内存。类似 try-catch 块一般。具体详情可参见 copy_to_user/copy_from_user 的实现以及内核文档 Documentation/x86/exception-tables.txt 的描述。在 copy_from_user 时，会去进行指针检查，然后如果没有映射，会触发 page_fault,如果指针不合法，也会检查。这句话是重点！也正是 copy_from_user 的作用所在。就 LINUX 内存管理机制来说，在 x86 平台下用 CR3 寄存器来保存页目录表的物理地址，无论内核态或用户态使用同一张页目录表，用户态或内核态都是通过同一个页目录找到线性地址对应的物理地址。因此内核态可以通过页目录表找到用户态指针指向的地址，这样就可以不使用 copy_from_user 来直接操作用户态传入内核的指针(只要这个指针合法)，用户态不能直接使用内核指针的主要原因是因为权限不够(ring3 不能访问 ring0 地址空间)。内核可以通过以下函数间接的访问用户空间：\naccess_ok\tChecks the validity of the user space memory pointer\tget_user\tGets a simple variable from user space\tput_user\tPuts a simple variable to user space\tclear_user\tClears, or zeros, a block in user space\tcopy_to_user\tCopies a block of data from the kernel to user space\tcopy_from_user\tCopies a block of data from user space to the kernel\tstrnlen_user\tGets the size of a string buffer in user space\tstrncpy_from_user\tCopies a string from user space into the kernel\n内核函数却不能直接解引用用户空间的指针，基于以下原因：\n用户空间的指针指向的地址可能在内核运行期间无效\n即使指针有效但是指针指向的数据却不驻留在内存中，就会造成缺页异常\n指针可能由于程序的恶意或错误产生，直接访问就会造成系统的不稳定\nhttps://blog.csdn.net/m0_47696151/article/details/118770472\n\n\nhttps://juejin.cn/post/6950275689345974308\n\n\n如果(addr + size) >= (current_thread_info()->addr_limit) - 1，返回非零值\n如果(addr + size) < (current_thread_info()->addr_limit)，返回零","vm_area_struct#vm_area_struct":"进程的 task_struct 中存了 mm_struct 的指针 mm，task_struct 中存了 vm_area_struct 的链表结构每个 vm_area_struct 都代表虚拟内存空间中一段连续的、具有相同访问权限的区域。包含下面的成员：vm_start：指向这个区域的起始处\nvm_end：指向这个区域的结束处\nvm_prot：描述这个区域所有页的读写许可权限\nvm_flags：描述这个区域内的页面是与其他进程共享的还是私有的\nvm_next：指向链表下一个区域结构\n当访问某个页面发生缺页中断，需要查询这个页面属于哪一个 vm_area_struct。而为了加快查找的速度，内核将 vm_area_struct 又组织成了一个红黑树。根据查找的结果，有三种处理方式：如果不在任何一个区域中，说明这个页面是非法的，触发段错误\n如果内存访问不合法，比如想要写这个页面，而这个页面所在的区域是只读的，这时候触发保护异常，中止程序。\n前两种情况都不存在，就选择一个物理页面来缓存，必要的时候要选择牺牲页面，还要将脏页写回。\n————————————————\n版权声明：本文为 CSDN 博主「不动心、」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/sinat_41619762/article/details/118972204x86 平台上，在进程切换的时候，软件不需要显示的调用 tlb flush 函数，在 switch_mm 函数中会用 next task 中的 mm->pgd 加载 CR3 寄存器，这时候 load cr3 的动作会导致本 cpu 中的 local tlb entry 被全部 flush 掉。https://blog.csdn.net/SweeNeil/article/details/106171361\nhttps://zhuanlan.zhihu.com/p/488042885","内存描述符#内存描述符":"内存使用内存描述符 mm_struct 表示进程的地址空间虚拟页的三种状态的实际含义如下：未分配虚拟页，指的是没有使用 mmap 建立 vm_area_struct，所以也就没有对应到具体的页表项\n已分配虚拟页，未映射到物理页，指的是已经使用了 mmap 建立的 vm_area_struct，可以映射到对应的页表项，但是页表项没有指向具体的物理页\n已分配虚拟页，已映射到物理页，指的是已经使用了 mmap 建立的 vm_area_struct，可以映射到对应的页表项，并且页表项指向具体的物理页https://zhuanlan.zhihu.com/p/431713219\nmmap 函数就是要创建一个新的 vm_area_struct 结构，并将其与文件的物理磁盘地址相连https://blog.csdn.net/Windgs_YF/article/details/114587330\ngood_area\nbad_area：用户空间访问未在 vma 中分配的空间\n\n包括两种情况\n需要一个空白的内存，作为函数调用栈空间或堆空间\n因为按需调页或交换，需要从磁盘交换写入到内存中\n\nmalloc 的实现,它有一个 chunk 仓库管理 128 字节以下的小块(chunk 仓库类似链表数组,)。之所以有 chunk 仓库是因为为了避免多次系统调用,快速获取内存块,因为从用户态到内核态的转换很耗时的(改变 cs,ds,ss,各种参数压栈等等),而有了 chunk 仓库可以直接在用户态获取内存块,chunk 仓库类似链表数组,其块大小由 2 的 n 次方构成,最大的块是 128 字节. malloc 如果分配超过了 128 字节将调用 brk 系统调用(改变堆界限,同时创建 vma) 如果 malloc 分配超大内存（具体是多少忘了）,那就直接 mmap 匿名映射了创建 vma 结构。作者：Tools boy\n链接：https://www.zhihu.com/question/57653599/answer/154146640\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。进程访存通过 CR3 基地址寄存器内核访存低端地址 896Mb 内直接减 0xC0000000 得到，高端地址通过动态临时的建立到其他全部物理空间的映射\nhttps://zhuanlan.zhihu.com/p/358891862\nhttps://blog.csdn.net/maokelong95/article/details/51989081\nhttps://blog.csdn.net/jasonchen_gbd/article/details/79461385\nhttps://zhuanlan.zhihu.com/p/556563925\nhttps://blog.csdn.net/Apollon_krj/article/details/54565768\n高端内存\nhttps://www.zhihu.com/question/280526042\n\n\nMMU 硬件对页表的支持\nhttps://zhuanlan.zhihu.com/p/363856783\nhttps://zhuanlan.zhihu.com/p/67813716\nhttps://zhuanlan.zhihu.com/p/65298260\nhttps://cloud.tencent.com/developer/article/1815567\n\n\n大页\npaging struct caches https://zhuanlan.zhihu.com/p/65774094\ncopy_to_user： https://blog.csdn.net/dog250/article/details/106105523\n综述\nhttps://www.cnblogs.com/titer1/archive/2012/04/10/2440238.html\n\n\nBuddy 系统\nhttps://zhuanlan.zhihu.com/p/363928310"}},"/tutorial/operating-system/linux-kernel/8":{"title":"内核启动","data":{"":"自举\n临时页表"}},"/tutorial/operating-system/linux-kernel/9":{"title":"文件管理","data":{"":"超级块\nhttps://www.cnblogs.com/betterquan/p/11369364.html\nhttps://www.eet-china.com/mp/a38145.html"}},"/tutorial/operating-system/linux-kernel":{"title":"Index","data":{"":""}},"/blog":{"title":"Blog","data":{"":""}},"/tutorial/computer-network/7":{"title":"4.1.RPC协议","data":{"":""}}}